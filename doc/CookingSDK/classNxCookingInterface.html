<html>
<head>
<title>Cooking SDK API Reference: NxCookingInterface Class Reference</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">

<LINK HREF="../stylesheet.css" REL="stylesheet" TYPE="text/css">

</head>

<body bgcolor="#FFFFFF">
<img alt="" src="images/PhysXlogo.png" align="middle"> <br>

<center>

<hr>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp;  </center>
<hr>
<!-- Generated by Doxygen 1.4.6-NO -->
<h1>NxCookingInterface Class Reference</h1><!-- doxytag: class="NxCookingInterface" --><code>#include &lt;<a class="el" href="NxCooking_8h-source.html">NxCooking.h</a>&gt;</code>
<p>
<a href="classNxCookingInterface-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxCookingInterface.html#d85ac53935f2bdcb77ae96efb64cc935">NxSetCookingParams</a> (const <a class="el" href="structNxCookingParams.html">NxCookingParams</a> &amp;params)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets cooking parameters.  <a href="#d85ac53935f2bdcb77ae96efb64cc935"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <a class="el" href="structNxCookingParams.html">NxCookingParams</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxCookingInterface.html#6994a293add0e111e909f39f47455ae0">NxGetCookingParams</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets cooking parameters.  <a href="#6994a293add0e111e909f39f47455ae0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxCookingInterface.html#11eef9338d63bfdb49603f5e31983b2e">NxPlatformMismatch</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks endianness is the same between cooking &amp; target platforms.  <a href="#11eef9338d63bfdb49603f5e31983b2e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxCookingInterface.html#77a9c996d8b7a3bd31fce87d6a2c16d5">NxInitCooking</a> (NxUserAllocator *allocator=NULL, NxUserOutputStream *outputStream=NULL)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes cooking.  <a href="#77a9c996d8b7a3bd31fce87d6a2c16d5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxCookingInterface.html#ab18902ae723323c7f863e793fd18865">NxCloseCooking</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Closes cooking.  <a href="#ab18902ae723323c7f863e793fd18865"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxCookingInterface.html#0c6080e44360f807bdbb553c53553e18">NxCookTriangleMesh</a> (const NxTriangleMeshDesc &amp;desc, NxStream &amp;stream)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cooks a triangle mesh. The results are written to the stream.  <a href="#0c6080e44360f807bdbb553c53553e18"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxCookingInterface.html#b2c568330ebea4109c827cc812caeb48">NxCookConvexMesh</a> (const NxConvexMeshDesc &amp;desc, NxStream &amp;stream)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cooks a convex mesh. The results are written to the stream.  <a href="#b2c568330ebea4109c827cc812caeb48"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxCookingInterface.html#ea54287e865c8a67e94e7b3eaaaf182c">NxCookClothMesh</a> (const NxClothMeshDesc &amp;desc, NxStream &amp;stream)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cooks a triangle mesh to a ClothMesh.  <a href="#ea54287e865c8a67e94e7b3eaaaf182c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxCookingInterface.html#a3a521ddecc58c6b6e0883638ab061c5">NxCookSoftBodyMesh</a> (const NxSoftBodyMeshDesc &amp;desc, NxStream &amp;stream)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cooks a tetrahedral mesh to a SoftBodyMesh.  <a href="#a3a521ddecc58c6b6e0883638ab061c5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxCookingInterface.html#d20ba8ea4d020fed99d909d0af742444">NxCreatePMap</a> (NxPMap &amp;pmap, const NxTriangleMesh &amp;mesh, NxU32 density, NxUserOutputStream *outputStream=NULL)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a PMap from a triangle mesh.  <a href="#d20ba8ea4d020fed99d909d0af742444"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxCookingInterface.html#0d08893310e1a40befbd190ec11f104c">NxReleasePMap</a> (NxPMap &amp;pmap)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Releases PMap previously created with NxCreatePMap.  <a href="#0d08893310e1a40befbd190ec11f104c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxCookingInterface.html#694bc32232d37aa1256897cc6abbab83">NxScaleCookedConvexMesh</a> (const NxStream &amp;source, NxReal scale, NxStream &amp;dest)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scales an existing cooked convex mesh and outputs it into another stream.  <a href="#694bc32232d37aa1256897cc6abbab83"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxCookingInterface.html#908253bf26fb5bbebdbbf23c03674c2e">NxReportCooking</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Report state of cooking memory usage.  <a href="#908253bf26fb5bbebdbbf23c03674c2e"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxCookingInterface.html#862fb003db2a361f4539543b6d2754de">~NxCookingInterface</a> ()</td></tr>

</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="862fb003db2a361f4539543b6d2754de"></a><!-- doxytag: member="NxCookingInterface::~NxCookingInterface" ref="862fb003db2a361f4539543b6d2754de" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual NxCookingInterface::~NxCookingInterface           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="ab18902ae723323c7f863e793fd18865"></a><!-- doxytag: member="NxCookingInterface::NxCloseCooking" ref="ab18902ae723323c7f863e793fd18865" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxCookingInterface::NxCloseCooking           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Closes cooking. 
<p>
This must be called at the end of your app, to release cooking-related data.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxCookingInterface.html#77a9c996d8b7a3bd31fce87d6a2c16d5">NxInitCooking()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ea54287e865c8a67e94e7b3eaaaf182c"></a><!-- doxytag: member="NxCookingInterface::NxCookClothMesh" ref="ea54287e865c8a67e94e7b3eaaaf182c" args="(const NxClothMeshDesc &amp;desc, NxStream &amp;stream)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool NxCookingInterface::NxCookClothMesh           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const NxClothMeshDesc &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>desc</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxStream &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>stream</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Cooks a triangle mesh to a ClothMesh. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>desc</em>&nbsp;</td><td>The cloth mesh descriptor on which the generation of the cooked mesh depends. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>The stream the cooked mesh is written to. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True if cooking was successful </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="b2c568330ebea4109c827cc812caeb48"></a><!-- doxytag: member="NxCookingInterface::NxCookConvexMesh" ref="b2c568330ebea4109c827cc812caeb48" args="(const NxConvexMeshDesc &amp;desc, NxStream &amp;stream)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool NxCookingInterface::NxCookConvexMesh           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const NxConvexMeshDesc &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>desc</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxStream &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>stream</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Cooks a convex mesh. The results are written to the stream. 
<p>
To create a triangle mesh object(unlike previous versions) it is necessary to first 'cook' the mesh data into a form which allows the SDK to perform efficient collision detection.<p>
<a class="el" href="classNxCookingInterface.html#0c6080e44360f807bdbb553c53553e18">NxCookTriangleMesh()</a> and <a class="el" href="classNxCookingInterface.html#b2c568330ebea4109c827cc812caeb48">NxCookConvexMesh()</a> allow a mesh description to be cooked into a binary stream suitable for loading and performing collision detection at runtime.<p>
<dl compact><dt><b>Note:</b></dt><dd><a class="el" href="classNxCookingInterface.html#77a9c996d8b7a3bd31fce87d6a2c16d5">NxInitCooking()</a> must be called before attempting to cook a mesh. <a class="el" href="classNxCookingInterface.html#ab18902ae723323c7f863e793fd18865">NxCloseCooking()</a> should be called when the application has finished using the cooking library.</dd></dl>
Example<p>
<div class="fragment"><pre class="fragment">
<span class="comment">//Make sure to initialize the cooking library.</span>
<a class="code" href="classNxCookingInterface.html#77a9c996d8b7a3bd31fce87d6a2c16d5">NxInitCooking</a>();

<span class="comment">//...</span>

<span class="comment">// Cook a convex mesh</span>
NxConvexMeshDesc coneMeshDesc;

coneMeshDesc.numVertices = CONE_NBVERTICES; <span class="comment">//Number of vertices in mesh.</span>
coneMeshDesc.numTriangles = CONE_NBFACES; <span class="comment">//Number of triangles(3 indices per triangle)</span>

coneMeshDesc.pointStrideBytes = <span class="keyword">sizeof</span>(NxVec3);<span class="comment">//Number of bytes from one vertex to the next.</span>
coneMeshDesc.triangleStrideBytes = 3*<span class="keyword">sizeof</span>(NxU32);<span class="comment">//Number of bytes from one triangle to the next.</span>

coneMeshDesc.points = gConeVertices;
coneMeshDesc.triangles = gConeTriangles;
coneMeshDesc.flags = 0;

<span class="comment">/*</span>
<span class="comment">** The cooked version of the mesh is written to UserStream, which is an implementation of NxStream.</span>
<span class="comment">** Alternatively MemoryReadBuffer/MemoryWriteBuffer could be used to store the cooked version of the </span>
<span class="comment">** mesh in memory. See SampleCommonCode for their implementation.</span>
<span class="comment">*/</span>

<a class="code" href="classNxCookingInterface.html#b2c568330ebea4109c827cc812caeb48">NxCookConvexMesh</a>(coneMeshDesc, UserStream(<span class="stringliteral">"c:\\cooked.bin"</span>, <span class="keyword">false</span>));

<span class="comment">//...</span>

<span class="comment">//release cooking related resources.</span>
<a class="code" href="classNxCookingInterface.html#ab18902ae723323c7f863e793fd18865">NxCloseCooking</a>()
</pre></div><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>The convex mesh descriptor to read the mesh from. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>stream</em>&nbsp;</td><td>User stream to output the cooked data. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>true on success</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxCookingInterface.html#0c6080e44360f807bdbb553c53553e18">NxCookTriangleMesh()</a> <a class="el" href="classNxCookingInterface.html#77a9c996d8b7a3bd31fce87d6a2c16d5">NxInitCooking()</a> <a class="el" href="classNxCookingInterface.html#d85ac53935f2bdcb77ae96efb64cc935">NxSetCookingParams()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a3a521ddecc58c6b6e0883638ab061c5"></a><!-- doxytag: member="NxCookingInterface::NxCookSoftBodyMesh" ref="a3a521ddecc58c6b6e0883638ab061c5" args="(const NxSoftBodyMeshDesc &amp;desc, NxStream &amp;stream)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool NxCookingInterface::NxCookSoftBodyMesh           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const NxSoftBodyMeshDesc &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>desc</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxStream &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>stream</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Cooks a tetrahedral mesh to a SoftBodyMesh. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>desc</em>&nbsp;</td><td>The soft body mesh descriptor on which the generation of the cooked mesh depends. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>The stream the cooked mesh is written to. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True if cooking was successful </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="0c6080e44360f807bdbb553c53553e18"></a><!-- doxytag: member="NxCookingInterface::NxCookTriangleMesh" ref="0c6080e44360f807bdbb553c53553e18" args="(const NxTriangleMeshDesc &amp;desc, NxStream &amp;stream)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool NxCookingInterface::NxCookTriangleMesh           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const NxTriangleMeshDesc &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>desc</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxStream &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>stream</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Cooks a triangle mesh. The results are written to the stream. 
<p>
To create a triangle mesh object(unlike previous versions) it is necessary to first 'cook' the mesh data into a form which allows the SDK to perform efficient collision detection.<p>
<a class="el" href="classNxCookingInterface.html#0c6080e44360f807bdbb553c53553e18">NxCookTriangleMesh()</a> and <a class="el" href="classNxCookingInterface.html#b2c568330ebea4109c827cc812caeb48">NxCookConvexMesh()</a> allow a mesh description to be cooked into a binary stream suitable for loading and performing collision detection at runtime.<p>
NxCookConvex requires the input mesh to form a closed convex volume. This allows more efficient and robust collision detection.<p>
<dl compact><dt><b>Note:</b></dt><dd><a class="el" href="classNxCookingInterface.html#77a9c996d8b7a3bd31fce87d6a2c16d5">NxInitCooking()</a> must be called before attempting to cook a mesh. <a class="el" href="classNxCookingInterface.html#ab18902ae723323c7f863e793fd18865">NxCloseCooking()</a> should be called when the application has finished using the cooking library.</dd></dl>
Example<p>
<div class="fragment"><pre class="fragment">
<span class="comment">//Make sure to initialize the cooking library.</span>
<a class="code" href="classNxCookingInterface.html#77a9c996d8b7a3bd31fce87d6a2c16d5">NxInitCooking</a>();

<span class="comment">//...</span>

<span class="comment">// Cook a mesh</span>
NxTriangleMeshDesc bunnyDesc;

bunnyDesc.numVertices = BUNNY_NBVERTICES; <span class="comment">//Number of vertices in mesh.</span>
bunnyDesc.numTriangles = BUNNY_NBFACES; <span class="comment">//Number of triangles(3 indices per triangle)</span>

bunnyDesc.pointStrideBytes = <span class="keyword">sizeof</span>(NxVec3);<span class="comment">//Number of bytes from one vertex to the next.</span>
bunnyDesc.triangleStrideBytes = 3*<span class="keyword">sizeof</span>(NxU32);<span class="comment">//Number of bytes from one triangle to the next.</span>

bunnyDesc.points = gBunnyVertices;
bunnyDesc.triangles = gBunnyTriangles;
bunnyDesc.flags = 0;

<span class="comment">/*</span>
<span class="comment">** The cooked version of the mesh is written to UserStream, which is an implementation of NxStream.</span>
<span class="comment">** Alternatively MemoryReadBuffer/MemoryWriteBuffer could be used to store the cooked version of the </span>
<span class="comment">** mesh in memory. See SampleCommonCode for their implementation.</span>
<span class="comment">*/</span>

<a class="code" href="classNxCookingInterface.html#0c6080e44360f807bdbb553c53553e18">NxCookTriangleMesh</a>(bunnyDesc, UserStream(<span class="stringliteral">"c:\\cooked.bin"</span>, <span class="keyword">false</span>));

<span class="comment">//...</span>

<span class="comment">//release cooking related resources.</span>
<a class="code" href="classNxCookingInterface.html#ab18902ae723323c7f863e793fd18865">NxCloseCooking</a>()
</pre></div><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>The triangle mesh descriptor to read the mesh from. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>stream</em>&nbsp;</td><td>User stream to output the cooked data. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>true on success</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxCookingInterface.html#0c6080e44360f807bdbb553c53553e18">NxCookTriangleMesh()</a> <a class="el" href="classNxCookingInterface.html#77a9c996d8b7a3bd31fce87d6a2c16d5">NxInitCooking()</a> <a class="el" href="classNxCookingInterface.html#d85ac53935f2bdcb77ae96efb64cc935">NxSetCookingParams()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="d20ba8ea4d020fed99d909d0af742444"></a><!-- doxytag: member="NxCookingInterface::NxCreatePMap" ref="d20ba8ea4d020fed99d909d0af742444" args="(NxPMap &amp;pmap, const NxTriangleMesh &amp;mesh, NxU32 density, NxUserOutputStream *outputStream=NULL)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool NxCookingInterface::NxCreatePMap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">NxPMap &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>pmap</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const NxTriangleMesh &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32&nbsp;</td>
          <td class="mdname" nowrap> <em>density</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxUserOutputStream *&nbsp;</td>
          <td class="mdname" nowrap> <em>outputStream</em> = <code>NULL</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a PMap from a triangle mesh. 
<p>
<dl compact><dt><b>Warning:</b></dt><dd>Legacy function</dd></dl>
A PMap is an optional data structure which makes mesh-mesh collision detection more robust at the cost of higher memory consumption.<p>
This structure can then be assigned to NxTriangleMeshDesc::pmap or passed to NxTriangleMesh::loadPMap().<p>
You may wish to store the PMap on disk (just write the above data block to a file of your choice) after computing it because the creation process can be quite expensive. Then you won't have to create it the next time you need it.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>pmap</em>&nbsp;</td><td>Used to store details of the created PMap. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mesh</em>&nbsp;</td><td>Mesh to create PMap from. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>density</em>&nbsp;</td><td>The density(resolution) of the PMap. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>outputStream</em>&nbsp;</td><td>User supplied interface for reporting errors and displaying messages(see NxUserOutputStream)</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes (Software fallback) </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd>NxPMap NxTriangleMesh.loadPMap() NxConvexShape.loadPMap() <a class="el" href="classNxCookingInterface.html#0d08893310e1a40befbd190ec11f104c">NxReleasePMap</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="6994a293add0e111e909f39f47455ae0"></a><!-- doxytag: member="NxCookingInterface::NxGetCookingParams" ref="6994a293add0e111e909f39f47455ae0" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual const <a class="el" href="structNxCookingParams.html">NxCookingParams</a>&amp; NxCookingInterface::NxGetCookingParams           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets cooking parameters. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Current cooking parameters.</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="structNxCookingParams.html">NxCookingParams</a> <a class="el" href="classNxCookingInterface.html#d85ac53935f2bdcb77ae96efb64cc935">NxSetCookingParams()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="77a9c996d8b7a3bd31fce87d6a2c16d5"></a><!-- doxytag: member="NxCookingInterface::NxInitCooking" ref="77a9c996d8b7a3bd31fce87d6a2c16d5" args="(NxUserAllocator *allocator=NULL, NxUserOutputStream *outputStream=NULL)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool NxCookingInterface::NxInitCooking           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">NxUserAllocator *&nbsp;</td>
          <td class="mdname" nowrap> <em>allocator</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxUserOutputStream *&nbsp;</td>
          <td class="mdname" nowrap> <em>outputStream</em> = <code>NULL</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initializes cooking. 
<p>
This must be called at least once, before any cooking method is called (otherwise cooking fails) and should be matched with a call to <a class="el" href="classNxCookingInterface.html#ab18902ae723323c7f863e793fd18865">NxCloseCooking()</a> before you remove the allocator or output stream objects.<p>
Please note that this also initializes the Foundation SDK. This is not an issue, unless you are linking the AGEIA PhysX SDK using static libraries. When you are using static libraries, the cooking library will share the same Foundation SDK as the rest of the application and this you will have to consider when initializing the cooking library. In statically linked applications, you should specify the same allocator and error stream to <a class="el" href="classNxCookingInterface.html#77a9c996d8b7a3bd31fce87d6a2c16d5">NxInitCooking()</a> and NxCreatePhysicsSDK(). You are not compelled to do so, but should be aware of the possible issues that could arise if you specify different values. A common error would be to specify a user error stream when creating the Physics SDK, but omit it when initializing the cooking, thus resulting in no error stream if the cooking is initialized last.<p>
The previous state of the cooking initialization is stored in a stack each time you call <a class="el" href="classNxCookingInterface.html#77a9c996d8b7a3bd31fce87d6a2c16d5">NxInitCooking()</a> and when you call <a class="el" href="classNxCookingInterface.html#ab18902ae723323c7f863e793fd18865">NxCloseCooking()</a> the previous state is activated again. The "state" that is saved is the allocator and output stream settings. The stack size is currently 32 states, which means that you can not call <a class="el" href="classNxCookingInterface.html#77a9c996d8b7a3bd31fce87d6a2c16d5">NxInitCooking()</a> 33 consecutive times without at least one call to <a class="el" href="classNxCookingInterface.html#ab18902ae723323c7f863e793fd18865">NxCloseCooking()</a> in between.<p>
Note: Cooking parameters (as set by NxSetCookingParams) are reset by this function. You should call NxSetCookingParams after this function, not before.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>allocator</em>&nbsp;</td><td>The memory allocator to use. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>outputStream</em>&nbsp;</td><td>The output stream to use. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>true on success.</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxCookingInterface.html#ab18902ae723323c7f863e793fd18865">NxCloseCooking()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="11eef9338d63bfdb49603f5e31983b2e"></a><!-- doxytag: member="NxCookingInterface::NxPlatformMismatch" ref="11eef9338d63bfdb49603f5e31983b2e" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool NxCookingInterface::NxPlatformMismatch           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Checks endianness is the same between cooking &amp; target platforms. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>True if there is and endian mismatch. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="0d08893310e1a40befbd190ec11f104c"></a><!-- doxytag: member="NxCookingInterface::NxReleasePMap" ref="0d08893310e1a40befbd190ec11f104c" args="(NxPMap &amp;pmap)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool NxCookingInterface::NxReleasePMap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">NxPMap &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pmap</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Releases PMap previously created with NxCreatePMap. 
<p>
<dl compact><dt><b>Warning:</b></dt><dd>Legacy function</dd></dl>
You should not call this on PMap data you have loaded from disc yourself. Don't release a PMap while it is being used by a NxTriangleMesh object.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pmap</em>&nbsp;</td><td>Pmap to release.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes (Software fallback) </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd>NxPMap NxTriangleMesh.loadPMap() NxConvexShape.loadPMap() <a class="el" href="classNxCookingInterface.html#d20ba8ea4d020fed99d909d0af742444">NxCreatePMap</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="908253bf26fb5bbebdbbf23c03674c2e"></a><!-- doxytag: member="NxCookingInterface::NxReportCooking" ref="908253bf26fb5bbebdbbf23c03674c2e" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxCookingInterface::NxReportCooking           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Report state of cooking memory usage. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="694bc32232d37aa1256897cc6abbab83"></a><!-- doxytag: member="NxCookingInterface::NxScaleCookedConvexMesh" ref="694bc32232d37aa1256897cc6abbab83" args="(const NxStream &amp;source, NxReal scale, NxStream &amp;dest)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool NxCookingInterface::NxScaleCookedConvexMesh           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const NxStream &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxReal&nbsp;</td>
          <td class="mdname" nowrap> <em>scale</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxStream &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>dest</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Scales an existing cooked convex mesh and outputs it into another stream. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>source</em>&nbsp;</td><td>The source cooked convex mesh to scale. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>scale</em>&nbsp;</td><td>The uniform scale factor to apply to the convex mesh. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dest</em>&nbsp;</td><td>User stream to output the cooked data. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>true on success</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd><a class="el" href="classNxCookingInterface.html#77a9c996d8b7a3bd31fce87d6a2c16d5">NxInitCooking()</a> must be called before attempting to cook a mesh. <a class="el" href="classNxCookingInterface.html#ab18902ae723323c7f863e793fd18865">NxCloseCooking()</a> should be called when the application has finished using the cooking library.</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxCookingInterface.html#b2c568330ebea4109c827cc812caeb48">NxCookConvexMesh()</a> <a class="el" href="classNxCookingInterface.html#0c6080e44360f807bdbb553c53553e18">NxCookTriangleMesh()</a> <a class="el" href="classNxCookingInterface.html#77a9c996d8b7a3bd31fce87d6a2c16d5">NxInitCooking()</a> <a class="el" href="classNxCookingInterface.html#d85ac53935f2bdcb77ae96efb64cc935">NxSetCookingParams()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="d85ac53935f2bdcb77ae96efb64cc935"></a><!-- doxytag: member="NxCookingInterface::NxSetCookingParams" ref="d85ac53935f2bdcb77ae96efb64cc935" args="(const NxCookingParams &amp;params)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool NxCookingInterface::NxSetCookingParams           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="structNxCookingParams.html">NxCookingParams</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>params</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets cooking parameters. 
<p>
<dl compact><dt><b>Note:</b></dt><dd><a class="el" href="classNxCookingInterface.html#77a9c996d8b7a3bd31fce87d6a2c16d5">NxInitCooking()</a> sets the parameters to their default values.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>params</em>&nbsp;</td><td>Cooking parameters</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>true on success.</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="structNxCookingParams.html">NxCookingParams</a> <a class="el" href="classNxCookingInterface.html#6994a293add0e111e909f39f47455ae0">NxGetCookingParams()</a> </dd></dl>
    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="NxCooking_8h-source.html">NxCooking.h</a></ul>

<hr style="width: 100%; height: 2px;"><a><br>
</a>
Copyright &copy; 2008 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</body>
</html>
