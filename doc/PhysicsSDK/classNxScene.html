<html>
<head>
<title>Physics SDK API Reference: NxScene Class Reference</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">

<LINK HREF="../stylesheet.css" REL="stylesheet" TYPE="text/css">

</head>

<body bgcolor="#FFFFFF">
<img alt="" src="images/PhysXlogo.png" align="middle"> <br>

<center>

<hr>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp;  </center>
<hr>
<!-- Generated by Doxygen 1.4.6-NO -->
<h1>NxScene Class Reference<br>
<small>
[<a class="el" href="group__physics.html">Physics</a>]</small>
</h1><!-- doxytag: class="NxScene" --><code>#include &lt;<a class="el" href="NxScene_8h-source.html">NxScene.h</a>&gt;</code>
<p>
<a href="classNxScene-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
A scene is a collection of bodies, constraints, and effectors which can interact. 
<p>
The scene simulates the behavior of these objects over time. Several scenes may exist at the same time, but each body, constraint, or effector object is specific to a scene -- they may not be shared.<p>
For example, attempting to create a joint in one scene and then using it to attach bodies from a different scene results in undefined behavior.<p>
<h3>Creation</h3>
<p>
Example:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// Create a scene</span>
<a class="code" href="classNxSceneDesc.html">NxSceneDesc</a> sceneDesc;

sceneDesc.<a class="code" href="classNxSceneDesc.html#5a464293323cfe168685b120f52d82ea">gravity</a>               = <a class="code" href="classNxVec3.html">NxVec3</a>(0.0f,-9.8f,0.0f); <span class="comment">//gravity to apply to objects in the scene.</span>

<a class="code" href="classNxScene.html">NxScene</a> *scene=gPhysicsSDK-&gt;createScene(sceneDesc);
</pre></div><p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxSceneDesc.html">NxSceneDesc</a> <a class="el" href="group__physics.html#g2dfe4fcc79d1068dd9340acb2c45da0c">NxPhysicsSDK.createScene()</a> <a class="el" href="group__physics.html#g614b1dd0a06e31594bc546849bc9d741">NxPhysicsSDK.releaseScene()</a> </dd></dl>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#645b3399372791ec9437a8378cbb4228">saveToDesc</a> (<a class="el" href="classNxSceneDesc.html">NxSceneDesc</a> &amp;desc) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Saves the Scene descriptor.  <a href="#645b3399372791ec9437a8378cbb4228"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual NxU32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#860585418b2fd79c7a7d0b7c2cbc159e">getFlags</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the scene flags.  <a href="#860585418b2fd79c7a7d0b7c2cbc159e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__physics.html#g815e4f6dc14a7f753e9a276379f5b768">NxSimulationType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#2763be68cdb1f4c9f0234e18becc2aab">getSimType</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the simulation type.  <a href="#2763be68cdb1f4c9f0234e18becc2aab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#4d1184b969a64b2b2f9d5483767bbe15">getInternal</a> (void)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets a private interface to an internal debug object.  <a href="#4d1184b969a64b2b2f9d5483767bbe15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#3d35ff91cee3f0a6b7c0f4afb63b2766">setGravity</a> (const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;vec)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a constant gravity for the entire scene.  <a href="#3d35ff91cee3f0a6b7c0f4afb63b2766"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#90d1d018192a6fd4ebe6bb7b4ceb6eae">getGravity</a> (<a class="el" href="classNxVec3.html">NxVec3</a> &amp;vec)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the current gravity setting.  <a href="#90d1d018192a6fd4ebe6bb7b4ceb6eae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#dc1375a6e1b406c8165ec1f11366ef3e">flushStream</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flush the scene's command queue for processing.  <a href="#dc1375a6e1b406c8165ec1f11366ef3e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#3f78154dfd007fbf8b6f74884f94657d">setTiming</a> (<a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a> maxTimestep=1.0f/60.0f, NxU32 maxIter=8, NxTimeStepMethod method=NX_TIMESTEP_FIXED)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets simulation timing parameters used in simulate(elapsedTime).  <a href="#3f78154dfd007fbf8b6f74884f94657d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#af4bb8e49b7e8b85c3b842e7cc3c96b0">getTiming</a> (<a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a> &amp;maxTimestep, NxU32 &amp;maxIter, <a class="el" href="group__physics.html#gb0121e5b18e9aab4ef5619d3749e5a6e">NxTimeStepMethod</a> &amp;method, NxU32 *numSubSteps=NULL) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves simulation timing parameters.  <a href="#af4bb8e49b7e8b85c3b842e7cc3c96b0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <a class="el" href="classNxDebugRenderable.html">NxDebugRenderable</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#a403e652cd1e77a3d687183aac63bdc5">getDebugRenderable</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the debug renderable.  <a href="#a403e652cd1e77a3d687183aac63bdc5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxPhysicsSDK.html">NxPhysicsSDK</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#480d328c211ab14decc60beb4d1ab425">getPhysicsSDK</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call this method to retrieve the Physics SDK.  <a href="#480d328c211ab14decc60beb4d1ab425"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#a10e6e8e16467c8ba360bc46646e7769">getStats</a> (<a class="el" href="classNxSceneStats.html">NxSceneStats</a> &amp;stats) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call this method to retrieve statistics about the current scene.  <a href="#a10e6e8e16467c8ba360bc46646e7769"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <a class="el" href="classNxSceneStats2.html">NxSceneStats2</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#b33d8be0787f4fb6d5d927e7f9a2053d">getStats2</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call this method to retrieve extended statistics about the current scene.  <a href="#b33d8be0787f4fb6d5d927e7f9a2053d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#45595724e4b7e4c7a0f6c41a704d11f5">getLimits</a> (<a class="el" href="classNxSceneLimits.html">NxSceneLimits</a> &amp;limits) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call to retrieve the expected object count limits set in the scene descriptor.  <a href="#45595724e4b7e4c7a0f6c41a704d11f5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#6c9f687bded62d2edfacfc858a563a0a">setMaxCPUForLoadBalancing</a> (<a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a> cpuFraction)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Not yet implemented!  <a href="#6c9f687bded62d2edfacfc858a563a0a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#2b8afea9fdd7a6037c241e4968ab33d9">getMaxCPUForLoadBalancing</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call to get the maximum CPU for use when load-balancing.  <a href="#2b8afea9fdd7a6037c241e4968ab33d9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#ecb720c8a69a42282b196c8844e17cbf">isWritable</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is a query to see if the scene is in a state that allows the application to update scene state.  <a href="#ecb720c8a69a42282b196c8844e17cbf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#4016009eb8c4a82959496bdab2cea017">simulate</a> (<a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a> elapsedTime)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Advances the simulation by an elapsedTime time.  <a href="#4016009eb8c4a82959496bdab2cea017"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#5b852665897d56a5f58da38b458718aa">checkResults</a> (<a class="el" href="group__physics.html#g06fc771bf59dfa0cea3428b5b6d36fc4">NxSimulationStatus</a> status, bool block=false)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This checks to see if the part of the simulation run whose results you are interested in has completed.  <a href="#5b852665897d56a5f58da38b458718aa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#120b86a16a1786546d73a5d22f7d1d55">fetchResults</a> (<a class="el" href="group__physics.html#g06fc771bf59dfa0cea3428b5b6d36fc4">NxSimulationStatus</a> status, bool block=false, NxU32 *errorState=0)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#7b321f8781975932f7bbeb169db2d420">flushCaches</a> ()=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <a class="el" href="classNxProfileData.html">NxProfileData</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#29a7d14b3edfc4c45196f4412958078f">readProfileData</a> (bool clearData)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__physics.html#g70ce4c9351d5599a0c9426942d8f3a0d">NxThreadPollResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#02a7bb5a100770f92e70de2685fb0eee">pollForWork</a> (<a class="el" href="group__physics.html#g01bb907296af882b2e2c6694273d7775">NxThreadWait</a> waitType)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Poll for work to execute on the current thread.  <a href="#02a7bb5a100770f92e70de2685fb0eee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#244018b935af9bcd373f3d452965d18e">resetPollForWork</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset parallel simulation.  <a href="#244018b935af9bcd373f3d452965d18e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__physics.html#g70ce4c9351d5599a0c9426942d8f3a0d">NxThreadPollResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#dfda8a6ede9094e911684f4135793a41">pollForBackgroundWork</a> (<a class="el" href="group__physics.html#g01bb907296af882b2e2c6694273d7775">NxThreadWait</a> waitType)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Polls for background work.  <a href="#dfda8a6ede9094e911684f4135793a41"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#941e68977c4fc3d971430b721ca3fc51">shutdownWorkerThreads</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release threads which are blocking to allow the SDK to be destroyed safely.  <a href="#941e68977c4fc3d971430b721ca3fc51"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#f981d709d15a827f5aca98b14e77400e">lockQueries</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Blocks all parallel raycast/overlap queries.  <a href="#f981d709d15a827f5aca98b14e77400e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#b42c1c7b5cdd7fd3c6d506607e08705c">unlockQueries</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock parallel raycast/overlap queries.  <a href="#b42c1c7b5cdd7fd3c6d506607e08705c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxSceneQuery.html">NxSceneQuery</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#7191a18eb6d75735267a4c33a1e2299a">createSceneQuery</a> (const <a class="el" href="classNxSceneQueryDesc.html">NxSceneQueryDesc</a> &amp;desc)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a batched query object.  <a href="#7191a18eb6d75735267a4c33a1e2299a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#d60ff389056371621715a19b29e10cf0">releaseSceneQuery</a> (<a class="el" href="classNxSceneQuery.html">NxSceneQuery</a> &amp;query)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release a scene query object.  <a href="#d60ff389056371621715a19b29e10cf0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#e6195bf85df84d67e3918bb92e8bf25c">setDynamicTreeRebuildRateHint</a> (NxU32 dynamicTreeRebuildRateHint)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the rebuild rate of the dynamic tree pruning structure.  <a href="#e6195bf85df84d67e3918bb92e8bf25c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual NxU32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#898c074684ead2e0efb5845a123ef2aa">getDynamicTreeRebuildRateHint</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the rebuild rate of the dynamic tree pruning structure.  <a href="#898c074684ead2e0efb5845a123ef2aa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#7e9e9d9826bc43f2d0ac6a1d8181b92d">setSolverBatchSize</a> (NxU32 solverBatchSize)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the number of actors required to spawn a separate rigid body solver thread.  <a href="#7e9e9d9826bc43f2d0ac6a1d8181b92d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual NxU32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#d436aa74d8aa4d30951a823a2adb5194">getSolverBatchSize</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the number of actors required to spawn a separate rigid body solver thread.  <a href="#d436aa74d8aa4d30951a823a2adb5194"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Create/Release Objects</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxActor.html">NxActor</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#67d5aeda6c35776fd7fbf3ab43cdaaf2">createActor</a> (const <a class="el" href="classNxActorDescBase.html">NxActorDescBase</a> &amp;desc)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an actor in this scene.  <a href="#67d5aeda6c35776fd7fbf3ab43cdaaf2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#b20ab7bf376ae2238882964c2c10424e">releaseActor</a> (<a class="el" href="classNxActor.html">NxActor</a> &amp;actor)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes the specified actor.  <a href="#b20ab7bf376ae2238882964c2c10424e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxJoint.html">NxJoint</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#b3cba152261abe42a2f90d2e42690170">createJoint</a> (const <a class="el" href="classNxJointDesc.html">NxJointDesc</a> &amp;jointDesc)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a joint.  <a href="#b3cba152261abe42a2f90d2e42690170"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#00578d1d1016a602df2b8e1f161d3ebb">releaseJoint</a> (<a class="el" href="classNxJoint.html">NxJoint</a> &amp;joint)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes the specified joint.  <a href="#00578d1d1016a602df2b8e1f161d3ebb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxSpringAndDamperEffector.html">NxSpringAndDamperEffector</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#daee1f1b73068cf2c32e89268f4d73ed">createSpringAndDamperEffector</a> (const <a class="el" href="classNxSpringAndDamperEffectorDesc.html">NxSpringAndDamperEffectorDesc</a> &amp;springDesc)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deprecated. Use <a class="el" href="classNxScene.html#9d67d1623df8fad0503663394b5aa0d0">createEffector()</a> instead.  <a href="#daee1f1b73068cf2c32e89268f4d73ed"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxEffector.html">NxEffector</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#9d67d1623df8fad0503663394b5aa0d0">createEffector</a> (const <a class="el" href="classNxEffectorDesc.html">NxEffectorDesc</a> &amp;desc)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an effector.  <a href="#9d67d1623df8fad0503663394b5aa0d0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#08fae090bb9ef999c3e265cf886a64d7">releaseEffector</a> (<a class="el" href="classNxEffector.html">NxEffector</a> &amp;effector)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes the effector passed.  <a href="#08fae090bb9ef999c3e265cf886a64d7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxForceField.html">NxForceField</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#4440eb8fa1a88501cdeb46e229c3ad6a">createForceField</a> (const <a class="el" href="classNxForceFieldDesc.html">NxForceFieldDesc</a> &amp;forceFieldDesc)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a force field.  <a href="#4440eb8fa1a88501cdeb46e229c3ad6a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#0f5c3108de6e31eaba0e413f3c877087">releaseForceField</a> (<a class="el" href="classNxForceField.html">NxForceField</a> &amp;forceField)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes the force field passed.  <a href="#0f5c3108de6e31eaba0e413f3c877087"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual NxU32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#7b569fb4fbad438542702d0783ae7bf6">getNbForceFields</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the number of force fields in the scene.  <a href="#7b569fb4fbad438542702d0783ae7bf6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxForceField.html">NxForceField</a> **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#1f0bb5e599e817d98a1e44ce592d487a">getForceFields</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the force fields in the scene.  <a href="#1f0bb5e599e817d98a1e44ce592d487a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxForceFieldLinearKernel.html">NxForceFieldLinearKernel</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#4b84b8290614e41c7aec528a1d60b737">createForceFieldLinearKernel</a> (const <a class="el" href="classNxForceFieldLinearKernelDesc.html">NxForceFieldLinearKernelDesc</a> &amp;kernelDesc)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">creates a forcefield kernel which uses the same linear function as pre 2.8 force fields  <a href="#4b84b8290614e41c7aec528a1d60b737"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#919b6675e07a2431c20a18673b78fcbf">releaseForceFieldLinearKernel</a> (<a class="el" href="classNxForceFieldLinearKernel.html">NxForceFieldLinearKernel</a> &amp;kernel)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">releases a linear force field kernel  <a href="#919b6675e07a2431c20a18673b78fcbf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual NxU32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#5b9feb79e058b88df2207fe453905f8e">getNbForceFieldLinearKernels</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of linear kernels in the scene.  <a href="#5b9feb79e058b88df2207fe453905f8e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#35a7c971541b877f47807f2781c99941">resetForceFieldLinearKernelsIterator</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Restarts the linear kernels iterator so that the next call to <a class="el" href="classNxScene.html#0004c1ba77f1b613139969637480dc1e">getNextForceFieldLinearKernel()</a>.  <a href="#35a7c971541b877f47807f2781c99941"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxForceFieldLinearKernel.html">NxForceFieldLinearKernel</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#0004c1ba77f1b613139969637480dc1e">getNextForceFieldLinearKernel</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the next linear kernel when iterating.  <a href="#0004c1ba77f1b613139969637480dc1e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxForceFieldShapeGroup.html">NxForceFieldShapeGroup</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#3bdc424db77735ebc3a6218603720cfd">createForceFieldShapeGroup</a> (const <a class="el" href="classNxForceFieldShapeGroupDesc.html">NxForceFieldShapeGroupDesc</a> &amp;desc)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new force field shape group.  <a href="#3bdc424db77735ebc3a6218603720cfd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#e9836babd691d45473c53abb2c1c50a0">releaseForceFieldShapeGroup</a> (<a class="el" href="classNxForceFieldShapeGroup.html">NxForceFieldShapeGroup</a> &amp;group)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Releases a force field shape group.  <a href="#e9836babd691d45473c53abb2c1c50a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual NxU32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#8fe4b89f28d8d3290ff3a12f1fdb6eff">getNbForceFieldShapeGroups</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of shape groups in the scene.  <a href="#8fe4b89f28d8d3290ff3a12f1fdb6eff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#6d5d84cadc9bcc4a92f6a76b01163659">resetForceFieldShapeGroupsIterator</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Restarts the shape groups iterator so that the next call to <a class="el" href="classNxScene.html#01e1183c4acbcd207bf3f4c4ecc879ed">getNextForceFieldShapeGroup()</a> returns the first shape group in the force scene.  <a href="#6d5d84cadc9bcc4a92f6a76b01163659"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxForceFieldShapeGroup.html">NxForceFieldShapeGroup</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#01e1183c4acbcd207bf3f4c4ecc879ed">getNextForceFieldShapeGroup</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the next shape group when iterating.  <a href="#01e1183c4acbcd207bf3f4c4ecc879ed"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__physics.html#g640c39d5ac1c8eafdb90f3f8c585ee2b">NxForceFieldVariety</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#48b98de6cfd7f35ebd1b8b489727dbb1">createForceFieldVariety</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new variety index for force fields to access the scaling table, creates a new row in the scaling table.  <a href="#48b98de6cfd7f35ebd1b8b489727dbb1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__physics.html#g640c39d5ac1c8eafdb90f3f8c585ee2b">NxForceFieldVariety</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#05797b48870311ea4dc6ccab219b8e53">getHighestForceFieldVariety</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the highest allocated force field variety.  <a href="#05797b48870311ea4dc6ccab219b8e53"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#0aa4a83affd4f618b83b84b5ffe1db69">releaseForceFieldVariety</a> (<a class="el" href="group__physics.html#g640c39d5ac1c8eafdb90f3f8c585ee2b">NxForceFieldVariety</a> var)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Releases a forcefield variety index and the related row in the scaling table.  <a href="#0aa4a83affd4f618b83b84b5ffe1db69"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__physics.html#g6a78f0087de2bc790aff345a36f7552f">NxForceFieldMaterial</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#2eac61c6192f6f9b06aa1bcef5b6652a">createForceFieldMaterial</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new index for objects(actor, fluid, cloth, softbody) to access the scaling table, creates a new column in the scaling table.  <a href="#2eac61c6192f6f9b06aa1bcef5b6652a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__physics.html#g6a78f0087de2bc790aff345a36f7552f">NxForceFieldMaterial</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#5661adb68661fa166d6b94ff77f457aa">getHighestForceFieldMaterial</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the highest allocated force field material.  <a href="#5661adb68661fa166d6b94ff77f457aa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#cf4b8692fa10d5ae72b2127df323ecf8">releaseForceFieldMaterial</a> (<a class="el" href="group__physics.html#g6a78f0087de2bc790aff345a36f7552f">NxForceFieldMaterial</a> mat)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Releases a forcefield material index and the related column in the scaling table.  <a href="#cf4b8692fa10d5ae72b2127df323ecf8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#539455577b07f393398ed5e90205614e">getForceFieldScale</a> (<a class="el" href="group__physics.html#g640c39d5ac1c8eafdb90f3f8c585ee2b">NxForceFieldVariety</a> var, <a class="el" href="group__physics.html#g6a78f0087de2bc790aff345a36f7552f">NxForceFieldMaterial</a> mat)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the scaling value for a given variety/material pair.  <a href="#539455577b07f393398ed5e90205614e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#3e2a82f1517151b482ec5878230cc934">setForceFieldScale</a> (<a class="el" href="group__physics.html#g640c39d5ac1c8eafdb90f3f8c585ee2b">NxForceFieldVariety</a> var, <a class="el" href="group__physics.html#g6a78f0087de2bc790aff345a36f7552f">NxForceFieldMaterial</a> mat, <a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a> val)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the scaling value for a given variety/material pair.  <a href="#3e2a82f1517151b482ec5878230cc934"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxMaterial.html">NxMaterial</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#a16ceef08f12195b0e5e2dd1efd98523">createMaterial</a> (const <a class="el" href="classNxMaterialDesc.html">NxMaterialDesc</a> &amp;matDesc)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new <a class="el" href="classNxMaterial.html">NxMaterial</a>.  <a href="#a16ceef08f12195b0e5e2dd1efd98523"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#d50c514ff47e8abedcbcd19eff30be4c">releaseMaterial</a> (<a class="el" href="classNxMaterial.html">NxMaterial</a> &amp;material)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes the specified material.  <a href="#d50c514ff47e8abedcbcd19eff30be4c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxCompartment.html">NxCompartment</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#49ae6e121d3ad73a249421b3798e6de7">createCompartment</a> (const <a class="el" href="classNxCompartmentDesc.html">NxCompartmentDesc</a> &amp;compDesc)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a scene compartment.  <a href="#49ae6e121d3ad73a249421b3798e6de7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual NxU32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#57e9f78a29a1f4f19da279ba0821211f">getNbCompartments</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of compartments created in the scene.  <a href="#57e9f78a29a1f4f19da279ba0821211f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual NxU32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#c3d087ba9fe3f55e900b625dbc40b9a3">getCompartmentArray</a> (<a class="el" href="classNxCompartment.html">NxCompartment</a> **userBuffer, NxU32 bufferSize, NxU32 &amp;usersIterator) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes the scene's array of <a class="el" href="classNxCompartment.html">NxCompartment</a> pointers to a user buffer.  <a href="#c3d087ba9fe3f55e900b625dbc40b9a3"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Collision Filtering and Grouping</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#124e55cbcbfa0a5bcf6a8f19f36fd5fe">setActorPairFlags</a> (<a class="el" href="classNxActor.html">NxActor</a> &amp;actorA, <a class="el" href="classNxActor.html">NxActor</a> &amp;actorB, NxU32 nxContactPairFlag)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the pair flags for the given pair of actors.  <a href="#124e55cbcbfa0a5bcf6a8f19f36fd5fe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual NxU32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#a6c8692f4c06a00658c2831e80608b7b">getActorPairFlags</a> (<a class="el" href="classNxActor.html">NxActor</a> &amp;actorA, <a class="el" href="classNxActor.html">NxActor</a> &amp;actorB) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the pair flags for the given pair of actors.  <a href="#a6c8692f4c06a00658c2831e80608b7b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#d2795f18b35cd23e749535459b3e6a22">setShapePairFlags</a> (<a class="el" href="classNxShape.html">NxShape</a> &amp;shapeA, <a class="el" href="classNxShape.html">NxShape</a> &amp;shapeB, NxU32 nxContactPairFlag)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Similar to <a class="el" href="classNxScene.html#124e55cbcbfa0a5bcf6a8f19f36fd5fe">setActorPairFlags()</a>, but for a pair of shapes.  <a href="#d2795f18b35cd23e749535459b3e6a22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual NxU32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#4c30521d2686d4054c432279aba65ed6">getShapePairFlags</a> (<a class="el" href="classNxShape.html">NxShape</a> &amp;shapeA, <a class="el" href="classNxShape.html">NxShape</a> &amp;shapeB) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Similar to <a class="el" href="classNxScene.html#a6c8692f4c06a00658c2831e80608b7b">getActorPairFlags()</a>, but for a pair of shapes.  <a href="#4c30521d2686d4054c432279aba65ed6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual NxU32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#14e4850a41771cc8edd18fd8eb55d485">getNbPairs</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of pairs for which pairFlags are defined. Note that this includes compartments.  <a href="#14e4850a41771cc8edd18fd8eb55d485"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual NxU32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#2bfb57ce590cc037c3e7c7df3f00c311">getPairFlagArray</a> (<a class="el" href="classNxPairFlag.html">NxPairFlag</a> *userArray, NxU32 numPairs) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the pair flag data.  <a href="#2bfb57ce590cc037c3e7c7df3f00c311"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#5d3b6f687c209e0c7d88d3c7b0ec0d81">setGroupCollisionFlag</a> (<a class="el" href="group__physics.html#gb144febecb4fc60da5d48839c14c2501">NxCollisionGroup</a> group1, <a class="el" href="group__physics.html#gb144febecb4fc60da5d48839c14c2501">NxCollisionGroup</a> group2, bool enable)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specifies if collision should be performed by a pair of shape groups.  <a href="#5d3b6f687c209e0c7d88d3c7b0ec0d81"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#c4d2b48b89c0398869399b5db6e4ec0b">getGroupCollisionFlag</a> (<a class="el" href="group__physics.html#gb144febecb4fc60da5d48839c14c2501">NxCollisionGroup</a> group1, <a class="el" href="group__physics.html#gb144febecb4fc60da5d48839c14c2501">NxCollisionGroup</a> group2) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines if collision detection is performed between a pair of groups.  <a href="#c4d2b48b89c0398869399b5db6e4ec0b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#b3a23eb788d2c6e290e3d14d8d5a2a79">setDominanceGroupPair</a> (<a class="el" href="group__physics.html#gd17c09bc9705b7db96e260dffffdb381">NxDominanceGroup</a> group1, <a class="el" href="group__physics.html#gd17c09bc9705b7db96e260dffffdb381">NxDominanceGroup</a> group2, <a class="el" href="structNxConstraintDominance.html">NxConstraintDominance</a> &amp;dominance)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specifies the dominance behavior of constraints between two actors with two certain dominance groups.  <a href="#b3a23eb788d2c6e290e3d14d8d5a2a79"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structNxConstraintDominance.html">NxConstraintDominance</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#44709422d5269f4966451964958c0bd6">getDominanceGroupPair</a> (<a class="el" href="group__physics.html#gd17c09bc9705b7db96e260dffffdb381">NxDominanceGroup</a> group1, <a class="el" href="group__physics.html#gd17c09bc9705b7db96e260dffffdb381">NxDominanceGroup</a> group2) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Samples the dominance matrix.  <a href="#44709422d5269f4966451964958c0bd6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#c918ed0ade26efb4df810e495924e05c">setActorGroupPairFlags</a> (<a class="el" href="group__physics.html#gd7d66f3c79185448a29cbc084ddcfefb">NxActorGroup</a> group1, <a class="el" href="group__physics.html#gd7d66f3c79185448a29cbc084ddcfefb">NxActorGroup</a> group2, NxU32 flags)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">With this method one can set contact reporting flags between actors belonging to a pair of groups.  <a href="#c918ed0ade26efb4df810e495924e05c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual NxU32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#871ae96ecabb8808e707a1616a3417b0">getActorGroupPairFlags</a> (<a class="el" href="group__physics.html#gd7d66f3c79185448a29cbc084ddcfefb">NxActorGroup</a> group1, <a class="el" href="group__physics.html#gd7d66f3c79185448a29cbc084ddcfefb">NxActorGroup</a> group2) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This reads the value set with <a class="el" href="classNxScene.html#c918ed0ade26efb4df810e495924e05c">setActorGroupPairFlags</a>.  <a href="#871ae96ecabb8808e707a1616a3417b0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual NxU32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#6109dca606a802788d247befa02e75c6">getNbActorGroupPairs</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the number of actor group flags (as set by setActorGroupPairFlags).  <a href="#6109dca606a802788d247befa02e75c6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual NxU32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#3f23c6571599aa7e789e00ae25ddfb7d">getActorGroupPairArray</a> (<a class="el" href="structNxActorGroupPair.html">NxActorGroupPair</a> *userBuffer, NxU32 bufferSize, NxU32 &amp;userIterator) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes the scene's array of actor group flags (as set by setActorGroupPairFlags) to a user buffer.  <a href="#3f23c6571599aa7e789e00ae25ddfb7d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#ee66b7fbef5420ad6b16df1e6180def6">setFilterOps</a> (<a class="el" href="group__physics.html#g0bb727ab008ff2a2cfcf2533489b58f2">NxFilterOp</a> op0, <a class="el" href="group__physics.html#g0bb727ab008ff2a2cfcf2533489b58f2">NxFilterOp</a> op1, <a class="el" href="group__physics.html#g0bb727ab008ff2a2cfcf2533489b58f2">NxFilterOp</a> op2)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Setups filtering operations. See comments for <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a>.  <a href="#ee66b7fbef5420ad6b16df1e6180def6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#aeeaf92ff2dfef1b536e615220b2e240">setFilterBool</a> (bool flag)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Setups filtering's boolean value. See comments for <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a>.  <a href="#aeeaf92ff2dfef1b536e615220b2e240"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#92135aeafe85554cd926cfe06bae8c54">setFilterConstant0</a> (const <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a> &amp;mask)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Setups filtering's K0 value. See comments for <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a>.  <a href="#92135aeafe85554cd926cfe06bae8c54"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#504622ffdbd9815dae2e06fcea079cd5">setFilterConstant1</a> (const <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a> &amp;mask)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Setups filtering's K1 value. See comments for <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a>.  <a href="#504622ffdbd9815dae2e06fcea079cd5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#2a93a86afa41862dd9e796ab63731c49">getFilterOps</a> (<a class="el" href="group__physics.html#g0bb727ab008ff2a2cfcf2533489b58f2">NxFilterOp</a> &amp;op0, <a class="el" href="group__physics.html#g0bb727ab008ff2a2cfcf2533489b58f2">NxFilterOp</a> &amp;op1, <a class="el" href="group__physics.html#g0bb727ab008ff2a2cfcf2533489b58f2">NxFilterOp</a> &amp;op2) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves filtering operation. See comments for <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a>.  <a href="#2a93a86afa41862dd9e796ab63731c49"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#b1d3932cf4bbfcd3e80b8548299ff233">getFilterBool</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves filtering's boolean value. See comments for <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a>.  <a href="#b1d3932cf4bbfcd3e80b8548299ff233"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#13b6807a00e9b4aeea5c6684d382e641">getFilterConstant0</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets filtering constant K0. See comments for <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a>.  <a href="#13b6807a00e9b4aeea5c6684d382e641"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#813480493abe1a4f03803dfad7e222ae">getFilterConstant1</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets filtering constant K1. See comments for <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a>.  <a href="#813480493abe1a4f03803dfad7e222ae"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Enumeration</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual NxU32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#ff41faf917ed8be6ccc9f493e3e10102">getNbActors</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the number of actors in the scene.  <a href="#ff41faf917ed8be6ccc9f493e3e10102"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxActor.html">NxActor</a> **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#195d2f4d72ef884c90d7bc9fc7b2e858">getActors</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve an array of all the actors in the scene.  <a href="#195d2f4d72ef884c90d7bc9fc7b2e858"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structNxActiveTransform.html">NxActiveTransform</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#df889afe53779dfe07818c14990b24f0">getActiveTransforms</a> (NxU32 &amp;nbTransformsOut)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queries the <a class="el" href="classNxScene.html">NxScene</a> for a list of the NxActors whose transforms have been updated during the previous simulation step.  <a href="#df889afe53779dfe07818c14990b24f0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual NxU32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#92bef655316556dfd2856dd998f54955">getNbStaticShapes</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of static shapes in the scene. Note that this includes compartments and mirrored shapes in compartments.  <a href="#92bef655316556dfd2856dd998f54955"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual NxU32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#20c0d3d5d2146f42c02b0e9dc0ccccba">getNbDynamicShapes</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of dynamic shapes in the scene. Note that this includes compartments and mirrored shapes in compartments.  <a href="#20c0d3d5d2146f42c02b0e9dc0ccccba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual NxU32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#fcaca9892b3d03f204751b610c0ea21b">getTotalNbShapes</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the total number of shapes in the scene, including compounds' sub-shapes. Note that this also includes compartments and mirrored shapes in compartments.  <a href="#fcaca9892b3d03f204751b610c0ea21b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual NxU32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#6832193dab2b4f8c901a2230cb16eddf">getNbJoints</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of joints in the scene (excluding "dead" joints). Note that this includes compartments.  <a href="#6832193dab2b4f8c901a2230cb16eddf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#9f3d1e4408bf99f193cfee52a113cf83">resetJointIterator</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Restarts the joint iterator so that the next call to getNextJoint() returns the first joint in the scene.  <a href="#9f3d1e4408bf99f193cfee52a113cf83"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxJoint.html">NxJoint</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#76c118714d46f0800e23afd5842307c4">getNextJoint</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the next joint when iterating.  <a href="#76c118714d46f0800e23afd5842307c4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual NxU32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#a55199c404c776475f71b0882465c754">getNbEffectors</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of effectors in the scene.  <a href="#a55199c404c776475f71b0882465c754"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#4dc6b5aa41bedad81992e96cebddb5d6">resetEffectorIterator</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Restarts the effector iterator so that the next call to getNextEffector() returns the first effector in the scene.  <a href="#4dc6b5aa41bedad81992e96cebddb5d6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxEffector.html">NxEffector</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#4aaff4a9db595e5b7dc25841819f5489">getNextEffector</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the next effector when iterating through the effectors in the scene.  <a href="#4aaff4a9db595e5b7dc25841819f5489"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual NxU32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#50d187eb84fed8911460eb0a70219d8d">getBoundForIslandSize</a> (<a class="el" href="classNxActor.html">NxActor</a> &amp;actor)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an upper bound for the number of actors in the collision island of a certain actor.  <a href="#50d187eb84fed8911460eb0a70219d8d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual NxU32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#bec8ca470bcb8656b1b1b3a52ea9d76c">getIslandArrayFromActor</a> (<a class="el" href="classNxActor.html">NxActor</a> &amp;actor, <a class="el" href="classNxActor.html">NxActor</a> **userBuffer, NxU32 bufferSize, NxU32 &amp;userIterator)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes pointers to the actors making up the collision island of a certain actor to a user buffer.  <a href="#bec8ca470bcb8656b1b1b3a52ea9d76c"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Materials</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual NxU32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#ec4836f6a7218e7a8a7354e0233398d9">getNbMaterials</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of materials in the scene.  <a href="#ec4836f6a7218e7a8a7354e0233398d9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual NxU32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#5a2a95c92eec6ae1cbe599f419dafbb5">getMaterialArray</a> (<a class="el" href="classNxMaterial.html">NxMaterial</a> **userBuffer, NxU32 bufferSize, NxU32 &amp;usersIterator)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes the scene's array of material pointers to a user buffer.  <a href="#5a2a95c92eec6ae1cbe599f419dafbb5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__physics.html#g7c86954f381ead77b9fbf58daa9eda52">NxMaterialIndex</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#bde32b80a6a4adc3dd4b5606a938ff07">getHighestMaterialIndex</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns current highest valid material index.  <a href="#bde32b80a6a4adc3dd4b5606a938ff07"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxMaterial.html">NxMaterial</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#9357a48b1d90d7a9634ab5743f3650be">getMaterialFromIndex</a> (<a class="el" href="group__physics.html#g7c86954f381ead77b9fbf58daa9eda52">NxMaterialIndex</a> matIndex)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the material with the given material index.  <a href="#9357a48b1d90d7a9634ab5743f3650be"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Callbacks</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#c0b9531f514d0219651a507ae197a0a2">setUserNotify</a> (<a class="el" href="classNxUserNotify.html">NxUserNotify</a> *callback)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a user notify object which receives special simulation events when they occur.  <a href="#c0b9531f514d0219651a507ae197a0a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxUserNotify.html">NxUserNotify</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#8a7f769f5cf233f440fb12dcc5000020">getUserNotify</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the userNotify pointer set with <a class="el" href="classNxScene.html#c0b9531f514d0219651a507ae197a0a2">setUserNotify()</a>.  <a href="#8a7f769f5cf233f440fb12dcc5000020"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#8262e2bfac8fa7c4e3ca5a2ab949fb86">setFluidUserNotify</a> (<a class="el" href="classNxFluidUserNotify.html">NxFluidUserNotify</a> *callback)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a user notify object which receives special simulation events when they occur.  <a href="#8262e2bfac8fa7c4e3ca5a2ab949fb86"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxFluidUserNotify.html">NxFluidUserNotify</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#4d92af89425c2955b62abc5a26f5a0e2">getFluidUserNotify</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the <a class="el" href="classNxFluidUserNotify.html">NxFluidUserNotify</a> pointer set with setfluidUserNotify().  <a href="#4d92af89425c2955b62abc5a26f5a0e2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#892fa4cbd5abae3506c4127e12c96a1b">setClothUserNotify</a> (<a class="el" href="classNxClothUserNotify.html">NxClothUserNotify</a> *callback)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a user notify object which receives special simulation events when they occur.  <a href="#892fa4cbd5abae3506c4127e12c96a1b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxClothUserNotify.html">NxClothUserNotify</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#57c06bc02979452cd547a7b012869823">getClothUserNotify</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the <a class="el" href="classNxClothUserNotify.html">NxClothUserNotify</a> pointer set with <a class="el" href="classNxScene.html#892fa4cbd5abae3506c4127e12c96a1b">setClothUserNotify()</a>.  <a href="#57c06bc02979452cd547a7b012869823"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#f0d657dc1b0a822ac5943cb548c6a60e">setSoftBodyUserNotify</a> (<a class="el" href="classNxSoftBodyUserNotify.html">NxSoftBodyUserNotify</a> *callback)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a user notify object which receives special simulation events when they occur.  <a href="#f0d657dc1b0a822ac5943cb548c6a60e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxSoftBodyUserNotify.html">NxSoftBodyUserNotify</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#8492f05f61d16f19b4e3f63209ad48e9">getSoftBodyUserNotify</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the <a class="el" href="classNxSoftBodyUserNotify.html">NxSoftBodyUserNotify</a> pointer set with <a class="el" href="classNxScene.html#f0d657dc1b0a822ac5943cb548c6a60e">setSoftBodyUserNotify()</a>.  <a href="#8492f05f61d16f19b4e3f63209ad48e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#6731ff076b2594d44d14b734ed8c660e">setUserContactModify</a> (<a class="el" href="classNxUserContactModify.html">NxUserContactModify</a> *callback)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a user callback object, which receives callbacks on all contacts generated for specified actors.  <a href="#6731ff076b2594d44d14b734ed8c660e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxUserContactModify.html">NxUserContactModify</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#3a1ad601f20dec9e733ac58c5871e208">getUserContactModify</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the <a class="el" href="classNxUserContactModify.html">NxUserContactModify</a> pointer set with <a class="el" href="classNxScene.html#6731ff076b2594d44d14b734ed8c660e">setUserContactModify()</a>.  <a href="#3a1ad601f20dec9e733ac58c5871e208"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#d0e23eeeef568ff2fd6b5b538c2ce3c7">setUserTriggerReport</a> (<a class="el" href="classNxUserTriggerReport.html">NxUserTriggerReport</a> *callback)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a trigger report object which receives collision trigger events.  <a href="#d0e23eeeef568ff2fd6b5b538c2ce3c7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxUserTriggerReport.html">NxUserTriggerReport</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#f343081b5d86e7791d7dfe480b975ed8">getUserTriggerReport</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the callback pointer set with <a class="el" href="classNxScene.html#d0e23eeeef568ff2fd6b5b538c2ce3c7">setUserTriggerReport()</a>.  <a href="#f343081b5d86e7791d7dfe480b975ed8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#9d9b93fb3217760b45280735a9e5a1a3">setUserContactReport</a> (<a class="el" href="classNxUserContactReport.html">NxUserContactReport</a> *callback)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a contact report object which receives collision contact events.  <a href="#9d9b93fb3217760b45280735a9e5a1a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxUserContactReport.html">NxUserContactReport</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#4b67e9defeb1d26f63ff02f243d7f340">getUserContactReport</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the callback pointer set with <a class="el" href="classNxScene.html#9d9b93fb3217760b45280735a9e5a1a3">setUserContactReport()</a>.  <a href="#4b67e9defeb1d26f63ff02f243d7f340"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#5b73eede587ac90cbebf8561de8421a2">setUserActorPairFiltering</a> (<a class="el" href="classNxUserActorPairFiltering.html">NxUserActorPairFiltering</a> *callback)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the custom actor pair filtering to use for this scene.  <a href="#5b73eede587ac90cbebf8561de8421a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxUserActorPairFiltering.html">NxUserActorPairFiltering</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#6cf0420a2cbf0873bf5b65b5f1ad1d92">getUserActorPairFiltering</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the custom actor pair filtering in use for this scene.  <a href="#6cf0420a2cbf0873bf5b65b5f1ad1d92"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Raycasting</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#564174af1cc7ce3c313e2de4bbdc45a7">raycastAnyBounds</a> (const <a class="el" href="classNxRay.html">NxRay</a> &amp;worldRay, <a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a> shapesType, NxU32 groups=0xffffffff, NxReal maxDist=NX_MAX_F32, const NxGroupsMask *groupsMask=NULL) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if any axis aligned bounding box enclosing a shape of type shapeType is intersected by the ray.  <a href="#564174af1cc7ce3c313e2de4bbdc45a7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#74f71e39b9e48ee55aec158e02c65dd0">raycastAnyShape</a> (const <a class="el" href="classNxRay.html">NxRay</a> &amp;worldRay, <a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a> shapesType, NxU32 groups=0xffffffff, NxReal maxDist=NX_MAX_F32, const NxGroupsMask *groupsMask=NULL, NxShape **cache=NULL) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if any shape of type ShapeType is intersected by the ray.  <a href="#74f71e39b9e48ee55aec158e02c65dd0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual NxU32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#3134810c29120974a7a316f8ea07e622">raycastAllBounds</a> (const <a class="el" href="classNxRay.html">NxRay</a> &amp;worldRay, <a class="el" href="classNxUserRaycastReport.html">NxUserRaycastReport</a> &amp;report, <a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a> shapesType, NxU32 groups=0xffffffff, NxReal maxDist=NX_MAX_F32, NxU32 hintFlags=0xffffffff, const NxGroupsMask *groupsMask=NULL) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls the report's hitCallback() method for all the axis aligned bounding boxes enclosing shapes of type ShapeType intersected by the ray.  <a href="#3134810c29120974a7a316f8ea07e622"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual NxU32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#21fdc86f5fcfe33d7b4f6c802c7c3f94">raycastAllShapes</a> (const <a class="el" href="classNxRay.html">NxRay</a> &amp;worldRay, <a class="el" href="classNxUserRaycastReport.html">NxUserRaycastReport</a> &amp;report, <a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a> shapesType, NxU32 groups=0xffffffff, NxReal maxDist=NX_MAX_F32, NxU32 hintFlags=0xffffffff, const NxGroupsMask *groupsMask=NULL) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls the report's hitCallback() method for all the shapes of type ShapeType intersected by the ray.  <a href="#21fdc86f5fcfe33d7b4f6c802c7c3f94"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxShape.html">NxShape</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#3a51467c411f214fd7197562ecf25162">raycastClosestBounds</a> (const <a class="el" href="classNxRay.html">NxRay</a> &amp;worldRay, <a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a> shapeType, <a class="el" href="structNxRaycastHit.html">NxRaycastHit</a> &amp;hit, NxU32 groups=0xffffffff, NxReal maxDist=NX_MAX_F32, NxU32 hintFlags=0xffffffff, const NxGroupsMask *groupsMask=NULL) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the first axis aligned bounding box enclosing a shape of type shapeType that is hit along the ray.  <a href="#3a51467c411f214fd7197562ecf25162"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxShape.html">NxShape</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#8cfd017296ab965088561ec92d8fe6ea">raycastClosestShape</a> (const <a class="el" href="classNxRay.html">NxRay</a> &amp;worldRay, <a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a> shapeType, <a class="el" href="structNxRaycastHit.html">NxRaycastHit</a> &amp;hit, NxU32 groups=0xffffffff, NxReal maxDist=NX_MAX_F32, NxU32 hintFlags=0xffffffff, const NxGroupsMask *groupsMask=NULL, NxShape **cache=NULL) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the first shape of type shapeType that is hit along the ray.  <a href="#8cfd017296ab965088561ec92d8fe6ea"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Overlap Testing</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual NxU32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#982c1bbc89e5fa15f45d9b74570d0488">overlapSphereShapes</a> (const <a class="el" href="classNxSphere.html">NxSphere</a> &amp;worldSphere, <a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a> shapeType, NxU32 nbShapes, <a class="el" href="classNxShape.html">NxShape</a> **shapes, <a class="el" href="classNxUserEntityReport.html">NxUserEntityReport</a>&lt; <a class="el" href="classNxShape.html">NxShape</a> * &gt; *callback, NxU32 activeGroups=0xffffffff, const NxGroupsMask *groupsMask=NULL, bool accurateCollision=false)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the set of shapes overlapped by the world-space sphere.  <a href="#982c1bbc89e5fa15f45d9b74570d0488"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual NxU32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#c67f8f88acd1110063fe60e73ba673f6">overlapAABBShapes</a> (const <a class="el" href="classNxBounds3.html">NxBounds3</a> &amp;worldBounds, <a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a> shapeType, NxU32 nbShapes, <a class="el" href="classNxShape.html">NxShape</a> **shapes, <a class="el" href="classNxUserEntityReport.html">NxUserEntityReport</a>&lt; <a class="el" href="classNxShape.html">NxShape</a> * &gt; *callback, NxU32 activeGroups=0xffffffff, const NxGroupsMask *groupsMask=NULL, bool accurateCollision=false)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the set of shapes overlapped by the world-space AABB.  <a href="#c67f8f88acd1110063fe60e73ba673f6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual NxU32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#8d27be6eba87cfc6ae34905488e7e893">overlapOBBShapes</a> (const <a class="el" href="classNxBox.html">NxBox</a> &amp;worldBox, <a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a> shapeType, NxU32 nbShapes, <a class="el" href="classNxShape.html">NxShape</a> **shapes, <a class="el" href="classNxUserEntityReport.html">NxUserEntityReport</a>&lt; <a class="el" href="classNxShape.html">NxShape</a> * &gt; *callback, NxU32 activeGroups=0xffffffff, const NxGroupsMask *groupsMask=NULL, bool accurateCollision=false)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the set of shapes overlapped by the world-space OBB.  <a href="#8d27be6eba87cfc6ae34905488e7e893"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual NxU32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#0c0a6ed26aa6e349aad0f8e4d691e6ba">overlapCapsuleShapes</a> (const <a class="el" href="classNxCapsule.html">NxCapsule</a> &amp;worldCapsule, <a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a> shapeType, NxU32 nbShapes, <a class="el" href="classNxShape.html">NxShape</a> **shapes, <a class="el" href="classNxUserEntityReport.html">NxUserEntityReport</a>&lt; <a class="el" href="classNxShape.html">NxShape</a> * &gt; *callback, NxU32 activeGroups=0xffffffff, const NxGroupsMask *groupsMask=NULL, bool accurateCollision=false)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the set of shapes overlapped by the world-space capsule.  <a href="#0c0a6ed26aa6e349aad0f8e4d691e6ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxSweepCache.html">NxSweepCache</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#17e15e9f9626bb5f3ca6c6ee86f28745">createSweepCache</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a sweep cache, for use with <a class="el" href="classNxActor.html#7c5a99bd0aa92fcd82ca0326a63003d4">NxActor::linearSweep()</a>. See the Guide, "Sweep API" section for more information.  <a href="#17e15e9f9626bb5f3ca6c6ee86f28745"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#45ae6fcc592ae3955d251a190399778f">releaseSweepCache</a> (<a class="el" href="classNxSweepCache.html">NxSweepCache</a> *cache)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes a sweep cache. See the Guide, "Sweep API" section, for more information on sweep caches. Avoid release calls while the scene is simulating (in between <a class="el" href="classNxScene.html#4016009eb8c4a82959496bdab2cea017">simulate()</a> and <a class="el" href="classNxScene.html#120b86a16a1786546d73a5d22f7d1d55">fetchResults()</a> calls).  <a href="#45ae6fcc592ae3955d251a190399778f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual NxU32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#79146b5e21728905459bcce6db951028">linearOBBSweep</a> (const <a class="el" href="classNxBox.html">NxBox</a> &amp;worldBox, const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;motion, NxU32 flags, void *<a class="el" href="classNxScene.html#d0d0d7ad66c7110490dfd791e6e259e0">userData</a>, NxU32 nbShapes, <a class="el" href="structNxSweepQueryHit.html">NxSweepQueryHit</a> *shapes, <a class="el" href="classNxUserEntityReport.html">NxUserEntityReport</a>&lt; <a class="el" href="structNxSweepQueryHit.html">NxSweepQueryHit</a> &gt; *callback, NxU32 activeGroups=0xffffffff, const NxGroupsMask *groupsMask=NULL)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a linear sweep through space with an oriented box.  <a href="#79146b5e21728905459bcce6db951028"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual NxU32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#8fd2f63d309769b8e0770e322c4c67bb">linearCapsuleSweep</a> (const <a class="el" href="classNxCapsule.html">NxCapsule</a> &amp;worldCapsule, const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;motion, NxU32 flags, void *<a class="el" href="classNxScene.html#d0d0d7ad66c7110490dfd791e6e259e0">userData</a>, NxU32 nbShapes, <a class="el" href="structNxSweepQueryHit.html">NxSweepQueryHit</a> *shapes, <a class="el" href="classNxUserEntityReport.html">NxUserEntityReport</a>&lt; <a class="el" href="structNxSweepQueryHit.html">NxSweepQueryHit</a> &gt; *callback, NxU32 activeGroups=0xffffffff, const NxGroupsMask *groupsMask=NULL)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a linear sweep through space with an oriented capsule.  <a href="#8fd2f63d309769b8e0770e322c4c67bb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual NxU32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#bbcb4747ab0d71bd3f8d193f7953362c">cullShapes</a> (NxU32 nbPlanes, const <a class="el" href="classNxPlane.html">NxPlane</a> *worldPlanes, <a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a> shapeType, NxU32 nbShapes, <a class="el" href="classNxShape.html">NxShape</a> **shapes, <a class="el" href="classNxUserEntityReport.html">NxUserEntityReport</a>&lt; <a class="el" href="classNxShape.html">NxShape</a> * &gt; *callback, NxU32 activeGroups=0xffffffff, const NxGroupsMask *groupsMask=NULL)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the set of shapes which are in the negative half space of a number of planes.  <a href="#bbcb4747ab0d71bd3f8d193f7953362c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#8171b527a010cf2388c92e63f2e86f69">checkOverlapSphere</a> (const <a class="el" href="classNxSphere.html">NxSphere</a> &amp;worldSphere, <a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a> shapeType=NX_ALL_SHAPES, NxU32 activeGroups=0xffffffff, const NxGroupsMask *groupsMask=NULL)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks whether a world-space sphere overlaps a shape or not.  <a href="#8171b527a010cf2388c92e63f2e86f69"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#7a69a48db39b853047d4d71895f90f65">checkOverlapAABB</a> (const <a class="el" href="classNxBounds3.html">NxBounds3</a> &amp;worldBounds, <a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a> shapeType=NX_ALL_SHAPES, NxU32 activeGroups=0xffffffff, const NxGroupsMask *groupsMask=NULL)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks whether a world-space AABB overlaps a shape or not.  <a href="#7a69a48db39b853047d4d71895f90f65"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#7592e53a3d773dd5fef8cb5ae61a1769">checkOverlapOBB</a> (const <a class="el" href="classNxBox.html">NxBox</a> &amp;worldBox, <a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a> shapeType=NX_ALL_SHAPES, NxU32 activeGroups=0xffffffff, const NxGroupsMask *groupsMask=NULL)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks whether a world-space OBB overlaps a shape or not.  <a href="#7592e53a3d773dd5fef8cb5ae61a1769"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#44d027828e380aaab62a202dc975a2bd">checkOverlapCapsule</a> (const <a class="el" href="classNxCapsule.html">NxCapsule</a> &amp;worldCapsule, <a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a> shapeType=NX_ALL_SHAPES, NxU32 activeGroups=0xffffffff, const NxGroupsMask *groupsMask=NULL)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks whether a world-space capsule overlaps something or not.  <a href="#44d027828e380aaab62a202dc975a2bd"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Fluids</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxFluid.html">NxFluid</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#702dc69b6f663dd0ae87505a9e6a9c79">createFluid</a> (const <a class="el" href="classNxFluidDescBase.html">NxFluidDescBase</a> &amp;fluidDesc)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a fluid in this scene.  <a href="#702dc69b6f663dd0ae87505a9e6a9c79"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#8d1bc41f20de36487a6b681ff9b777c8">releaseFluid</a> (<a class="el" href="classNxFluid.html">NxFluid</a> &amp;fluid)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes the specified fluid. The fluid must be in this scene.  <a href="#8d1bc41f20de36487a6b681ff9b777c8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual NxU32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#926e59515115cac7df76c0acd6702698">getNbFluids</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of fluids belonging to the scene.  <a href="#926e59515115cac7df76c0acd6702698"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxFluid.html">NxFluid</a> **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#f76a22106785a6a4ad002faabf0a515a">getFluids</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an array of fluids belonging to the scene.  <a href="#f76a22106785a6a4ad002faabf0a515a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#e56f57e993c0bda21c9ce14ec70da8cc">cookFluidMeshHotspot</a> (const <a class="el" href="classNxBounds3.html">NxBounds3</a> &amp;bounds, NxU32 packetSizeMultiplier, <a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a> restParticlesPerMeter, <a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a> kernelRadiusMultiplier, <a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a> motionLimitMultiplier, <a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a> collisionDistanceMultiplier, <a class="el" href="classNxCompartment.html">NxCompartment</a> *compartment=NULL, bool forceStrictCookingFormat=false)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pre-cooks all triangles from static NxTriangleMeshShapes of the scene which are intersecting with the given bounds.  <a href="#e56f57e993c0bda21c9ce14ec70da8cc"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Cloth</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxCloth.html">NxCloth</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#0827db374f63455d964813d1e7f5eef7">createCloth</a> (const <a class="el" href="classNxClothDesc.html">NxClothDesc</a> &amp;clothDesc)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#2f5f8ebb1a394a37631486d3d494551c">releaseCloth</a> (<a class="el" href="classNxCloth.html">NxCloth</a> &amp;cloth)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual NxU32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#07cfeed3d6cd95d269e285a8c457a3f7">getNbCloths</a> () const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxCloth.html">NxCloth</a> **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#09bb9db5b08d5f15ca6e67786932b4e2">getCloths</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an array of cloth objects.  <a href="#09bb9db5b08d5f15ca6e67786932b4e2"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">SoftBody</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxSoftBody.html">NxSoftBody</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#d25086ed597d2530a61be72b02582320">createSoftBody</a> (const <a class="el" href="classNxSoftBodyDesc.html">NxSoftBodyDesc</a> &amp;softBodyDesc)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#bbd8f11b2727bb38b6608e951b49c5a0">releaseSoftBody</a> (<a class="el" href="classNxSoftBody.html">NxSoftBody</a> &amp;softBody)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual NxU32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#d69c82e02d48ec94b417f88a3f921cbc">getNbSoftBodies</a> () const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxSoftBody.html">NxSoftBody</a> **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#04f3762c8ac1635a1a0a6a080fa42ae9">getSoftBodies</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an array of soft body objects.  <a href="#04f3762c8ac1635a1a0a6a080fa42ae9"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#d0d0d7ad66c7110490dfd791e6e259e0">userData</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">user can assign this to whatever, usually to create a 1:1 relationship with a user object.  <a href="#d0d0d7ad66c7110490dfd791e6e259e0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#2e3f19f751545ab7daf272a14320caff">extLink</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reserved for linkage with other Ageia components. Applications and SDK should not modify  <a href="#2e3f19f751545ab7daf272a14320caff"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#e51a467f955c7098f03199e6e5582fd0">NxScene</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxScene.html#5765dd88d9aa1f256b35ed79c820547b">~NxScene</a> ()</td></tr>

</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="e51a467f955c7098f03199e6e5582fd0"></a><!-- doxytag: member="NxScene::NxScene" ref="e51a467f955c7098f03199e6e5582fd0" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">NxScene::NxScene           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline, protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="5765dd88d9aa1f256b35ed79c820547b"></a><!-- doxytag: member="NxScene::~NxScene" ref="5765dd88d9aa1f256b35ed79c820547b" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual NxScene::~NxScene           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="7a69a48db39b853047d4d71895f90f65"></a><!-- doxytag: member="NxScene::checkOverlapAABB" ref="7a69a48db39b853047d4d71895f90f65" args="(const NxBounds3 &amp;worldBounds, NxShapesType shapeType=NX_ALL_SHAPES, NxU32 activeGroups=0xffffffff, const NxGroupsMask *groupsMask=NULL)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool NxScene::checkOverlapAABB           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxBounds3.html">NxBounds3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>worldBounds</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>shapeType</em> = <code>NX_ALL_SHAPES</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32&nbsp;</td>
          <td class="mdname" nowrap> <em>activeGroups</em> = <code>0xffffffff</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>groupsMask</em> = <code>NULL</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Checks whether a world-space AABB overlaps a shape or not. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>Because the SDK double buffers shape state, a shape will not be updated until a simulation step is taken. For example the result of setting the global pose is not immediatly visible.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>worldBounds</em>&nbsp;</td><td>Axis Aligned Bounding Box in world space. <b>Range:</b> See <a class="el" href="classNxBounds3.html">NxBounds3</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shapeType</em>&nbsp;</td><td>Choose if to intersect with static, dynamic or both types of shape. See <a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>activeGroups</em>&nbsp;</td><td>Mask used to filter shape objects. See <a class="el" href="classNxShape.html#03de2c71a97d1f3b1b30abc7bdc208d1">NxShape::setGroup</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>groupsMask</em>&nbsp;</td><td>Alternative mask used to filter shapes. See <a class="el" href="classNxShape.html#a8eca1891f54640eabf40da27476c5d2">NxShape::setGroupsMask</a></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True if the AABB overlaps a shape.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxBounds3.html">NxBounds3</a> <a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a> <a class="el" href="classNxScene.html#c67f8f88acd1110063fe60e73ba673f6">overlapAABBShapes</a> <a class="el" href="classNxShape.html#fe008f15bebec6527d27a3fea4b19c1d">NxShape.checkOverlapAABB()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="44d027828e380aaab62a202dc975a2bd"></a><!-- doxytag: member="NxScene::checkOverlapCapsule" ref="44d027828e380aaab62a202dc975a2bd" args="(const NxCapsule &amp;worldCapsule, NxShapesType shapeType=NX_ALL_SHAPES, NxU32 activeGroups=0xffffffff, const NxGroupsMask *groupsMask=NULL)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool NxScene::checkOverlapCapsule           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxCapsule.html">NxCapsule</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>worldCapsule</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>shapeType</em> = <code>NX_ALL_SHAPES</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32&nbsp;</td>
          <td class="mdname" nowrap> <em>activeGroups</em> = <code>0xffffffff</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>groupsMask</em> = <code>NULL</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Checks whether a world-space capsule overlaps something or not. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>Because the SDK double buffers shape state, a shape will not be updated until a simulation step is taken. For example the result of setting the global pose is not immediatly visible.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>worldCapsule</em>&nbsp;</td><td>Capsule description in world space. <b>Range:</b> See <a class="el" href="classNxCapsule.html">NxCapsule</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shapeType</em>&nbsp;</td><td>Choose if to intersect with static, dynamic or both types of shape. See <a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>activeGroups</em>&nbsp;</td><td>Mask used to filter shape objects. See <a class="el" href="classNxShape.html#03de2c71a97d1f3b1b30abc7bdc208d1">NxShape::setGroup</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>groupsMask</em>&nbsp;</td><td>Alternative mask used to filter shapes. See <a class="el" href="classNxShape.html#a8eca1891f54640eabf40da27476c5d2">NxShape::setGroupsMask</a></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True if the capsule overlaps a shape.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxCapsule.html">NxCapsule</a> <a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a> <a class="el" href="classNxShape.html#03de2c71a97d1f3b1b30abc7bdc208d1">NxShape.setGroup</a> <a class="el" href="classNxShape.html#a8eca1891f54640eabf40da27476c5d2">NxShape.setGroupsMask</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="7592e53a3d773dd5fef8cb5ae61a1769"></a><!-- doxytag: member="NxScene::checkOverlapOBB" ref="7592e53a3d773dd5fef8cb5ae61a1769" args="(const NxBox &amp;worldBox, NxShapesType shapeType=NX_ALL_SHAPES, NxU32 activeGroups=0xffffffff, const NxGroupsMask *groupsMask=NULL)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool NxScene::checkOverlapOBB           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxBox.html">NxBox</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>worldBox</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>shapeType</em> = <code>NX_ALL_SHAPES</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32&nbsp;</td>
          <td class="mdname" nowrap> <em>activeGroups</em> = <code>0xffffffff</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>groupsMask</em> = <code>NULL</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Checks whether a world-space OBB overlaps a shape or not. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>Because the SDK double buffers shape state, a shape will not be updated until a simulation step is taken. For example the result of setting the global pose is not immediatly visible.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>worldBox</em>&nbsp;</td><td>Oriented Bounding Box in world space. <b>Range:</b> See <a class="el" href="classNxBounds3.html">NxBounds3</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shapeType</em>&nbsp;</td><td>Choose if to intersect with static, dynamic or both types of shape. See <a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>activeGroups</em>&nbsp;</td><td>Mask used to filter shape objects. See <a class="el" href="classNxShape.html#03de2c71a97d1f3b1b30abc7bdc208d1">NxShape::setGroup</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>groupsMask</em>&nbsp;</td><td>Alternative mask used to filter shapes. See <a class="el" href="classNxShape.html#a8eca1891f54640eabf40da27476c5d2">NxShape::setGroupsMask</a></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True if the OBB overlaps a shape.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxBounds3.html">NxBounds3</a> <a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a> <a class="el" href="classNxScene.html#8d27be6eba87cfc6ae34905488e7e893">overlapOBBShapes</a> <a class="el" href="classNxShape.html#738bbb4046686a6f48b889d43210f29d">NxShape.checkOverlapOBB()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="8171b527a010cf2388c92e63f2e86f69"></a><!-- doxytag: member="NxScene::checkOverlapSphere" ref="8171b527a010cf2388c92e63f2e86f69" args="(const NxSphere &amp;worldSphere, NxShapesType shapeType=NX_ALL_SHAPES, NxU32 activeGroups=0xffffffff, const NxGroupsMask *groupsMask=NULL)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool NxScene::checkOverlapSphere           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxSphere.html">NxSphere</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>worldSphere</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>shapeType</em> = <code>NX_ALL_SHAPES</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32&nbsp;</td>
          <td class="mdname" nowrap> <em>activeGroups</em> = <code>0xffffffff</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>groupsMask</em> = <code>NULL</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Checks whether a world-space sphere overlaps a shape or not. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>Because the SDK double buffers shape state, a shape will not be updated until a simulation step is taken. For example the result of setting the global pose is not immediatly visible.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>worldSphere</em>&nbsp;</td><td>Sphere description in world space. <b>Range:</b> See <a class="el" href="classNxSphere.html">NxSphere</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shapeType</em>&nbsp;</td><td>Choose if to intersect with static, dynamic or both types of shape. See <a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>activeGroups</em>&nbsp;</td><td>Mask used to filter shape objects. See <a class="el" href="classNxShape.html#03de2c71a97d1f3b1b30abc7bdc208d1">NxShape::setGroup</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>groupsMask</em>&nbsp;</td><td>Alternative mask used to filter shapes. See <a class="el" href="classNxShape.html#a8eca1891f54640eabf40da27476c5d2">NxShape::setGroupsMask</a></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True if the sphere overlaps a shape.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxSphere.html">NxSphere</a> <a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a> <a class="el" href="classNxScene.html#982c1bbc89e5fa15f45d9b74570d0488">overlapSphereShapes</a> <a class="el" href="classNxShape.html#cf310bdbc3ede3eb80a5ac2366b09ae5">NxShape.checkOverlapSphere()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="5b852665897d56a5f58da38b458718aa"></a><!-- doxytag: member="NxScene::checkResults" ref="5b852665897d56a5f58da38b458718aa" args="(NxSimulationStatus status, bool block=false)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool NxScene::checkResults           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__physics.html#g06fc771bf59dfa0cea3428b5b6d36fc4">NxSimulationStatus</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>status</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>block</em> = <code>false</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This checks to see if the part of the simulation run whose results you are interested in has completed. 
<p>
This does not cause the data available for reading to be updated with the results of the simulation, it is simply a status check. The bool will allow it to either return immediately or block waiting for the condition to be met so that it can return true<p>
This method replaces wait()<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>status</em>&nbsp;</td><td>The part of the simulation to check (eg NX_RIGID_BODY_FINISHED). See <a class="el" href="group__physics.html#g06fc771bf59dfa0cea3428b5b6d36fc4">NxSimulationStatus</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block</em>&nbsp;</td><td>When set to true will block until the condition is met. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True if the results are available.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#4016009eb8c4a82959496bdab2cea017">simulate()</a> <a class="el" href="classNxScene.html#120b86a16a1786546d73a5d22f7d1d55">fetchResults()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="e56f57e993c0bda21c9ce14ec70da8cc"></a><!-- doxytag: member="NxScene::cookFluidMeshHotspot" ref="e56f57e993c0bda21c9ce14ec70da8cc" args="(const NxBounds3 &amp;bounds, NxU32 packetSizeMultiplier, NxReal restParticlesPerMeter, NxReal kernelRadiusMultiplier, NxReal motionLimitMultiplier, NxReal collisionDistanceMultiplier, NxCompartment *compartment=NULL, bool forceStrictCookingFormat=false)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool NxScene::cookFluidMeshHotspot           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxBounds3.html">NxBounds3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32&nbsp;</td>
          <td class="mdname" nowrap> <em>packetSizeMultiplier</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>restParticlesPerMeter</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>kernelRadiusMultiplier</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>motionLimitMultiplier</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>collisionDistanceMultiplier</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classNxCompartment.html">NxCompartment</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>compartment</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>forceStrictCookingFormat</em> = <code>false</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Pre-cooks all triangles from static NxTriangleMeshShapes of the scene which are intersecting with the given bounds. 
<p>
The pre-cooking will only be valid for Fluids which share the specified parameters (see <a class="el" href="classNxFluidDesc.html">NxFluidDesc</a>)<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bounds</em>&nbsp;</td><td>The volume whose contents should be pre-cooked </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>packetSizeMultiplier</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>restParticlesPerMeter</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>kernelRadiusMultiplier</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>motionLimitMultiplier</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>collisionDistanceMultiplier</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>compartment</em>&nbsp;</td><td>The specific compartment to perform the pre-cooking for. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>forceStrictCookingFormat</em>&nbsp;</td><td>Forces specified cooking parameters. Otherwise they might internaly be reinterpreted depending on created fluids. Not implemented yet.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Operation succeeded. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxFluidDesc.html">NxFluidDesc</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="67d5aeda6c35776fd7fbf3ab43cdaaf2"></a><!-- doxytag: member="NxScene::createActor" ref="67d5aeda6c35776fd7fbf3ab43cdaaf2" args="(const NxActorDescBase &amp;desc)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxActor.html">NxActor</a>* NxScene::createActor           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxActorDescBase.html">NxActorDescBase</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>desc</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates an actor in this scene. 
<p>
<a class="el" href="group__physics.html#g9bd5b7be8df1180fb4f407394c1d8040">NxActorDesc::isValid()</a> must return true.<p>
<b>Sleeping:</b> This call wakes the actors if they are sleeping.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>Descriptor for actor to create. See <a class="el" href="classNxActorDescBase.html">NxActorDescBase</a> </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The new actor.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes (Limits on numbers and types of actors) </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html">NxActor</a> <a class="el" href="classNxActorDesc.html">NxActorDesc</a> <a class="el" href="classNxActorDescBase.html">NxActorDescBase</a> <a class="el" href="classNxScene.html#b20ab7bf376ae2238882964c2c10424e">releaseActor()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="0827db374f63455d964813d1e7f5eef7"></a><!-- doxytag: member="NxScene::createCloth" ref="0827db374f63455d964813d1e7f5eef7" args="(const NxClothDesc &amp;clothDesc)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxCloth.html">NxCloth</a>* NxScene::createCloth           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxClothDesc.html">NxClothDesc</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>clothDesc</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a cloth in this scene. <a class="el" href="group__cloth.html#g58697bb24ddccb41175247e97d7fca5b">NxClothDesc::isValid()</a> must return true.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clothDesc</em>&nbsp;</td><td>Description of the cloth object to create. See <a class="el" href="classNxClothDesc.html">NxClothDesc</a>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The new cloth.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxClothDesc.html">NxClothDesc</a> <a class="el" href="classNxCloth.html">NxCloth</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="49ae6e121d3ad73a249421b3798e6de7"></a><!-- doxytag: member="NxScene::createCompartment" ref="49ae6e121d3ad73a249421b3798e6de7" args="(const NxCompartmentDesc &amp;compDesc)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxCompartment.html">NxCompartment</a>* NxScene::createCompartment           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxCompartmentDesc.html">NxCompartmentDesc</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>compDesc</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a scene compartment. 
<p>
A scene compartment is a portion of the scene that can be simulated on a different hardware device than other parts of the scene. See also the User's Guide on Compartments.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>compDesc</em>&nbsp;</td><td>The <a class="el" href="classNxCompartment.html">NxCompartment</a> descriptor to use to create a compartment. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the new compartment.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxCompartment.html">NxCompartment</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="9d67d1623df8fad0503663394b5aa0d0"></a><!-- doxytag: member="NxScene::createEffector" ref="9d67d1623df8fad0503663394b5aa0d0" args="(const NxEffectorDesc &amp;desc)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxEffector.html">NxEffector</a>* NxScene::createEffector           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxEffectorDesc.html">NxEffectorDesc</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>desc</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates an effector. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>The descriptor for the effector to create. See <a class="el" href="classNxEffectorDesc.html">NxEffectorDesc</a>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The new effector.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxSpringAndDamperEffectorDesc.html">NxSpringAndDamperEffectorDesc</a> <a class="el" href="classNxSpringAndDamperEffector.html">NxSpringAndDamperEffector</a> <a class="el" href="classNxScene.html#08fae090bb9ef999c3e265cf886a64d7">releaseEffector()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="702dc69b6f663dd0ae87505a9e6a9c79"></a><!-- doxytag: member="NxScene::createFluid" ref="702dc69b6f663dd0ae87505a9e6a9c79" args="(const NxFluidDescBase &amp;fluidDesc)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxFluid.html">NxFluid</a>* NxScene::createFluid           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxFluidDescBase.html">NxFluidDescBase</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>fluidDesc</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a fluid in this scene. 
<p>
<a class="el" href="group__fluids.html#g5b5fa37bcf7a27a4b3c59e6a0156b02e">NxFluidDesc::isValid()</a> must return true.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fluidDesc</em>&nbsp;</td><td>Description of the fluid object to create. See <a class="el" href="classNxFluidDesc.html">NxFluidDesc</a>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The new fluid.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#8d1bc41f20de36487a6b681ff9b777c8">releaseFluid()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="4440eb8fa1a88501cdeb46e229c3ad6a"></a><!-- doxytag: member="NxScene::createForceField" ref="4440eb8fa1a88501cdeb46e229c3ad6a" args="(const NxForceFieldDesc &amp;forceFieldDesc)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxForceField.html">NxForceField</a>* NxScene::createForceField           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxForceFieldDesc.html">NxForceFieldDesc</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>forceFieldDesc</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a force field. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>forceFieldDesc</em>&nbsp;</td><td>The descriptor for the force field to create. See <a class="el" href="classNxForceFieldDesc.html">NxForceFieldDesc</a>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The new force field.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes [SW fallback] </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#0f5c3108de6e31eaba0e413f3c877087">releaseForceField</a> <a class="el" href="classNxForceField.html">NxForceField</a> <a class="el" href="classNxForceFieldDesc.html">NxForceFieldDesc</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="4b84b8290614e41c7aec528a1d60b737"></a><!-- doxytag: member="NxScene::createForceFieldLinearKernel" ref="4b84b8290614e41c7aec528a1d60b737" args="(const NxForceFieldLinearKernelDesc &amp;kernelDesc)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxForceFieldLinearKernel.html">NxForceFieldLinearKernel</a>* NxScene::createForceFieldLinearKernel           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxForceFieldLinearKernelDesc.html">NxForceFieldLinearKernelDesc</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>kernelDesc</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
creates a forcefield kernel which uses the same linear function as pre 2.8 force fields 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>kernelDesc</em>&nbsp;</td><td>The linear kernel desc to use to create a linear kernel for force fields. See <a class="el" href="classNxForceFieldLinearKernelDesc.html">NxForceFieldLinearKernelDesc</a>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="classNxForceFieldLinearKernel.html">NxForceFieldLinearKernel</a>. See <a class="el" href="classNxForceFieldLinearKernel.html">NxForceFieldLinearKernel</a></dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes [SW fallback] </li>
<li>PS3 : Yes </li>
<li>XB360: Yes </li>
</ul>
    </td>
  </tr>
</table>
<a class="anchor" name="2eac61c6192f6f9b06aa1bcef5b6652a"></a><!-- doxytag: member="NxScene::createForceFieldMaterial" ref="2eac61c6192f6f9b06aa1bcef5b6652a" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="group__physics.html#g6a78f0087de2bc790aff345a36f7552f">NxForceFieldMaterial</a> NxScene::createForceFieldMaterial           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a new index for objects(actor, fluid, cloth, softbody) to access the scaling table, creates a new column in the scaling table. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>NxForceFieldMaterial See <a class="el" href="group__physics.html#g6a78f0087de2bc790aff345a36f7552f">NxForceFieldMaterial</a></dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes [SW fallback] </li>
<li>PS3 : Yes </li>
<li>XB360: Yes </li>
</ul>
    </td>
  </tr>
</table>
<a class="anchor" name="3bdc424db77735ebc3a6218603720cfd"></a><!-- doxytag: member="NxScene::createForceFieldShapeGroup" ref="3bdc424db77735ebc3a6218603720cfd" args="(const NxForceFieldShapeGroupDesc &amp;desc)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxForceFieldShapeGroup.html">NxForceFieldShapeGroup</a>* NxScene::createForceFieldShapeGroup           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxForceFieldShapeGroupDesc.html">NxForceFieldShapeGroupDesc</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>desc</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a new force field shape group. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>The force field group descriptor. See <a class="el" href="classNxForceFieldShapeGroupDesc.html">NxForceFieldShapeGroupDesc</a>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="classNxForceFieldShapeGroup.html">NxForceFieldShapeGroup</a>. See <a class="el" href="classNxForceFieldShapeGroup.html">NxForceFieldShapeGroup</a></dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes [SW fallback] </li>
<li>PS3 : Yes </li>
<li>XB360: Yes </li>
</ul>
    </td>
  </tr>
</table>
<a class="anchor" name="48b98de6cfd7f35ebd1b8b489727dbb1"></a><!-- doxytag: member="NxScene::createForceFieldVariety" ref="48b98de6cfd7f35ebd1b8b489727dbb1" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="group__physics.html#g640c39d5ac1c8eafdb90f3f8c585ee2b">NxForceFieldVariety</a> NxScene::createForceFieldVariety           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a new variety index for force fields to access the scaling table, creates a new row in the scaling table. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>NxForceFieldVariety. See <a class="el" href="group__physics.html#g640c39d5ac1c8eafdb90f3f8c585ee2b">NxForceFieldVariety</a> &amp; <a class="el" href="classNxScene.html#3e2a82f1517151b482ec5878230cc934">setForceFieldScale</a></dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes [SW fallback] </li>
<li>PS3 : Yes </li>
<li>XB360: Yes </li>
</ul>
    </td>
  </tr>
</table>
<a class="anchor" name="b3cba152261abe42a2f90d2e42690170"></a><!-- doxytag: member="NxScene::createJoint" ref="b3cba152261abe42a2f90d2e42690170" args="(const NxJointDesc &amp;jointDesc)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxJoint.html">NxJoint</a>* NxScene::createJoint           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxJointDesc.html">NxJointDesc</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>jointDesc</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a joint. 
<p>
The joint type depends on the type of joint desc passed in.<p>
<b>Sleeping:</b> This call wakes the actor(s) if they are sleeping.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>jointDesc</em>&nbsp;</td><td>The descriptor for the joint to create. E.g. <a class="el" href="classNxSphericalJointDesc.html">NxSphericalJointDesc</a>,<a class="el" href="classNxRevoluteJointDesc.html">NxRevoluteJointDesc</a> etc </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The new joint.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes (Up to 64k per scene) </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxJoint.html">NxJoint</a> <a class="el" href="classNxJointDesc.html">NxJointDesc</a> <a class="el" href="classNxScene.html#00578d1d1016a602df2b8e1f161d3ebb">releaseJoint()</a> <a class="el" href="classNxJoint.html">NxJoint</a> <p>
<a class="el" href="classNxRevoluteJoint.html">NxRevoluteJoint</a> <a class="el" href="classNxSphericalJoint.html">NxSphericalJoint</a> <a class="el" href="classNxPrismaticJoint.html">NxPrismaticJoint</a> <a class="el" href="classNxCylindricalJoint.html">NxCylindricalJoint</a> <a class="el" href="classNxD6Joint.html">NxD6Joint</a> <a class="el" href="classNxDistanceJoint.html">NxDistanceJoint</a> <a class="el" href="classNxFixedJoint.html">NxFixedJoint</a> <a class="el" href="classNxPointInPlaneJoint.html">NxPointInPlaneJoint</a> <a class="el" href="classNxPointOnLineJoint.html">NxPointOnLineJoint</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a16ceef08f12195b0e5e2dd1efd98523"></a><!-- doxytag: member="NxScene::createMaterial" ref="a16ceef08f12195b0e5e2dd1efd98523" args="(const NxMaterialDesc &amp;matDesc)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxMaterial.html">NxMaterial</a>* NxScene::createMaterial           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxMaterialDesc.html">NxMaterialDesc</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>matDesc</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a new <a class="el" href="classNxMaterial.html">NxMaterial</a>. 
<p>
The material library consists of an array of material objects. Each material has a well defined index that can be used to refer to it. If an object (shape or triangle) references an undefined material, the default material with index 0 is used instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>matDesc</em>&nbsp;</td><td>The material desc to use to create a material. See <a class="el" href="classNxMaterialDesc.html">NxMaterialDesc</a>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The new material.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxMaterial.html">NxMaterial</a> <a class="el" href="classNxMaterialDesc.html">NxMaterialDesc</a> <a class="el" href="classNxScene.html#d50c514ff47e8abedcbcd19eff30be4c">releaseMaterial()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="7191a18eb6d75735267a4c33a1e2299a"></a><!-- doxytag: member="NxScene::createSceneQuery" ref="7191a18eb6d75735267a4c33a1e2299a" args="(const NxSceneQueryDesc &amp;desc)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxSceneQuery.html">NxSceneQuery</a>* NxScene::createSceneQuery           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxSceneQueryDesc.html">NxSceneQueryDesc</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>desc</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a batched query object. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>Descriptor used to modify the created query object. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A new query object.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes (software) </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#d60ff389056371621715a19b29e10cf0">releaseSceneQuery()</a> <a class="el" href="classNxSceneQueryDesc.html">NxSceneQueryDesc</a> <a class="el" href="classNxSceneQuery.html">NxSceneQuery</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="d25086ed597d2530a61be72b02582320"></a><!-- doxytag: member="NxScene::createSoftBody" ref="d25086ed597d2530a61be72b02582320" args="(const NxSoftBodyDesc &amp;softBodyDesc)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxSoftBody.html">NxSoftBody</a>* NxScene::createSoftBody           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxSoftBodyDesc.html">NxSoftBodyDesc</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>softBodyDesc</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a soft body in this scene. <a class="el" href="group__softbody.html#gbb6aae706965f18cc80cddcb5128b9a9">NxSoftBodyDesc::isValid()</a> must return true.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>softBodyDesc</em>&nbsp;</td><td>Description of the soft body object to create. See <a class="el" href="classNxSoftBodyDesc.html">NxSoftBodyDesc</a>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The new soft body.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxSoftBodyDesc.html">NxSoftBodyDesc</a> <a class="el" href="classNxSoftBody.html">NxSoftBody</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="daee1f1b73068cf2c32e89268f4d73ed"></a><!-- doxytag: member="NxScene::createSpringAndDamperEffector" ref="daee1f1b73068cf2c32e89268f4d73ed" args="(const NxSpringAndDamperEffectorDesc &amp;springDesc)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxSpringAndDamperEffector.html">NxSpringAndDamperEffector</a>* NxScene::createSpringAndDamperEffector           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxSpringAndDamperEffectorDesc.html">NxSpringAndDamperEffectorDesc</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>springDesc</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Deprecated. Use <a class="el" href="classNxScene.html#9d67d1623df8fad0503663394b5aa0d0">createEffector()</a> instead. 
<p>
<b>Sleeping:</b> Does <b>NOT</b> wake the actor up automatically.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>springDesc</em>&nbsp;</td><td>The descriptor for the spring and damper effector to create. See <a class="el" href="classNxSpringAndDamperEffectorDesc.html">NxSpringAndDamperEffectorDesc</a>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The new spring and damper.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxSpringAndDamperEffectorDesc.html">NxSpringAndDamperEffectorDesc</a> <a class="el" href="classNxSpringAndDamperEffector.html">NxSpringAndDamperEffector</a> <a class="el" href="classNxScene.html#08fae090bb9ef999c3e265cf886a64d7">releaseEffector()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="17e15e9f9626bb5f3ca6c6ee86f28745"></a><!-- doxytag: member="NxScene::createSweepCache" ref="17e15e9f9626bb5f3ca6c6ee86f28745" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxSweepCache.html">NxSweepCache</a>* NxScene::createSweepCache           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a sweep cache, for use with <a class="el" href="classNxActor.html#7c5a99bd0aa92fcd82ca0326a63003d4">NxActor::linearSweep()</a>. See the Guide, "Sweep API" section for more information. 
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html">NxActor</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="bbcb4747ab0d71bd3f8d193f7953362c"></a><!-- doxytag: member="NxScene::cullShapes" ref="bbcb4747ab0d71bd3f8d193f7953362c" args="(NxU32 nbPlanes, const NxPlane *worldPlanes, NxShapesType shapeType, NxU32 nbShapes, NxShape **shapes, NxUserEntityReport&lt; NxShape * &gt; *callback, NxU32 activeGroups=0xffffffff, const NxGroupsMask *groupsMask=NULL)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual NxU32 NxScene::cullShapes           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">NxU32&nbsp;</td>
          <td class="mdname" nowrap> <em>nbPlanes</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classNxPlane.html">NxPlane</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>worldPlanes</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>shapeType</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32&nbsp;</td>
          <td class="mdname" nowrap> <em>nbShapes</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classNxShape.html">NxShape</a> **&nbsp;</td>
          <td class="mdname" nowrap> <em>shapes</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classNxUserEntityReport.html">NxUserEntityReport</a>&lt; <a class="el" href="classNxShape.html">NxShape</a> * &gt; *&nbsp;</td>
          <td class="mdname" nowrap> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32&nbsp;</td>
          <td class="mdname" nowrap> <em>activeGroups</em> = <code>0xffffffff</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>groupsMask</em> = <code>NULL</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the set of shapes which are in the negative half space of a number of planes. 
<p>
This function returns the set of shapes whose axis aligned bounding volumes are in the negative half space(side the normal points away from) of all the planes passed in.<p>
However the set of shapes returned is not conservative, ie additional shapes may be returned which do not actually intersect the union of the planes negative half space.<p>
You can test against static and/or dynamic objects by adjusting 'shapeType'. Shapes are written to the static array 'shapes', which should be big enough to hold 'nbShapes'. An alternative is to use the <a class="el" href="classNxUserEntityReport.html">NxUserEntityReport</a> callback mechanism.<p>
The function returns the total number of collided shapes.<p>
This function can be used for view-frustum culling by passing the 6 camera planes to the function.<p>
<dl compact><dt><b>Note:</b></dt><dd>Because the SDK double buffers shape state, a shape will not be updated until a simulation step is taken. For example the result of setting the global pose is not immediatly visible.</dd></dl>
<dl compact><dt><b>Warning:</b></dt><dd>Passing more than 32 planes to this function is unsupported and may result in undefined behavior.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nbPlanes</em>&nbsp;</td><td>Number of planes to test. (worldPlanes should contain this many planes) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>worldPlanes</em>&nbsp;</td><td>Set of planes to test. <b>Range:</b> See <a class="el" href="classNxPlane.html">NxPlane</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shapeType</em>&nbsp;</td><td>Choose if to intersect with static, dynamic or both types of shape. See <a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nbShapes</em>&nbsp;</td><td>Number of shapes that the buffer shapes can hold. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>shapes</em>&nbsp;</td><td>Buffer to store intersecting shapes. Should be at least sizeof(NxShape *) * nbShapes. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>Alternative method to retrieve overlapping shapes. Is called with sets of overlapping shapes. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>activeGroups</em>&nbsp;</td><td>Mask used to filter shape objects. See <a class="el" href="classNxShape.html#03de2c71a97d1f3b1b30abc7bdc208d1">NxShape::setGroup</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>groupsMask</em>&nbsp;</td><td>Alternative mask used to filter shapes. See <a class="el" href="classNxShape.html#a8eca1891f54640eabf40da27476c5d2">NxShape::setGroupsMask</a></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the total number of collided shapes.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxPlane.html">NxPlane</a> <a class="el" href="classNxScene.html#c67f8f88acd1110063fe60e73ba673f6">overlapAABBShapes()</a> <a class="el" href="classNxScene.html#982c1bbc89e5fa15f45d9b74570d0488">overlapSphereShapes()</a> <a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a> <a class="el" href="classNxUserEntityReport.html">NxUserEntityReport</a> <a class="el" href="classNxShape.html#03de2c71a97d1f3b1b30abc7bdc208d1">NxShape.setGroup()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="120b86a16a1786546d73a5d22f7d1d55"></a><!-- doxytag: member="NxScene::fetchResults" ref="120b86a16a1786546d73a5d22f7d1d55" args="(NxSimulationStatus status, bool block=false, NxU32 *errorState=0)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool NxScene::fetchResults           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__physics.html#g06fc771bf59dfa0cea3428b5b6d36fc4">NxSimulationStatus</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>status</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>block</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32 *&nbsp;</td>
          <td class="mdname" nowrap> <em>errorState</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This is the big brother to <a class="el" href="classNxScene.html#5b852665897d56a5f58da38b458718aa">checkResults()</a> it basically does the following:<p>
<div class="fragment"><pre class="fragment">    <span class="keywordflow">if</span> ( <a class="code" href="classNxScene.html#5b852665897d56a5f58da38b458718aa">checkResults</a>(<span class="keyword">enum</span>, block) )
    {
        fire appropriate callbacks
        swap buffers
        <span class="keywordflow">if</span> (CheckResults(all_enums, <span class="keyword">false</span>))
            make IsWritable() true
        return true
    }
    else
        return false
</pre></div><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>status</em>&nbsp;</td><td>The part of the simulation to fetch results for (eg NX_RIGID_BODY_FINISHED). See <a class="el" href="group__physics.html#g06fc771bf59dfa0cea3428b5b6d36fc4">NxSimulationStatus</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block</em>&nbsp;</td><td>When set to true will block until the condition is met. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>errorState</em>&nbsp;</td><td>Used to retrieve hardware error codes. A non zero value indicates an error. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True if the results have been fetched.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#4016009eb8c4a82959496bdab2cea017">simulate()</a> <a class="el" href="classNxScene.html#5b852665897d56a5f58da38b458718aa">checkResults()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="7b321f8781975932f7bbeb169db2d420"></a><!-- doxytag: member="NxScene::flushCaches" ref="7b321f8781975932f7bbeb169db2d420" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::flushCaches           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Flush internal caches.<p>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes </li>
</ul>
    </td>
  </tr>
</table>
<a class="anchor" name="dc1375a6e1b406c8165ec1f11366ef3e"></a><!-- doxytag: member="NxScene::flushStream" ref="dc1375a6e1b406c8165ec1f11366ef3e" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::flushStream           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Flush the scene's command queue for processing. 
<p>
Flushes any buffered commands so that they get executed. Ensures that commands buffered in the system will continue to make forward progress until completion.<p>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#3f78154dfd007fbf8b6f74884f94657d">setTiming()</a> <a class="el" href="classNxScene.html#4016009eb8c4a82959496bdab2cea017">simulate()</a> <a class="el" href="classNxScene.html#120b86a16a1786546d73a5d22f7d1d55">fetchResults()</a> <a class="el" href="classNxScene.html#5b852665897d56a5f58da38b458718aa">checkResults()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="df889afe53779dfe07818c14990b24f0"></a><!-- doxytag: member="NxScene::getActiveTransforms" ref="df889afe53779dfe07818c14990b24f0" args="(NxU32 &amp;nbTransformsOut)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structNxActiveTransform.html">NxActiveTransform</a>* NxScene::getActiveTransforms           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">NxU32 &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>nbTransformsOut</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Queries the <a class="el" href="classNxScene.html">NxScene</a> for a list of the NxActors whose transforms have been updated during the previous simulation step. 
<p>
Note: NX_SF_ENABLE_ACTIVETRANSFORMS must be set.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>nbTransformsOut</em>&nbsp;</td><td>The number of transforms returned.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A pointer to the list of NxActiveTransforms generated during the last call to <a class="el" href="classNxScene.html#120b86a16a1786546d73a5d22f7d1d55">fetchResults()</a>.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="structNxActiveTransform.html">NxActiveTransform</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="3f23c6571599aa7e789e00ae25ddfb7d"></a><!-- doxytag: member="NxScene::getActorGroupPairArray" ref="3f23c6571599aa7e789e00ae25ddfb7d" args="(NxActorGroupPair *userBuffer, NxU32 bufferSize, NxU32 &amp;userIterator) const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual NxU32 NxScene::getActorGroupPairArray           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structNxActorGroupPair.html">NxActorGroupPair</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>userBuffer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32&nbsp;</td>
          <td class="mdname" nowrap> <em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32 &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>userIterator</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Writes the scene's array of actor group flags (as set by setActorGroupPairFlags) to a user buffer. 
<p>
bufferSize is the number of NxActorGroupPairs (not bytes) that the buffer can hold. usersIterator is an iterator that the user should initialize to 0 to start copying the array from the beginning. Once the first call succeeds, the SDK will have changed the value of the iterator (in some data structure specific way) such that the next get*Array() call will return the next batch of values. This way a large internal array can be read out with several calls into a smaller user side buffer.<p>
<dl compact><dt><b>Returns:</b></dt><dd>the number of pairs written, this should be less or equal to bufferSize.</dd></dl>
The ordering of the elements in the array is not specified.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>userBuffer</em>&nbsp;</td><td>The buffer to receive NxActorGroupPairs. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bufferSize</em>&nbsp;</td><td>The number of NxActorGroupPairs which can be stored in the buffer. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>userIterator</em>&nbsp;</td><td>Cookie used to continue iteration from the last position. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of pairs written to userBuffer.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#6109dca606a802788d247befa02e75c6">getNbActorGroupPairs()</a> <a class="el" href="structNxActorGroupPair.html">NxActorGroupPair</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="871ae96ecabb8808e707a1616a3417b0"></a><!-- doxytag: member="NxScene::getActorGroupPairFlags" ref="871ae96ecabb8808e707a1616a3417b0" args="(NxActorGroup group1, NxActorGroup group2) const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual NxU32 NxScene::getActorGroupPairFlags           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__physics.html#gd7d66f3c79185448a29cbc084ddcfefb">NxActorGroup</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>group1</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__physics.html#gd7d66f3c79185448a29cbc084ddcfefb">NxActorGroup</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>group2</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This reads the value set with <a class="el" href="classNxScene.html#c918ed0ade26efb4df810e495924e05c">setActorGroupPairFlags</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>group1</em>&nbsp;</td><td>First Group </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>group2</em>&nbsp;</td><td>Second Group </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The contact reporting flags associated with this actor pair. See <a class="el" href="classNxScene.html#c918ed0ade26efb4df810e495924e05c">setActorGroupPairFlags</a>.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#124e55cbcbfa0a5bcf6a8f19f36fd5fe">setActorPairFlags()</a> <a class="el" href="group__physics.html#gd7d66f3c79185448a29cbc084ddcfefb">NxActorGroup</a> <a class="el" href="classNxActor.html#13d0bf7a27e8870eb93e233dbb8107ec">NxActor.getGroup()</a> <a class="el" href="classNxActor.html#3f2e3d34803c146d47264099cf27a7dc">NxActor.setGroup()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a6c8692f4c06a00658c2831e80608b7b"></a><!-- doxytag: member="NxScene::getActorPairFlags" ref="a6c8692f4c06a00658c2831e80608b7b" args="(NxActor &amp;actorA, NxActor &amp;actorB) const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual NxU32 NxScene::getActorPairFlags           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classNxActor.html">NxActor</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>actorA</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classNxActor.html">NxActor</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>actorB</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the pair flags for the given pair of actors. 
<p>
The pair flags are a combination of bits defined by <a class="el" href="group__physics.html#g05983d9ea71be115e74f0a5d6a7559cc">NxContactPairFlag</a>. If no pair record is found, zero is returned. The two actor references must not reference the same actor.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actorA</em>&nbsp;</td><td>Actor A </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actorB</em>&nbsp;</td><td>Actor B </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The actor pair flags.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#124e55cbcbfa0a5bcf6a8f19f36fd5fe">setActorPairFlags()</a> <a class="el" href="group__physics.html#g05983d9ea71be115e74f0a5d6a7559cc">NxContactPairFlag</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="195d2f4d72ef884c90d7bc9fc7b2e858"></a><!-- doxytag: member="NxScene::getActors" ref="195d2f4d72ef884c90d7bc9fc7b2e858" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxActor.html">NxActor</a>** NxScene::getActors           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieve an array of all the actors in the scene. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>an array of actor pointers with size <a class="el" href="classNxScene.html#ff41faf917ed8be6ccc9f493e3e10102">getNbActors()</a>.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#ff41faf917ed8be6ccc9f493e3e10102">getNbActors()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="50d187eb84fed8911460eb0a70219d8d"></a><!-- doxytag: member="NxScene::getBoundForIslandSize" ref="50d187eb84fed8911460eb0a70219d8d" args="(NxActor &amp;actor)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual NxU32 NxScene::getBoundForIslandSize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classNxActor.html">NxActor</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>actor</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns an upper bound for the number of actors in the collision island of a certain actor. 
<p>
A collision island is a group of objects that are connected through bounds overlaps or joint constraints.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor</em>&nbsp;</td><td>The actor for which to return island information</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The maximum size of the internal actor array.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#bec8ca470bcb8656b1b1b3a52ea9d76c">getIslandArrayFromActor()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="09bb9db5b08d5f15ca6e67786932b4e2"></a><!-- doxytag: member="NxScene::getCloths" ref="09bb9db5b08d5f15ca6e67786932b4e2" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxCloth.html">NxCloth</a>** NxScene::getCloths           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns an array of cloth objects. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>an array of cloth pointers with size <a class="el" href="classNxScene.html#07cfeed3d6cd95d269e285a8c457a3f7">getNbCloths()</a>.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#07cfeed3d6cd95d269e285a8c457a3f7">getNbCloths()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="57c06bc02979452cd547a7b012869823"></a><!-- doxytag: member="NxScene::getClothUserNotify" ref="57c06bc02979452cd547a7b012869823" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxClothUserNotify.html">NxClothUserNotify</a>* NxScene::getClothUserNotify           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the <a class="el" href="classNxClothUserNotify.html">NxClothUserNotify</a> pointer set with <a class="el" href="classNxScene.html#892fa4cbd5abae3506c4127e12c96a1b">setClothUserNotify()</a>. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The current user cloth notify pointer. See <a class="el" href="classNxClothUserNotify.html">NxClothUserNotify</a>.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: No </li>
<li>PPU : No </li>
<li>PS3 : No </li>
<li>XB360: No</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxClothUserNotify.html">NxClothUserNotify</a> <a class="el" href="classNxScene.html#892fa4cbd5abae3506c4127e12c96a1b">setClothUserNotify()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="c3d087ba9fe3f55e900b625dbc40b9a3"></a><!-- doxytag: member="NxScene::getCompartmentArray" ref="c3d087ba9fe3f55e900b625dbc40b9a3" args="(NxCompartment **userBuffer, NxU32 bufferSize, NxU32 &amp;usersIterator) const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual NxU32 NxScene::getCompartmentArray           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classNxCompartment.html">NxCompartment</a> **&nbsp;</td>
          <td class="mdname" nowrap> <em>userBuffer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32&nbsp;</td>
          <td class="mdname" nowrap> <em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32 &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>usersIterator</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Writes the scene's array of <a class="el" href="classNxCompartment.html">NxCompartment</a> pointers to a user buffer. 
<p>
bufferSize is the number of pointers (not bytes) that the buffer can hold. usersIterator is an iterator that the user should initialize to 0 to start copying the array from the beginning. Once the first call succeeds, the SDK will have changed the value of the iterator (in some data structure specific way) such that the next get*Array() call will return the next batch of values. This way a large internal array can be read out with several calls into a smaller user side buffer.<p>
Returns the number of pointers written, this should be less or equal to bufferSize.<p>
The ordering of the compartments in the array is not specified.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>userBuffer</em>&nbsp;</td><td>The buffer to receive compartment pointers. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bufferSize</em>&nbsp;</td><td>The number of compartment pointers which can be stored in the buffer. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>usersIterator</em>&nbsp;</td><td>Cookie used to continue iteration from the last position. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of compartment pointers written to userBuffer.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#57e9f78a29a1f4f19da279ba0821211f">getNbCompartments()</a> <a class="el" href="classNxCompartment.html">NxCompartment</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a403e652cd1e77a3d687183aac63bdc5"></a><!-- doxytag: member="NxScene::getDebugRenderable" ref="a403e652cd1e77a3d687183aac63bdc5" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual const <a class="el" href="classNxDebugRenderable.html">NxDebugRenderable</a>* NxScene::getDebugRenderable           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the debug renderable. 
<p>
This will contain the results of any active visualization for this scene. <dl compact><dt><b>Returns:</b></dt><dd>The debug renderable.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : No </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxDebugRenderable.html">NxDebugRenderable</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="44709422d5269f4966451964958c0bd6"></a><!-- doxytag: member="NxScene::getDominanceGroupPair" ref="44709422d5269f4966451964958c0bd6" args="(NxDominanceGroup group1, NxDominanceGroup group2) const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="structNxConstraintDominance.html">NxConstraintDominance</a> NxScene::getDominanceGroupPair           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__physics.html#gd17c09bc9705b7db96e260dffffdb381">NxDominanceGroup</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>group1</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__physics.html#gd17c09bc9705b7db96e260dffffdb381">NxDominanceGroup</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>group2</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Samples the dominance matrix. 
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#b3a23eb788d2c6e290e3d14d8d5a2a79">setDominanceGroupPair()</a> <a class="el" href="group__physics.html#gd17c09bc9705b7db96e260dffffdb381">NxDominanceGroup</a> <a class="el" href="structNxConstraintDominance.html">NxConstraintDominance</a> <a class="el" href="classNxActor.html#589c806ed21ba3b8abe624e65d9c46a2">NxActor::setDominanceGroup()</a> <a class="el" href="classNxActor.html#0809ec35a615e40824d13bf373ef3587">NxActor::getDominanceGroup()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="898c074684ead2e0efb5845a123ef2aa"></a><!-- doxytag: member="NxScene::getDynamicTreeRebuildRateHint" ref="898c074684ead2e0efb5845a123ef2aa" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual NxU32 NxScene::getDynamicTreeRebuildRateHint           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the rebuild rate of the dynamic tree pruning structure. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The rebuild rate of the dyamic tree pruning structure.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxSceneDesc.html#bcf4bdeab4980bd80dacdddb548d2cdc">NxSceneDesc.dynamicTreeRebuildRateHint</a> <a class="el" href="classNxScene.html#e6195bf85df84d67e3918bb92e8bf25c">setDynamicTreeRebuildRateHint()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="b1d3932cf4bbfcd3e80b8548299ff233"></a><!-- doxytag: member="NxScene::getFilterBool" ref="b1d3932cf4bbfcd3e80b8548299ff233" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool NxScene::getFilterBool           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves filtering's boolean value. See comments for <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a>. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>flag Boolean value for filter.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#aeeaf92ff2dfef1b536e615220b2e240">setFilterBool()</a> <a class="el" href="classNxScene.html#92135aeafe85554cd926cfe06bae8c54">setFilterConstant0()</a> <a class="el" href="classNxScene.html#504622ffdbd9815dae2e06fcea079cd5">setFilterConstant1()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="13b6807a00e9b4aeea5c6684d382e641"></a><!-- doxytag: member="NxScene::getFilterConstant0" ref="13b6807a00e9b4aeea5c6684d382e641" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a> NxScene::getFilterConstant0           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets filtering constant K0. See comments for <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a>. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>the filtering constant, as a mask. See <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a>.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#ee66b7fbef5420ad6b16df1e6180def6">setFilterOps()</a> <a class="el" href="classNxScene.html#aeeaf92ff2dfef1b536e615220b2e240">setFilterBool()</a> <a class="el" href="classNxScene.html#92135aeafe85554cd926cfe06bae8c54">setFilterConstant0()</a> <a class="el" href="classNxScene.html#504622ffdbd9815dae2e06fcea079cd5">setFilterConstant1()</a> <a class="el" href="classNxScene.html#813480493abe1a4f03803dfad7e222ae">getFilterConstant1()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="813480493abe1a4f03803dfad7e222ae"></a><!-- doxytag: member="NxScene::getFilterConstant1" ref="813480493abe1a4f03803dfad7e222ae" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a> NxScene::getFilterConstant1           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets filtering constant K1. See comments for <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a>. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>the filtering constant, as a mask. See <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a>.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#ee66b7fbef5420ad6b16df1e6180def6">setFilterOps()</a> <a class="el" href="classNxScene.html#aeeaf92ff2dfef1b536e615220b2e240">setFilterBool()</a> <a class="el" href="classNxScene.html#92135aeafe85554cd926cfe06bae8c54">setFilterConstant0()</a> <a class="el" href="classNxScene.html#504622ffdbd9815dae2e06fcea079cd5">setFilterConstant1()</a> <a class="el" href="classNxScene.html#13b6807a00e9b4aeea5c6684d382e641">getFilterConstant0()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="2a93a86afa41862dd9e796ab63731c49"></a><!-- doxytag: member="NxScene::getFilterOps" ref="2a93a86afa41862dd9e796ab63731c49" args="(NxFilterOp &amp;op0, NxFilterOp &amp;op1, NxFilterOp &amp;op2) const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::getFilterOps           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__physics.html#g0bb727ab008ff2a2cfcf2533489b58f2">NxFilterOp</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>op0</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__physics.html#g0bb727ab008ff2a2cfcf2533489b58f2">NxFilterOp</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>op1</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__physics.html#g0bb727ab008ff2a2cfcf2533489b58f2">NxFilterOp</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>op2</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves filtering operation. See comments for <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>op0</em>&nbsp;</td><td>First filter operator. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>op1</em>&nbsp;</td><td>Second filter operator. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>op2</em>&nbsp;</td><td>Third filter operator.</td></tr>
  </table>
</dl>
See the user guide page "Contact Filtering" for more details.<p>
<dl compact><dt><b>Returns:</b></dt><dd>the filter operation requested</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#ee66b7fbef5420ad6b16df1e6180def6">setFilterOps()</a> <a class="el" href="classNxScene.html#aeeaf92ff2dfef1b536e615220b2e240">setFilterBool()</a> <a class="el" href="classNxScene.html#92135aeafe85554cd926cfe06bae8c54">setFilterConstant0()</a> <a class="el" href="classNxScene.html#504622ffdbd9815dae2e06fcea079cd5">setFilterConstant1()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="860585418b2fd79c7a7d0b7c2cbc159e"></a><!-- doxytag: member="NxScene::getFlags" ref="860585418b2fd79c7a7d0b7c2cbc159e" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual NxU32 NxScene::getFlags           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the scene flags. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The scene flags. See <a class="el" href="group__physics.html#g19b64b752f22309935028abaec2f7e58">NxSceneFlags</a></dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__physics.html#g19b64b752f22309935028abaec2f7e58">NxSceneFlags</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="f76a22106785a6a4ad002faabf0a515a"></a><!-- doxytag: member="NxScene::getFluids" ref="f76a22106785a6a4ad002faabf0a515a" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxFluid.html">NxFluid</a>** NxScene::getFluids           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get an array of fluids belonging to the scene. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>an array of fluid pointers with size <a class="el" href="classNxScene.html#926e59515115cac7df76c0acd6702698">getNbFluids()</a>.<p>
An array of fluid objects belonging to this scene.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#926e59515115cac7df76c0acd6702698">getNbFluids()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="4d92af89425c2955b62abc5a26f5a0e2"></a><!-- doxytag: member="NxScene::getFluidUserNotify" ref="4d92af89425c2955b62abc5a26f5a0e2" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxFluidUserNotify.html">NxFluidUserNotify</a>* NxScene::getFluidUserNotify           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the <a class="el" href="classNxFluidUserNotify.html">NxFluidUserNotify</a> pointer set with setfluidUserNotify(). 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The current user fluid notify pointer. See <a class="el" href="classNxFluidUserNotify.html">NxFluidUserNotify</a>.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: No </li>
<li>PPU : No </li>
<li>PS3 : No </li>
<li>XB360: No</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxFluidUserNotify.html">NxFluidUserNotify</a> <a class="el" href="classNxScene.html#8262e2bfac8fa7c4e3ca5a2ab949fb86">setFluidUserNotify()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="1f0bb5e599e817d98a1e44ce592d487a"></a><!-- doxytag: member="NxScene::getForceFields" ref="1f0bb5e599e817d98a1e44ce592d487a" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxForceField.html">NxForceField</a>** NxScene::getForceFields           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the force fields in the scene. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Array of pointers to <a class="el" href="classNxForceField.html">NxForceField</a> objects. Use <a class="el" href="classNxScene.html#7b569fb4fbad438542702d0783ae7bf6">getNbForceFields</a> to find the size of the array.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes [SW fallback] </li>
<li>PS3 : Yes </li>
<li>XB360: Yes </li>
</ul>
    </td>
  </tr>
</table>
<a class="anchor" name="539455577b07f393398ed5e90205614e"></a><!-- doxytag: member="NxScene::getForceFieldScale" ref="539455577b07f393398ed5e90205614e" args="(NxForceFieldVariety var, NxForceFieldMaterial mat)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a> NxScene::getForceFieldScale           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__physics.html#g640c39d5ac1c8eafdb90f3f8c585ee2b">NxForceFieldVariety</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__physics.html#g6a78f0087de2bc790aff345a36f7552f">NxForceFieldMaterial</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>mat</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the scaling value for a given variety/material pair. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The scaling value for a given variety/material pair.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes [SW fallback] </li>
<li>PS3 : Yes </li>
<li>XB360: Yes </li>
</ul>
    </td>
  </tr>
</table>
<a class="anchor" name="90d1d018192a6fd4ebe6bb7b4ceb6eae"></a><!-- doxytag: member="NxScene::getGravity" ref="90d1d018192a6fd4ebe6bb7b4ceb6eae" args="(NxVec3 &amp;vec)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::getGravity           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classNxVec3.html">NxVec3</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>vec</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the current gravity setting. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>vec</em>&nbsp;</td><td>Used to retrieve the current gravity for the scene.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#3d35ff91cee3f0a6b7c0f4afb63b2766">setGravity()</a> <a class="el" href="classNxSceneDesc.html#5a464293323cfe168685b120f52d82ea">NxSceneDesc.gravity</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="c4d2b48b89c0398869399b5db6e4ec0b"></a><!-- doxytag: member="NxScene::getGroupCollisionFlag" ref="c4d2b48b89c0398869399b5db6e4ec0b" args="(NxCollisionGroup group1, NxCollisionGroup group2) const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool NxScene::getGroupCollisionFlag           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__physics.html#gb144febecb4fc60da5d48839c14c2501">NxCollisionGroup</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>group1</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__physics.html#gb144febecb4fc60da5d48839c14c2501">NxCollisionGroup</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>group2</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Determines if collision detection is performed between a pair of groups. 
<p>
NxCollisionGroup is an integer between 0 and 31.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>group1</em>&nbsp;</td><td>First Group. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>group2</em>&nbsp;</td><td>Second Group. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True if the groups could collide.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#5d3b6f687c209e0c7d88d3c7b0ec0d81">setGroupCollisionFlag()</a> <a class="el" href="group__physics.html#gb144febecb4fc60da5d48839c14c2501">NxCollisionGroup</a> <a class="el" href="classNxShape.html#03de2c71a97d1f3b1b30abc7bdc208d1">NxShape.setGroup()</a> <a class="el" href="classNxShape.html#00020779ec876e57b4a9f839f2fbeaca">NxShape.getGroup()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="5661adb68661fa166d6b94ff77f457aa"></a><!-- doxytag: member="NxScene::getHighestForceFieldMaterial" ref="5661adb68661fa166d6b94ff77f457aa" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="group__physics.html#g6a78f0087de2bc790aff345a36f7552f">NxForceFieldMaterial</a> NxScene::getHighestForceFieldMaterial           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the highest allocated force field material. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The highest allocated force field material. See <a class="el" href="group__physics.html#g6a78f0087de2bc790aff345a36f7552f">NxForceFieldMaterial</a></dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes [SW fallback] </li>
<li>PS3 : Yes </li>
<li>XB360: Yes </li>
</ul>
    </td>
  </tr>
</table>
<a class="anchor" name="05797b48870311ea4dc6ccab219b8e53"></a><!-- doxytag: member="NxScene::getHighestForceFieldVariety" ref="05797b48870311ea4dc6ccab219b8e53" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="group__physics.html#g640c39d5ac1c8eafdb90f3f8c585ee2b">NxForceFieldVariety</a> NxScene::getHighestForceFieldVariety           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the highest allocated force field variety. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Highest variety index See <a class="el" href="group__physics.html#g640c39d5ac1c8eafdb90f3f8c585ee2b">NxForceFieldVariety</a></dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes [SW fallback] </li>
<li>PS3 : Yes </li>
<li>XB360: Yes </li>
</ul>
    </td>
  </tr>
</table>
<a class="anchor" name="bde32b80a6a4adc3dd4b5606a938ff07"></a><!-- doxytag: member="NxScene::getHighestMaterialIndex" ref="bde32b80a6a4adc3dd4b5606a938ff07" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="group__physics.html#g7c86954f381ead77b9fbf58daa9eda52">NxMaterialIndex</a> NxScene::getHighestMaterialIndex           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns current highest valid material index. 
<p>
Note that not all indices below this are valid if some of them belong to meshes that have been freed.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The highest material index.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxMaterial.html">NxMaterial</a> <a class="el" href="group__physics.html#g7c86954f381ead77b9fbf58daa9eda52">NxMaterialIndex</a> <a class="el" href="classNxScene.html#a16ceef08f12195b0e5e2dd1efd98523">NxScene.createMaterial()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="4d1184b969a64b2b2f9d5483767bbe15"></a><!-- doxytag: member="NxScene::getInternal" ref="4d1184b969a64b2b2f9d5483767bbe15" args="(void)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void* NxScene::getInternal           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets a private interface to an internal debug object. 
<p>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes </li>
</ul>
    </td>
  </tr>
</table>
<a class="anchor" name="bec8ca470bcb8656b1b1b3a52ea9d76c"></a><!-- doxytag: member="NxScene::getIslandArrayFromActor" ref="bec8ca470bcb8656b1b1b3a52ea9d76c" args="(NxActor &amp;actor, NxActor **userBuffer, NxU32 bufferSize, NxU32 &amp;userIterator)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual NxU32 NxScene::getIslandArrayFromActor           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classNxActor.html">NxActor</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>actor</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classNxActor.html">NxActor</a> **&nbsp;</td>
          <td class="mdname" nowrap> <em>userBuffer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32&nbsp;</td>
          <td class="mdname" nowrap> <em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32 &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>userIterator</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Writes pointers to the actors making up the collision island of a certain actor to a user buffer. 
<p>
A collision island is a group of objects that are connected through bounds overlaps or joint constraints.<p>
bufferSize is the number of pointers (not bytes) that the buffer can hold. usersIterator is an iterator that the user should initialize to 0 to start copying the array from the beginning. Once the first call succeeds, the SDK will have changed the value of the iterator (in some data structure specific way) such that the next get*Array() call will return the next batch of values. This way a large internal array can be read out with several calls into a smaller user side buffer.<p>
Returns the number of pointers written, this should be less or equal to bufferSize. This will include the specified actor.<p>
The ordering of the actors in the array is not specified. Note that this call is invalid while the scene is simulating (in between <a class="el" href="classNxScene.html#4016009eb8c4a82959496bdab2cea017">simulate()</a> and <a class="el" href="classNxScene.html#120b86a16a1786546d73a5d22f7d1d55">fetchResults()</a> calls). Also, the island is based on the state just before the last simulation step, which means the islands may be somewhat inaccurate, especially for fast moving objects.<p>
Usage example: <div class="fragment"><pre class="fragment">    <a class="code" href="classNxActor.html">NxActor</a> * ptrs[3];
    NxU32 iterator = 0;
    NxU32 actorCount;
    <span class="keywordflow">while</span> (actorCount = s-&gt;getIslandArrayFromActor(actor, ptrs, 3, iterator))
        <span class="keywordflow">while</span>(actorCount--) processActor(ptrs[actorCount]);
</pre></div><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor</em>&nbsp;</td><td>The actor for which to return island information </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>userBuffer</em>&nbsp;</td><td>The buffer to receive actor pointers. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bufferSize</em>&nbsp;</td><td>The number of actor pointers which can be stored in the buffer. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>userIterator</em>&nbsp;</td><td>Cookie used to continue iteration from the last position. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of actor pointers written to userBuffer.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#50d187eb84fed8911460eb0a70219d8d">getBoundForIslandSize()</a> <a class="el" href="classNxActor.html">NxActor</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="45595724e4b7e4c7a0f6c41a704d11f5"></a><!-- doxytag: member="NxScene::getLimits" ref="45595724e4b7e4c7a0f6c41a704d11f5" args="(NxSceneLimits &amp;limits) const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::getLimits           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classNxSceneLimits.html">NxSceneLimits</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>limits</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Call to retrieve the expected object count limits set in the scene descriptor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>limits</em>&nbsp;</td><td>Used to retrieve the limits for the scene(e.g. maximum number of actors). See <a class="el" href="classNxSceneLimits.html">NxSceneLimits</a>.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxSceneLimits.html">NxSceneLimits</a> <a class="el" href="classNxScene.html#a10e6e8e16467c8ba360bc46646e7769">getStats()</a> <a class="el" href="classNxSceneStats.html">NxSceneStats</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="5a2a95c92eec6ae1cbe599f419dafbb5"></a><!-- doxytag: member="NxScene::getMaterialArray" ref="5a2a95c92eec6ae1cbe599f419dafbb5" args="(NxMaterial **userBuffer, NxU32 bufferSize, NxU32 &amp;usersIterator)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual NxU32 NxScene::getMaterialArray           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classNxMaterial.html">NxMaterial</a> **&nbsp;</td>
          <td class="mdname" nowrap> <em>userBuffer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32&nbsp;</td>
          <td class="mdname" nowrap> <em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32 &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>usersIterator</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Writes the scene's array of material pointers to a user buffer. 
<p>
bufferSize is the number of pointers (not bytes) that the buffer can hold. usersIterator is an iterator that the user should initialize to 0 to start copying the array from the beginning. Once the first call succeeds, the SDK will have changed the value of the iterator (in some data structure specific way) such that the next get*Array() call will return the next batch of values. This way a large internal array can be read out with several calls into a smaller user side buffer.<p>
Returns the number of pointers written, this should be less or equal to bufferSize. This will also return the default material which exists without having to be created.<p>
The ordering of the materials in the array is not specified.<p>
Usage example: <div class="fragment"><pre class="fragment">    <a class="code" href="classNxMaterial.html">NxMaterial</a> * ptrs[3];
    NxU32 iterator = 0;
    NxU32 materialCount;
    <span class="keywordflow">while</span> (materialCount = s-&gt;getMaterialArray(ptrs, 3, iterator))
        <span class="keywordflow">while</span>(materialCount--) processMaterial(ptrs[materialCount]);
</pre></div><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>userBuffer</em>&nbsp;</td><td>The buffer to receive material pointers. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bufferSize</em>&nbsp;</td><td>The number of material pointers which can be stored in the buffer. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>usersIterator</em>&nbsp;</td><td>Cookie used to continue iteration from the last position. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of material pointers written to userBuffer.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#ec4836f6a7218e7a8a7354e0233398d9">getNbMaterials()</a> <a class="el" href="classNxMaterial.html">NxMaterial</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="9357a48b1d90d7a9634ab5743f3650be"></a><!-- doxytag: member="NxScene::getMaterialFromIndex" ref="9357a48b1d90d7a9634ab5743f3650be" args="(NxMaterialIndex matIndex)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxMaterial.html">NxMaterial</a>* NxScene::getMaterialFromIndex           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__physics.html#g7c86954f381ead77b9fbf58daa9eda52">NxMaterialIndex</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>matIndex</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the material with the given material index. 
<p>
There is always at least one material in the Scene, the default material (index 0). If the specified material index is out of range (larger than getHighestMaterialIndex) or belongs to a material that has been released, then the default material is returned, but no error is reported.<p>
You can always get a pointer to the default material by specifying index 0. You can change the properties of the default material by changing the properties directly on the material. It is not possible to release the default material, calling releaseMaterial(defaultMaterial) has no effect.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>matIndex</em>&nbsp;</td><td>Material index to retrieve. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The associated material.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxMaterial.html">NxMaterial</a> <a class="el" href="group__physics.html#g7c86954f381ead77b9fbf58daa9eda52">NxMaterialIndex</a> <a class="el" href="classNxScene.html#a16ceef08f12195b0e5e2dd1efd98523">NxScene.createMaterial()</a> <a class="el" href="classNxScene.html#bde32b80a6a4adc3dd4b5606a938ff07">getHighestMaterialIndex()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="2b8afea9fdd7a6037c241e4968ab33d9"></a><!-- doxytag: member="NxScene::getMaxCPUForLoadBalancing" ref="2b8afea9fdd7a6037c241e4968ab33d9" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a> NxScene::getMaxCPUForLoadBalancing           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Call to get the maximum CPU for use when load-balancing. 
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#6c9f687bded62d2edfacfc858a563a0a">setMaxCPUForLoadBalancing()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="6109dca606a802788d247befa02e75c6"></a><!-- doxytag: member="NxScene::getNbActorGroupPairs" ref="6109dca606a802788d247befa02e75c6" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual NxU32 NxScene::getNbActorGroupPairs           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the number of actor group flags (as set by setActorGroupPairFlags). 
<p>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : No </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="structNxActorGroupPair.html">NxActorGroupPair</a>, <a class="el" href="classNxScene.html#871ae96ecabb8808e707a1616a3417b0">getActorGroupPairFlags()</a>, <a class="el" href="classNxScene.html#3f23c6571599aa7e789e00ae25ddfb7d">getActorGroupPairArray()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ff41faf917ed8be6ccc9f493e3e10102"></a><!-- doxytag: member="NxScene::getNbActors" ref="ff41faf917ed8be6ccc9f493e3e10102" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual NxU32 NxScene::getNbActors           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieve the number of actors in the scene. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>the number of actors.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#195d2f4d72ef884c90d7bc9fc7b2e858">getActors()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="07cfeed3d6cd95d269e285a8c457a3f7"></a><!-- doxytag: member="NxScene::getNbCloths" ref="07cfeed3d6cd95d269e285a8c457a3f7" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual NxU32 NxScene::getNbCloths           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Returns:</b></dt><dd>the number of cloths.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#09bb9db5b08d5f15ca6e67786932b4e2">getCloths()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="57e9f78a29a1f4f19da279ba0821211f"></a><!-- doxytag: member="NxScene::getNbCompartments" ref="57e9f78a29a1f4f19da279ba0821211f" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual NxU32 NxScene::getNbCompartments           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the number of compartments created in the scene. 
<p>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxCompartment.html">NxCompartment</a>, <a class="el" href="classNxScene.html#c3d087ba9fe3f55e900b625dbc40b9a3">getCompartmentArray()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="20c0d3d5d2146f42c02b0e9dc0ccccba"></a><!-- doxytag: member="NxScene::getNbDynamicShapes" ref="20c0d3d5d2146f42c02b0e9dc0ccccba" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual NxU32 NxScene::getNbDynamicShapes           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the number of dynamic shapes in the scene. Note that this includes compartments and mirrored shapes in compartments. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>the number of dynamic shapes.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#92bef655316556dfd2856dd998f54955">getNbStaticShapes()</a> <p>
<a class="el" href="classNxScene.html#fcaca9892b3d03f204751b610c0ea21b">getTotalNbShapes()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a55199c404c776475f71b0882465c754"></a><!-- doxytag: member="NxScene::getNbEffectors" ref="a55199c404c776475f71b0882465c754" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual NxU32 NxScene::getNbEffectors           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the number of effectors in the scene. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>the number of effectors in this scene.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#4aaff4a9db595e5b7dc25841819f5489">getNextEffector()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="926e59515115cac7df76c0acd6702698"></a><!-- doxytag: member="NxScene::getNbFluids" ref="926e59515115cac7df76c0acd6702698" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual NxU32 NxScene::getNbFluids           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the number of fluids belonging to the scene. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>the number of fluids.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#f76a22106785a6a4ad002faabf0a515a">getFluids()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="5b9feb79e058b88df2207fe453905f8e"></a><!-- doxytag: member="NxScene::getNbForceFieldLinearKernels" ref="5b9feb79e058b88df2207fe453905f8e" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual NxU32 NxScene::getNbForceFieldLinearKernels           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the number of linear kernels in the scene. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>number of linear kernels in the scene.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes [SW fallback] </li>
<li>PS3 : Yes </li>
<li>XB360: Yes </li>
</ul>
    </td>
  </tr>
</table>
<a class="anchor" name="7b569fb4fbad438542702d0783ae7bf6"></a><!-- doxytag: member="NxScene::getNbForceFields" ref="7b569fb4fbad438542702d0783ae7bf6" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual NxU32 NxScene::getNbForceFields           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the number of force fields in the scene. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The force field count.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes [SW fallback] </li>
<li>PS3 : Yes </li>
<li>XB360: Yes </li>
</ul>
    </td>
  </tr>
</table>
<a class="anchor" name="8fe4b89f28d8d3290ff3a12f1fdb6eff"></a><!-- doxytag: member="NxScene::getNbForceFieldShapeGroups" ref="8fe4b89f28d8d3290ff3a12f1fdb6eff" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual NxU32 NxScene::getNbForceFieldShapeGroups           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the number of shape groups in the scene. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The number of shape groups in the scene.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes [SW fallback] </li>
<li>PS3 : Yes </li>
<li>XB360: Yes </li>
</ul>
    </td>
  </tr>
</table>
<a class="anchor" name="6832193dab2b4f8c901a2230cb16eddf"></a><!-- doxytag: member="NxScene::getNbJoints" ref="6832193dab2b4f8c901a2230cb16eddf" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual NxU32 NxScene::getNbJoints           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the number of joints in the scene (excluding "dead" joints). Note that this includes compartments. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>the number of joints in this scene.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#76c118714d46f0800e23afd5842307c4">getNextJoint()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ec4836f6a7218e7a8a7354e0233398d9"></a><!-- doxytag: member="NxScene::getNbMaterials" ref="ec4836f6a7218e7a8a7354e0233398d9" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual NxU32 NxScene::getNbMaterials           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the number of materials in the scene. 
<p>
Note that the returned value is not related to material indices (NxMaterialIndex). Those may not be allocated continuously, and its values may be higher than <a class="el" href="classNxScene.html#ec4836f6a7218e7a8a7354e0233398d9">getNbMaterials()</a>. This will also include the default material which exists without having to be created.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The size of the internal material array.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#5a2a95c92eec6ae1cbe599f419dafbb5">getMaterialArray()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="14e4850a41771cc8edd18fd8eb55d485"></a><!-- doxytag: member="NxScene::getNbPairs" ref="14e4850a41771cc8edd18fd8eb55d485" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual NxU32 NxScene::getNbPairs           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the number of pairs for which pairFlags are defined. Note that this includes compartments. 
<p>
This includes actor and shape pairs.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The number of pairs.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__physics.html#g05983d9ea71be115e74f0a5d6a7559cc">NxContactPairFlag</a> <a class="el" href="classNxScene.html#d2795f18b35cd23e749535459b3e6a22">setShapePairFlags()</a> <a class="el" href="classNxScene.html#124e55cbcbfa0a5bcf6a8f19f36fd5fe">setActorPairFlags()</a> <a class="el" href="classNxScene.html#2bfb57ce590cc037c3e7c7df3f00c311">getPairFlagArray()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="d69c82e02d48ec94b417f88a3f921cbc"></a><!-- doxytag: member="NxScene::getNbSoftBodies" ref="d69c82e02d48ec94b417f88a3f921cbc" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual NxU32 NxScene::getNbSoftBodies           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Returns:</b></dt><dd>the number of soft bodies.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#04f3762c8ac1635a1a0a6a080fa42ae9">getSoftBodies()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="92bef655316556dfd2856dd998f54955"></a><!-- doxytag: member="NxScene::getNbStaticShapes" ref="92bef655316556dfd2856dd998f54955" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual NxU32 NxScene::getNbStaticShapes           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the number of static shapes in the scene. Note that this includes compartments and mirrored shapes in compartments. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The number of static shapes.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#20c0d3d5d2146f42c02b0e9dc0ccccba">getNbDynamicShapes()</a>; <p>
<a class="el" href="classNxScene.html#fcaca9892b3d03f204751b610c0ea21b">getTotalNbShapes()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="4aaff4a9db595e5b7dc25841819f5489"></a><!-- doxytag: member="NxScene::getNextEffector" ref="4aaff4a9db595e5b7dc25841819f5489" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxEffector.html">NxEffector</a>* NxScene::getNextEffector           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the next effector when iterating through the effectors in the scene. 
<p>
First call <a class="el" href="classNxScene.html#4dc6b5aa41bedad81992e96cebddb5d6">resetEffectorIterator()</a>, then call this method repeatedly until it returns zero. After a call to <a class="el" href="classNxScene.html#4dc6b5aa41bedad81992e96cebddb5d6">resetEffectorIterator()</a>, repeated calls to <a class="el" href="classNxScene.html#4aaff4a9db595e5b7dc25841819f5489">getNextEffector()</a> should return a sequence of <a class="el" href="classNxScene.html#a55199c404c776475f71b0882465c754">getNbEffectors()</a> effector pointers. The <a class="el" href="classNxScene.html#a55199c404c776475f71b0882465c754">getNbEffectors()</a>+1th call will return 0. Creating or deleting effectors resets the joint iterator.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#4dc6b5aa41bedad81992e96cebddb5d6">resetEffectorIterator</a>.</dd></dl>
<dl compact><dt><b>Returns:</b></dt><dd>The next effector in the iteration sequence. Or NULL when the end of the list of joints is reached.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#4dc6b5aa41bedad81992e96cebddb5d6">resetEffectorIterator()</a> <a class="el" href="classNxScene.html#a55199c404c776475f71b0882465c754">getNbEffectors()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="0004c1ba77f1b613139969637480dc1e"></a><!-- doxytag: member="NxScene::getNextForceFieldLinearKernel" ref="0004c1ba77f1b613139969637480dc1e" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxForceFieldLinearKernel.html">NxForceFieldLinearKernel</a>* NxScene::getNextForceFieldLinearKernel           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the next linear kernel when iterating. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="classNxForceFieldLinearKernel.html">NxForceFieldLinearKernel</a></dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes [SW fallback] </li>
<li>PS3 : Yes </li>
<li>XB360: Yes </li>
</ul>
    </td>
  </tr>
</table>
<a class="anchor" name="01e1183c4acbcd207bf3f4c4ecc879ed"></a><!-- doxytag: member="NxScene::getNextForceFieldShapeGroup" ref="01e1183c4acbcd207bf3f4c4ecc879ed" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxForceFieldShapeGroup.html">NxForceFieldShapeGroup</a>* NxScene::getNextForceFieldShapeGroup           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the next shape group when iterating. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="classNxForceFieldShapeGroup.html">NxForceFieldShapeGroup</a>. See <a class="el" href="classNxForceFieldShapeGroup.html">NxForceFieldShapeGroup</a></dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes [SW fallback] </li>
<li>PS3 : Yes </li>
<li>XB360: Yes </li>
</ul>
    </td>
  </tr>
</table>
<a class="anchor" name="76c118714d46f0800e23afd5842307c4"></a><!-- doxytag: member="NxScene::getNextJoint" ref="76c118714d46f0800e23afd5842307c4" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxJoint.html">NxJoint</a>* NxScene::getNextJoint           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the next joint when iterating. 
<p>
First call <a class="el" href="classNxScene.html#9f3d1e4408bf99f193cfee52a113cf83">resetJointIterator()</a>, then call this method repeatedly until it returns zero. After a call to <a class="el" href="classNxScene.html#9f3d1e4408bf99f193cfee52a113cf83">resetJointIterator()</a>, repeated calls to <a class="el" href="classNxScene.html#76c118714d46f0800e23afd5842307c4">getNextJoint()</a> should return a sequence of <a class="el" href="classNxScene.html#6832193dab2b4f8c901a2230cb16eddf">getNbJoints()</a> joint pointers. The <a class="el" href="classNxScene.html#6832193dab2b4f8c901a2230cb16eddf">getNbJoints()</a>+1th call will return 0. Creating or deleting joints resets the joint iterator.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#9f3d1e4408bf99f193cfee52a113cf83">resetJointIterator</a>.</dd></dl>
<dl compact><dt><b>Returns:</b></dt><dd>The next joint in the iteration sequence. Or NULL when the end of the list of joints is reached.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#9f3d1e4408bf99f193cfee52a113cf83">resetJointIterator()</a> <a class="el" href="classNxScene.html#6832193dab2b4f8c901a2230cb16eddf">getNbJoints()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="2bfb57ce590cc037c3e7c7df3f00c311"></a><!-- doxytag: member="NxScene::getPairFlagArray" ref="2bfb57ce590cc037c3e7c7df3f00c311" args="(NxPairFlag *userArray, NxU32 numPairs) const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual NxU32 NxScene::getPairFlagArray           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classNxPairFlag.html">NxPairFlag</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>userArray</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32&nbsp;</td>
          <td class="mdname" nowrap> <em>numPairs</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the pair flag data. 
<p>
The high bit of each 32 bit flag field denotes whether a pair is a shape or an actor pair. numPairs is the number of pairs the buffer can hold. The user is responsible for allocating and deallocating the buffer. Call getNbPairs() to check what the number of pairs should be.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>userArray</em>&nbsp;</td><td>Pointer to user array to receive pair flags. should be at least sizeof(NxPairFlag)*numPairs in size. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numPairs</em>&nbsp;</td><td>Number of pairs the user buffer can hold. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of pairs written to userArray.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : No </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__physics.html#g05983d9ea71be115e74f0a5d6a7559cc">NxContactPairFlag</a> <a class="el" href="classNxScene.html#d2795f18b35cd23e749535459b3e6a22">setShapePairFlags()</a> <a class="el" href="classNxScene.html#124e55cbcbfa0a5bcf6a8f19f36fd5fe">setActorPairFlags()</a> <a class="el" href="classNxScene.html#14e4850a41771cc8edd18fd8eb55d485">getNbPairs()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="480d328c211ab14decc60beb4d1ab425"></a><!-- doxytag: member="NxScene::getPhysicsSDK" ref="480d328c211ab14decc60beb4d1ab425" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxPhysicsSDK.html">NxPhysicsSDK</a>&amp; NxScene::getPhysicsSDK           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Call this method to retrieve the Physics SDK. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The physics SDK this scene is associated with.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxPhysicsSDK.html">NxPhysicsSDK</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="4c30521d2686d4054c432279aba65ed6"></a><!-- doxytag: member="NxScene::getShapePairFlags" ref="4c30521d2686d4054c432279aba65ed6" args="(NxShape &amp;shapeA, NxShape &amp;shapeB) const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual NxU32 NxScene::getShapePairFlags           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classNxShape.html">NxShape</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>shapeA</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classNxShape.html">NxShape</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>shapeB</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Similar to <a class="el" href="classNxScene.html#a6c8692f4c06a00658c2831e80608b7b">getActorPairFlags()</a>, but for a pair of shapes. 
<p>
The two shape references must not reference the same shape.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shapeA</em>&nbsp;</td><td>Shape A </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shapeB</em>&nbsp;</td><td>SHape B </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The shape pair flags.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#d2795f18b35cd23e749535459b3e6a22">setShapePairFlags()</a> <a class="el" href="group__physics.html#g05983d9ea71be115e74f0a5d6a7559cc">NxContactPairFlag</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="2763be68cdb1f4c9f0234e18becc2aab"></a><!-- doxytag: member="NxScene::getSimType" ref="2763be68cdb1f4c9f0234e18becc2aab" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="group__physics.html#g815e4f6dc14a7f753e9a276379f5b768">NxSimulationType</a> NxScene::getSimType           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the simulation type. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The simulation type. See <a class="el" href="group__physics.html#g815e4f6dc14a7f753e9a276379f5b768">NxSimulationType</a></dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : No </li>
<li>XB360: No</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxSceneDesc.html#01c546ca6dde53ac9733ff990dc9c41e">NxSceneDesc.simType</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="04f3762c8ac1635a1a0a6a080fa42ae9"></a><!-- doxytag: member="NxScene::getSoftBodies" ref="04f3762c8ac1635a1a0a6a080fa42ae9" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxSoftBody.html">NxSoftBody</a>** NxScene::getSoftBodies           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns an array of soft body objects. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>an array of soft body pointers with size <a class="el" href="classNxScene.html#d69c82e02d48ec94b417f88a3f921cbc">getNbSoftBodies()</a>.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#d69c82e02d48ec94b417f88a3f921cbc">getNbSoftBodies()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="8492f05f61d16f19b4e3f63209ad48e9"></a><!-- doxytag: member="NxScene::getSoftBodyUserNotify" ref="8492f05f61d16f19b4e3f63209ad48e9" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxSoftBodyUserNotify.html">NxSoftBodyUserNotify</a>* NxScene::getSoftBodyUserNotify           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the <a class="el" href="classNxSoftBodyUserNotify.html">NxSoftBodyUserNotify</a> pointer set with <a class="el" href="classNxScene.html#f0d657dc1b0a822ac5943cb548c6a60e">setSoftBodyUserNotify()</a>. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The current user softbody notify pointer. See <a class="el" href="classNxSoftBodyUserNotify.html">NxSoftBodyUserNotify</a>.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: No </li>
<li>PPU : No </li>
<li>PS3 : No </li>
<li>XB360: No</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxSoftBodyUserNotify.html">NxSoftBodyUserNotify</a> <a class="el" href="classNxScene.html#f0d657dc1b0a822ac5943cb548c6a60e">setSoftBodyUserNotify()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="d436aa74d8aa4d30951a823a2adb5194"></a><!-- doxytag: member="NxScene::getSolverBatchSize" ref="d436aa74d8aa4d30951a823a2adb5194" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual NxU32 NxScene::getSolverBatchSize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the number of actors required to spawn a separate rigid body solver thread. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Current number of actors required to spawn a separate rigid body solver thread.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Not applicable </li>
<li>PS3 : Not applicable </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxSceneDesc.html#5a6dcbdde5e31efaeafcddf272dba3e7">NxSceneDesc.solverBatchSize</a> <a class="el" href="classNxScene.html#7e9e9d9826bc43f2d0ac6a1d8181b92d">setSolverBatchSize()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a10e6e8e16467c8ba360bc46646e7769"></a><!-- doxytag: member="NxScene::getStats" ref="a10e6e8e16467c8ba360bc46646e7769" args="(NxSceneStats &amp;stats) const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::getStats           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classNxSceneStats.html">NxSceneStats</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>stats</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Call this method to retrieve statistics about the current scene. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>stats</em>&nbsp;</td><td>Used to retrieve statistics for the scene. See <a class="el" href="classNxSceneStats.html">NxSceneStats</a>.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : No </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxSceneStats.html">NxSceneStats</a> <a class="el" href="classNxScene.html#45595724e4b7e4c7a0f6c41a704d11f5">getLimits()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="b33d8be0787f4fb6d5d927e7f9a2053d"></a><!-- doxytag: member="NxScene::getStats2" ref="b33d8be0787f4fb6d5d927e7f9a2053d" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual const <a class="el" href="classNxSceneStats2.html">NxSceneStats2</a>* NxScene::getStats2           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Call this method to retrieve extended statistics about the current scene. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Used to retrieve statistics for the scene. See <a class="el" href="classNxSceneStats2.html">NxSceneStats2</a>. Note that this is a pointer to data that changes with each simulation call; the relevant data must be copied in order to save it.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes </li>
</ul>
    </td>
  </tr>
</table>
<a class="anchor" name="af4bb8e49b7e8b85c3b842e7cc3c96b0"></a><!-- doxytag: member="NxScene::getTiming" ref="af4bb8e49b7e8b85c3b842e7cc3c96b0" args="(NxReal &amp;maxTimestep, NxU32 &amp;maxIter, NxTimeStepMethod &amp;method, NxU32 *numSubSteps=NULL) const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::getTiming           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>maxTimestep</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32 &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>maxIter</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__physics.html#gb0121e5b18e9aab4ef5619d3749e5a6e">NxTimeStepMethod</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>method</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32 *&nbsp;</td>
          <td class="mdname" nowrap> <em>numSubSteps</em> = <code>NULL</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves simulation timing parameters. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxTimestep</em>&nbsp;</td><td>Maximum size to divide a substep into. <b>Range:</b> (0,inf) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxIter</em>&nbsp;</td><td>Maximum number of iterations to divide a timestep into. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>method</em>&nbsp;</td><td>Method to use for timestep (either variable time step or fixed). See <a class="el" href="group__physics.html#gb0121e5b18e9aab4ef5619d3749e5a6e">NxTimeStepMethod</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numSubSteps</em>&nbsp;</td><td>The number of sub steps the time step will be divided into.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#3f78154dfd007fbf8b6f74884f94657d">setTiming()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="fcaca9892b3d03f204751b610c0ea21b"></a><!-- doxytag: member="NxScene::getTotalNbShapes" ref="fcaca9892b3d03f204751b610c0ea21b" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual NxU32 NxScene::getTotalNbShapes           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the total number of shapes in the scene, including compounds' sub-shapes. Note that this also includes compartments and mirrored shapes in compartments. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>the total number of shapes.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#92bef655316556dfd2856dd998f54955">getNbStaticShapes()</a> <p>
<a class="el" href="classNxScene.html#20c0d3d5d2146f42c02b0e9dc0ccccba">getNbDynamicShapes()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="6cf0420a2cbf0873bf5b65b5f1ad1d92"></a><!-- doxytag: member="NxScene::getUserActorPairFiltering" ref="6cf0420a2cbf0873bf5b65b5f1ad1d92" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxUserActorPairFiltering.html">NxUserActorPairFiltering</a>* NxScene::getUserActorPairFiltering           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the custom actor pair filtering in use for this scene. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Filtering class that defines the callback used for custom pair filtering.</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxUserActorPairFiltering.html">NxUserActorPairFiltering</a> <a class="el" href="classNxScene.html#5b73eede587ac90cbebf8561de8421a2">setUserActorPairFiltering</a> <a class="el" href="classNxActor.html#a579d708b79eb4b52d3a1ced14659282">NxActor::resetUserActorPairFiltering</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="3a1ad601f20dec9e733ac58c5871e208"></a><!-- doxytag: member="NxScene::getUserContactModify" ref="3a1ad601f20dec9e733ac58c5871e208" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxUserContactModify.html">NxUserContactModify</a>* NxScene::getUserContactModify           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the <a class="el" href="classNxUserContactModify.html">NxUserContactModify</a> pointer set with <a class="el" href="classNxScene.html#6731ff076b2594d44d14b734ed8c660e">setUserContactModify()</a>. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The current user contact modify callback pointer. See <a class="el" href="classNxUserContactModify.html">NxUserContactModify</a>.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxUserContactModify.html">NxUserContactModify</a> <a class="el" href="classNxScene.html#6731ff076b2594d44d14b734ed8c660e">setUserContactModify()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="4b67e9defeb1d26f63ff02f243d7f340"></a><!-- doxytag: member="NxScene::getUserContactReport" ref="4b67e9defeb1d26f63ff02f243d7f340" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxUserContactReport.html">NxUserContactReport</a>* NxScene::getUserContactReport           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the callback pointer set with <a class="el" href="classNxScene.html#9d9b93fb3217760b45280735a9e5a1a3">setUserContactReport()</a>. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The current user contact reporter. See <a class="el" href="classNxUserContactReport.html">NxUserContactReport</a>.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxUserContactReport.html">NxUserContactReport</a> <a class="el" href="classNxScene.html#9d9b93fb3217760b45280735a9e5a1a3">setUserContactReport()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="8a7f769f5cf233f440fb12dcc5000020"></a><!-- doxytag: member="NxScene::getUserNotify" ref="8a7f769f5cf233f440fb12dcc5000020" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxUserNotify.html">NxUserNotify</a>* NxScene::getUserNotify           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the userNotify pointer set with <a class="el" href="classNxScene.html#c0b9531f514d0219651a507ae197a0a2">setUserNotify()</a>. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The current user notify pointer. See <a class="el" href="classNxUserNotify.html">NxUserNotify</a>.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxUserNotify.html">NxUserNotify</a> <a class="el" href="classNxScene.html#c0b9531f514d0219651a507ae197a0a2">setUserNotify()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="f343081b5d86e7791d7dfe480b975ed8"></a><!-- doxytag: member="NxScene::getUserTriggerReport" ref="f343081b5d86e7791d7dfe480b975ed8" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxUserTriggerReport.html">NxUserTriggerReport</a>* NxScene::getUserTriggerReport           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the callback pointer set with <a class="el" href="classNxScene.html#d0e23eeeef568ff2fd6b5b538c2ce3c7">setUserTriggerReport()</a>. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The current user trigger pointer. See <a class="el" href="classNxUserTriggerReport.html">NxUserTriggerReport</a>.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxUserTriggerReport.html">NxUserTriggerReport</a> <a class="el" href="classNxScene.html#d0e23eeeef568ff2fd6b5b538c2ce3c7">setUserTriggerReport()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ecb720c8a69a42282b196c8844e17cbf"></a><!-- doxytag: member="NxScene::isWritable" ref="ecb720c8a69a42282b196c8844e17cbf" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool NxScene::isWritable           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This is a query to see if the scene is in a state that allows the application to update scene state. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>True if the scene can be written by the application.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes </li>
</ul>
    </td>
  </tr>
</table>
<a class="anchor" name="8fd2f63d309769b8e0770e322c4c67bb"></a><!-- doxytag: member="NxScene::linearCapsuleSweep" ref="8fd2f63d309769b8e0770e322c4c67bb" args="(const NxCapsule &amp;worldCapsule, const NxVec3 &amp;motion, NxU32 flags, void *userData, NxU32 nbShapes, NxSweepQueryHit *shapes, NxUserEntityReport&lt; NxSweepQueryHit &gt; *callback, NxU32 activeGroups=0xffffffff, const NxGroupsMask *groupsMask=NULL)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual NxU32 NxScene::linearCapsuleSweep           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxCapsule.html">NxCapsule</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>worldCapsule</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>motion</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32&nbsp;</td>
          <td class="mdname" nowrap> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>userData</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32&nbsp;</td>
          <td class="mdname" nowrap> <em>nbShapes</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structNxSweepQueryHit.html">NxSweepQueryHit</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>shapes</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classNxUserEntityReport.html">NxUserEntityReport</a>&lt; <a class="el" href="structNxSweepQueryHit.html">NxSweepQueryHit</a> &gt; *&nbsp;</td>
          <td class="mdname" nowrap> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32&nbsp;</td>
          <td class="mdname" nowrap> <em>activeGroups</em> = <code>0xffffffff</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>groupsMask</em> = <code>NULL</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Performs a linear sweep through space with an oriented capsule. 
<p>
The function a capsule through space and reports any shapes in the scene which it intersects. Apart from the number of shapes intersected in this way, and the shapes intersected, information on the closest intersection is put in an <a class="el" href="structNxSweepQueryHit.html">NxSweepQueryHit</a> structure which can be processed in the callback function if provided. Which shapes in the scene are regarded is specified through the flags parameter.<p>
<dl compact><dt><b>Note:</b></dt><dd>Because the SDK double buffers shape state, a shape will not be updated until a simulation step is taken. For example the result of setting the global pose is not immediatly visible.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>worldCapsule</em>&nbsp;</td><td>The oriented capsule (<a class="el" href="classNxCapsule.html">NxCapsule</a> object) that is to be swept </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>motion</em>&nbsp;</td><td>Length and direction of the sweep </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags controlling the mode of the sweep </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>userData</em>&nbsp;</td><td>User data to impart to the returned data struct </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nbShapes</em>&nbsp;</td><td>Maximum number of shapes to report <b>Range:</b> [1,NX_MAX_U32] </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>shapes</em>&nbsp;</td><td>Pointer to buffer for reported shapes </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>Callback function invoked on the closest hit (if any) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>activeGroups</em>&nbsp;</td><td>Mask used to filter shape objects. See <a class="el" href="classNxShape.html#03de2c71a97d1f3b1b30abc7bdc208d1">NxShape::setGroup</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>groupsMask</em>&nbsp;</td><td>Alternative mask used to filter shapes. See <a class="el" href="classNxShape.html#a8eca1891f54640eabf40da27476c5d2">NxShape::setGroupsMask</a></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of hits reported.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxCapsule.html">NxCapsule</a> <a class="el" href="classNxShape.html">NxShape</a> <a class="el" href="structNxSweepQueryHit.html">NxSweepQueryHit</a> <a class="el" href="group__physics.html#g3b13edbb56b767ba6fe057052f37ec0d">NxSweepFlags</a> <a class="el" href="classNxUserEntityReport.html">NxUserEntityReport</a> <a class="el" href="classNxScene.html">NxScene</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="79146b5e21728905459bcce6db951028"></a><!-- doxytag: member="NxScene::linearOBBSweep" ref="79146b5e21728905459bcce6db951028" args="(const NxBox &amp;worldBox, const NxVec3 &amp;motion, NxU32 flags, void *userData, NxU32 nbShapes, NxSweepQueryHit *shapes, NxUserEntityReport&lt; NxSweepQueryHit &gt; *callback, NxU32 activeGroups=0xffffffff, const NxGroupsMask *groupsMask=NULL)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual NxU32 NxScene::linearOBBSweep           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxBox.html">NxBox</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>worldBox</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>motion</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32&nbsp;</td>
          <td class="mdname" nowrap> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>userData</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32&nbsp;</td>
          <td class="mdname" nowrap> <em>nbShapes</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structNxSweepQueryHit.html">NxSweepQueryHit</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>shapes</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classNxUserEntityReport.html">NxUserEntityReport</a>&lt; <a class="el" href="structNxSweepQueryHit.html">NxSweepQueryHit</a> &gt; *&nbsp;</td>
          <td class="mdname" nowrap> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32&nbsp;</td>
          <td class="mdname" nowrap> <em>activeGroups</em> = <code>0xffffffff</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>groupsMask</em> = <code>NULL</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Performs a linear sweep through space with an oriented box. 
<p>
The function sweeps an oriented box through space and reports any shapes in the scene which it intersects. Apart from the number of shapes intersected in this way, and the shapes intersected, information on the closest intersection is put in an <a class="el" href="structNxSweepQueryHit.html">NxSweepQueryHit</a> structure which can be processed in the callback function if provided. Which shapes in the scene are regarded is specified through the flags parameter.<p>
<dl compact><dt><b>Note:</b></dt><dd>Because the SDK double buffers shape state, a shape will not be updated until a simulation step is taken. For example the result of setting the global pose is not immediatly visible.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>worldBox</em>&nbsp;</td><td>The oriented box (<a class="el" href="classNxBox.html">NxBox</a> object) that is to be swept </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>motion</em>&nbsp;</td><td>Length and direction of the sweep </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags controlling the mode of the sweep </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>userData</em>&nbsp;</td><td>User data to impart to the returned data struct </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nbShapes</em>&nbsp;</td><td>Maximum number of shapes to report <b>Range:</b> [1,NX_MAX_U32] </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>shapes</em>&nbsp;</td><td>Pointer to buffer for reported shapes </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>Callback function invoked on the closest hit (if any) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>activeGroups</em>&nbsp;</td><td>Mask used to filter shape objects. See <a class="el" href="classNxShape.html#03de2c71a97d1f3b1b30abc7bdc208d1">NxShape::setGroup</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>groupsMask</em>&nbsp;</td><td>Alternative mask used to filter shapes. See <a class="el" href="classNxShape.html#a8eca1891f54640eabf40da27476c5d2">NxShape::setGroupsMask</a></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of hits reported.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxBox.html">NxBox</a> <a class="el" href="classNxShape.html">NxShape</a> <a class="el" href="structNxSweepQueryHit.html">NxSweepQueryHit</a> <a class="el" href="group__physics.html#g3b13edbb56b767ba6fe057052f37ec0d">NxSweepFlags</a> <a class="el" href="classNxUserEntityReport.html">NxUserEntityReport</a> <a class="el" href="classNxScene.html">NxScene</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="f981d709d15a827f5aca98b14e77400e"></a><!-- doxytag: member="NxScene::lockQueries" ref="f981d709d15a827f5aca98b14e77400e" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::lockQueries           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Blocks all parallel raycast/overlap queries. 
<p>
This method should be used to lock raycasts from other threads while the SDK state is being updated in a way which will affect raycasting/overlap queries.<p>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : No </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#b42c1c7b5cdd7fd3c6d506607e08705c">unlockQueries()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="c67f8f88acd1110063fe60e73ba673f6"></a><!-- doxytag: member="NxScene::overlapAABBShapes" ref="c67f8f88acd1110063fe60e73ba673f6" args="(const NxBounds3 &amp;worldBounds, NxShapesType shapeType, NxU32 nbShapes, NxShape **shapes, NxUserEntityReport&lt; NxShape * &gt; *callback, NxU32 activeGroups=0xffffffff, const NxGroupsMask *groupsMask=NULL, bool accurateCollision=false)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual NxU32 NxScene::overlapAABBShapes           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxBounds3.html">NxBounds3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>worldBounds</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>shapeType</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32&nbsp;</td>
          <td class="mdname" nowrap> <em>nbShapes</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classNxShape.html">NxShape</a> **&nbsp;</td>
          <td class="mdname" nowrap> <em>shapes</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classNxUserEntityReport.html">NxUserEntityReport</a>&lt; <a class="el" href="classNxShape.html">NxShape</a> * &gt; *&nbsp;</td>
          <td class="mdname" nowrap> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32&nbsp;</td>
          <td class="mdname" nowrap> <em>activeGroups</em> = <code>0xffffffff</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>groupsMask</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>accurateCollision</em> = <code>false</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the set of shapes overlapped by the world-space AABB. 
<p>
You can test against static and/or dynamic objects by adjusting 'shapeType'. Shapes are written to the static array 'shapes', which should be big enough to hold 'nbShapes'. An alternative is to use the <a class="el" href="classNxUserEntityReport.html">NxUserEntityReport</a> callback mechanism.<p>
The function returns the total number of collided shapes.<p>
<dl compact><dt><b>Note:</b></dt><dd>Because the SDK double buffers shape state, a shape will not be updated until a simulation step is taken. For example the result of setting the global pose is not immediatly visible.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>worldBounds</em>&nbsp;</td><td>Axis Aligned Bounding Box in world space. <b>Range:</b> See <a class="el" href="classNxBounds3.html">NxBounds3</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shapeType</em>&nbsp;</td><td>Choose if to intersect with static, dynamic or both types of shape. See <a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nbShapes</em>&nbsp;</td><td>Number of shapes that the buffer shapes can hold. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>shapes</em>&nbsp;</td><td>Buffer to store intersecting shapes. Should be at least sizeof(NxShape *) * nbShapes. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>Alternative method to retrieve overlapping shapes. Is called with sets of overlapping shapes. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>activeGroups</em>&nbsp;</td><td>Mask used to filter shape objects. See <a class="el" href="classNxShape.html#03de2c71a97d1f3b1b30abc7bdc208d1">NxShape::setGroup</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>groupsMask</em>&nbsp;</td><td>Alternative mask used to filter shapes. See <a class="el" href="classNxShape.html#a8eca1891f54640eabf40da27476c5d2">NxShape::setGroupsMask</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>accurateCollision</em>&nbsp;</td><td>True to test the AABB against the actual shapes, false to test against the AABBs only.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the total number of collided shapes.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxBounds3.html">NxBounds3</a> <a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a> <a class="el" href="classNxScene.html#c67f8f88acd1110063fe60e73ba673f6">overlapAABBShapes</a> <a class="el" href="classNxUserEntityReport.html">NxUserEntityReport</a> <a class="el" href="classNxShape.html#fe008f15bebec6527d27a3fea4b19c1d">NxShape.checkOverlapAABB()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="0c0a6ed26aa6e349aad0f8e4d691e6ba"></a><!-- doxytag: member="NxScene::overlapCapsuleShapes" ref="0c0a6ed26aa6e349aad0f8e4d691e6ba" args="(const NxCapsule &amp;worldCapsule, NxShapesType shapeType, NxU32 nbShapes, NxShape **shapes, NxUserEntityReport&lt; NxShape * &gt; *callback, NxU32 activeGroups=0xffffffff, const NxGroupsMask *groupsMask=NULL, bool accurateCollision=false)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual NxU32 NxScene::overlapCapsuleShapes           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxCapsule.html">NxCapsule</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>worldCapsule</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>shapeType</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32&nbsp;</td>
          <td class="mdname" nowrap> <em>nbShapes</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classNxShape.html">NxShape</a> **&nbsp;</td>
          <td class="mdname" nowrap> <em>shapes</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classNxUserEntityReport.html">NxUserEntityReport</a>&lt; <a class="el" href="classNxShape.html">NxShape</a> * &gt; *&nbsp;</td>
          <td class="mdname" nowrap> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32&nbsp;</td>
          <td class="mdname" nowrap> <em>activeGroups</em> = <code>0xffffffff</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>groupsMask</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>accurateCollision</em> = <code>false</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the set of shapes overlapped by the world-space capsule. 
<p>
You can test against static and/or dynamic objects by adjusting 'shapeType'. Shapes are written to the static array 'shapes', which should be big enough to hold 'nbShapes'. An alternative is to use the <a class="el" href="classNxUserEntityReport.html">NxUserEntityReport</a> callback mechanism.<p>
The function returns the total number of collided shapes.<p>
<dl compact><dt><b>Note:</b></dt><dd>Because the SDK double buffers shape state, a shape will not be updated until a simulation step is taken. For example the result of setting the global pose is not immediatly visible.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>worldCapsule</em>&nbsp;</td><td>capsule in world space. <b>Range:</b> See <a class="el" href="classNxCapsule.html">NxCapsule</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shapeType</em>&nbsp;</td><td>Choose if to intersect with static, dynamic or both types of shape. See <a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nbShapes</em>&nbsp;</td><td>Number of shapes that the buffer shapes can hold. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>shapes</em>&nbsp;</td><td>Buffer to store intersecting shapes. Should be at least sizeof(NxShape *) * nbShapes. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>Alternative method to retrieve overlapping shapes. Is called with sets of overlapping shapes. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>activeGroups</em>&nbsp;</td><td>Mask used to filter shape objects. See <a class="el" href="classNxShape.html#03de2c71a97d1f3b1b30abc7bdc208d1">NxShape::setGroup</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>groupsMask</em>&nbsp;</td><td>Alternative mask used to filter shapes. See <a class="el" href="classNxShape.html#a8eca1891f54640eabf40da27476c5d2">NxShape::setGroupsMask</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>accurateCollision</em>&nbsp;</td><td>True to test the capsule against the actual shapes, false to test against the AABBs only.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the total number of collided shapes.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxBounds3.html">NxBounds3</a> <a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a> <a class="el" href="classNxScene.html#0c0a6ed26aa6e349aad0f8e4d691e6ba">overlapCapsuleShapes</a> <a class="el" href="classNxUserEntityReport.html">NxUserEntityReport</a> <a class="el" href="classNxShape.html#e55779cbbf15d179f1bdc06a2bce6153">NxShape.checkOverlapCapsule()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="8d27be6eba87cfc6ae34905488e7e893"></a><!-- doxytag: member="NxScene::overlapOBBShapes" ref="8d27be6eba87cfc6ae34905488e7e893" args="(const NxBox &amp;worldBox, NxShapesType shapeType, NxU32 nbShapes, NxShape **shapes, NxUserEntityReport&lt; NxShape * &gt; *callback, NxU32 activeGroups=0xffffffff, const NxGroupsMask *groupsMask=NULL, bool accurateCollision=false)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual NxU32 NxScene::overlapOBBShapes           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxBox.html">NxBox</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>worldBox</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>shapeType</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32&nbsp;</td>
          <td class="mdname" nowrap> <em>nbShapes</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classNxShape.html">NxShape</a> **&nbsp;</td>
          <td class="mdname" nowrap> <em>shapes</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classNxUserEntityReport.html">NxUserEntityReport</a>&lt; <a class="el" href="classNxShape.html">NxShape</a> * &gt; *&nbsp;</td>
          <td class="mdname" nowrap> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32&nbsp;</td>
          <td class="mdname" nowrap> <em>activeGroups</em> = <code>0xffffffff</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>groupsMask</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>accurateCollision</em> = <code>false</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the set of shapes overlapped by the world-space OBB. 
<p>
You can test against static and/or dynamic objects by adjusting 'shapeType'. Shapes are written to the static array 'shapes', which should be big enough to hold 'nbShapes'. An alternative is to use the <a class="el" href="classNxUserEntityReport.html">NxUserEntityReport</a> callback mechanism.<p>
The function returns the total number of collided shapes.<p>
<dl compact><dt><b>Note:</b></dt><dd>Because the SDK double buffers shape state, a shape will not be updated until a simulation step is taken. For example the result of setting the global pose is not immediatly visible.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>worldBox</em>&nbsp;</td><td>Oriented Bounding Box in world space. <b>Range:</b> See <a class="el" href="classNxBox.html">NxBox</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shapeType</em>&nbsp;</td><td>Choose if to intersect with static, dynamic or both types of shape. See <a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nbShapes</em>&nbsp;</td><td>Number of shapes that the buffer shapes can hold. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>shapes</em>&nbsp;</td><td>Buffer to store intersecting shapes. Should be at least sizeof(NxShape *) * nbShapes. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>Alternative method to retrieve overlapping shapes. Is called with sets of overlapping shapes. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>activeGroups</em>&nbsp;</td><td>Mask used to filter shape objects. See <a class="el" href="classNxShape.html#03de2c71a97d1f3b1b30abc7bdc208d1">NxShape::setGroup</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>groupsMask</em>&nbsp;</td><td>Alternative mask used to filter shapes. See <a class="el" href="classNxShape.html#a8eca1891f54640eabf40da27476c5d2">NxShape::setGroupsMask</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>accurateCollision</em>&nbsp;</td><td>True to test the OBB against the actual shapes, false to test against the AABBs only.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the total number of collided shapes.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxBounds3.html">NxBounds3</a> <a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a> <a class="el" href="classNxScene.html#8d27be6eba87cfc6ae34905488e7e893">overlapOBBShapes</a> <a class="el" href="classNxUserEntityReport.html">NxUserEntityReport</a> <a class="el" href="classNxShape.html#738bbb4046686a6f48b889d43210f29d">NxShape.checkOverlapOBB()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="982c1bbc89e5fa15f45d9b74570d0488"></a><!-- doxytag: member="NxScene::overlapSphereShapes" ref="982c1bbc89e5fa15f45d9b74570d0488" args="(const NxSphere &amp;worldSphere, NxShapesType shapeType, NxU32 nbShapes, NxShape **shapes, NxUserEntityReport&lt; NxShape * &gt; *callback, NxU32 activeGroups=0xffffffff, const NxGroupsMask *groupsMask=NULL, bool accurateCollision=false)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual NxU32 NxScene::overlapSphereShapes           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxSphere.html">NxSphere</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>worldSphere</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>shapeType</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32&nbsp;</td>
          <td class="mdname" nowrap> <em>nbShapes</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classNxShape.html">NxShape</a> **&nbsp;</td>
          <td class="mdname" nowrap> <em>shapes</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classNxUserEntityReport.html">NxUserEntityReport</a>&lt; <a class="el" href="classNxShape.html">NxShape</a> * &gt; *&nbsp;</td>
          <td class="mdname" nowrap> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32&nbsp;</td>
          <td class="mdname" nowrap> <em>activeGroups</em> = <code>0xffffffff</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>groupsMask</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>accurateCollision</em> = <code>false</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the set of shapes overlapped by the world-space sphere. 
<p>
You can test against static and/or dynamic objects by adjusting 'shapeType'. Shapes are written to the static array 'shapes', which should be big enough to hold 'nbShapes'. An alternative is to use the <a class="el" href="classNxUserEntityReport.html">NxUserEntityReport</a> callback mechanism.<p>
The function returns the total number of collided shapes.<p>
<dl compact><dt><b>Note:</b></dt><dd>Because the SDK double buffers shape state, a shape will not be updated until a simulation step is taken. For example the result of setting the global pose is not immediatly visible.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>worldSphere</em>&nbsp;</td><td>Sphere description in world space. <b>Range:</b> See <a class="el" href="classNxSphere.html">NxSphere</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shapeType</em>&nbsp;</td><td>Choose if to intersect with static, dynamic or both types of shape. See <a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nbShapes</em>&nbsp;</td><td>Number of shapes that the buffer shapes can hold. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>shapes</em>&nbsp;</td><td>Buffer to store intersecting shapes. Should be at least sizeof(NxShape *) * nbShapes. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>Alternative method to retrieve overlapping shapes. Is called with sets of overlapping shapes. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>activeGroups</em>&nbsp;</td><td>Mask used to filter shape objects. See <a class="el" href="classNxShape.html#03de2c71a97d1f3b1b30abc7bdc208d1">NxShape::setGroup</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>groupsMask</em>&nbsp;</td><td>Alternative mask used to filter shapes. See <a class="el" href="classNxShape.html#a8eca1891f54640eabf40da27476c5d2">NxShape::setGroupsMask</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>accurateCollision</em>&nbsp;</td><td>True to test the sphere against the actual shapes, false to test against the AABBs only.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the total number of collided shapes.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxSphere.html">NxSphere</a> <a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a> <a class="el" href="classNxScene.html#c67f8f88acd1110063fe60e73ba673f6">overlapAABBShapes</a> <a class="el" href="classNxUserEntityReport.html">NxUserEntityReport</a> <a class="el" href="classNxShape.html#cf310bdbc3ede3eb80a5ac2366b09ae5">NxShape.checkOverlapSphere()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="dfda8a6ede9094e911684f4135793a41"></a><!-- doxytag: member="NxScene::pollForBackgroundWork" ref="dfda8a6ede9094e911684f4135793a41" args="(NxThreadWait waitType)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="group__physics.html#g70ce4c9351d5599a0c9426942d8f3a0d">NxThreadPollResult</a> NxScene::pollForBackgroundWork           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__physics.html#g01bb907296af882b2e2c6694273d7775">NxThreadWait</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>waitType</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Polls for background work. 
<p>
Returns NX_THREAD_NOWORK if no work is available, NX_THREAD_MOREWORK if there may be work remaining to execute or NX_THREAD_SHUTDOWN if the thread was released by <a class="el" href="classNxScene.html#941e68977c4fc3d971430b721ca3fc51">shutdownWorkerThreads()</a>.<p>
The function waits for work to execute according the the waitType argument.<p>
The NX_WAIT_SIMULATION_END does not make sense for background tasks, as they are not associated with a particular simulation step.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>waitType</em>&nbsp;</td><td>Specifies how long the function should wait for work. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Informs the user about the reason for returning.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : No </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#244018b935af9bcd373f3d452965d18e">resetPollForWork()</a> <a class="el" href="group__physics.html#g01bb907296af882b2e2c6694273d7775">NxThreadWait</a> <a class="el" href="group__physics.html#g70ce4c9351d5599a0c9426942d8f3a0d">NxThreadPollResult</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="02a7bb5a100770f92e70de2685fb0eee"></a><!-- doxytag: member="NxScene::pollForWork" ref="02a7bb5a100770f92e70de2685fb0eee" args="(NxThreadWait waitType)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="group__physics.html#g70ce4c9351d5599a0c9426942d8f3a0d">NxThreadPollResult</a> NxScene::pollForWork           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__physics.html#g01bb907296af882b2e2c6694273d7775">NxThreadWait</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>waitType</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Poll for work to execute on the current thread. 
<p>
Returns NX_THREAD_SIMULATION_END if the simulation step ended, NX_THREAD_NOWORK if no work is available, NX_THREAD_MOREWORK if there may be work remaining to execute.<p>
The function waits for work to execute according the the waitType argument.<p>
The function will continue to return NX_THREAD_SIMULATION_END until the <a class="el" href="classNxScene.html#244018b935af9bcd373f3d452965d18e">resetPollForWork()</a> method is called.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>waitType</em>&nbsp;</td><td>Specifies how long the function should wait for work. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Informs the user about the reason for returning.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : No </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#244018b935af9bcd373f3d452965d18e">resetPollForWork()</a> <a class="el" href="group__physics.html#g01bb907296af882b2e2c6694273d7775">NxThreadWait</a> <a class="el" href="group__physics.html#g70ce4c9351d5599a0c9426942d8f3a0d">NxThreadPollResult</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="3134810c29120974a7a316f8ea07e622"></a><!-- doxytag: member="NxScene::raycastAllBounds" ref="3134810c29120974a7a316f8ea07e622" args="(const NxRay &amp;worldRay, NxUserRaycastReport &amp;report, NxShapesType shapesType, NxU32 groups=0xffffffff, NxReal maxDist=NX_MAX_F32, NxU32 hintFlags=0xffffffff, const NxGroupsMask *groupsMask=NULL) const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual NxU32 NxScene::raycastAllBounds           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxRay.html">NxRay</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>worldRay</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classNxUserRaycastReport.html">NxUserRaycastReport</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>report</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>shapesType</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32&nbsp;</td>
          <td class="mdname" nowrap> <em>groups</em> = <code>0xffffffff</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>maxDist</em> = <code>NX_MAX_F32</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32&nbsp;</td>
          <td class="mdname" nowrap> <em>hintFlags</em> = <code>0xffffffff</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>groupsMask</em> = <code>NULL</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calls the report's hitCallback() method for all the axis aligned bounding boxes enclosing shapes of type ShapeType intersected by the ray. 
<p>
The point of impact is provided as a parameter to hitCallback(). hintFlags is a combination of <a class="el" href="group__physics.html#ge02ef34f964753cb7f022818a10962e8">NxRaycastBit</a> flags. Returns the number of shapes hit.<p>
<dl compact><dt><b>Note:</b></dt><dd>Make certain that the direction vector of <a class="el" href="classNxRay.html">NxRay</a> is normalized.<p>
Because the SDK double buffers shape state, a shape will not be updated until a simulation step is taken. For example the result of setting the global pose is not immediatly visible.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>worldRay</em>&nbsp;</td><td>The ray to cast in the global frame. <b>Range:</b> See <a class="el" href="classNxRay.html">NxRay</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>report</em>&nbsp;</td><td>User callback, to be called when an intersection is encountered. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shapesType</em>&nbsp;</td><td>Choose if to raycast against static, dynamic or both types of shape. See <a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>groups</em>&nbsp;</td><td>Mask used to filter shape objects. See <a class="el" href="classNxShape.html#03de2c71a97d1f3b1b30abc7bdc208d1">NxShape::setGroup</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxDist</em>&nbsp;</td><td>Max distance to check along the ray for intersecting objects. <b>Range:</b> (0,inf) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hintFlags</em>&nbsp;</td><td>Allows the user to specify which field of <a class="el" href="structNxRaycastHit.html">NxRaycastHit</a> they are interested in. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>groupsMask</em>&nbsp;</td><td>Alternative mask used to filter shapes. See <a class="el" href="classNxShape.html#a8eca1891f54640eabf40da27476c5d2">NxShape::setGroupsMask</a></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the number of shapes hit.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#564174af1cc7ce3c313e2de4bbdc45a7">raycastAnyBounds()</a> <a class="el" href="classNxScene.html#21fdc86f5fcfe33d7b4f6c802c7c3f94">raycastAllShapes()</a> <a class="el" href="classNxRay.html">NxRay</a> <a class="el" href="classNxUserRaycastReport.html">NxUserRaycastReport</a> <a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a> <a class="el" href="classNxShape.html#03de2c71a97d1f3b1b30abc7bdc208d1">NxShape.setGroup()</a> <a class="el" href="structNxRaycastHit.html">NxRaycastHit</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="21fdc86f5fcfe33d7b4f6c802c7c3f94"></a><!-- doxytag: member="NxScene::raycastAllShapes" ref="21fdc86f5fcfe33d7b4f6c802c7c3f94" args="(const NxRay &amp;worldRay, NxUserRaycastReport &amp;report, NxShapesType shapesType, NxU32 groups=0xffffffff, NxReal maxDist=NX_MAX_F32, NxU32 hintFlags=0xffffffff, const NxGroupsMask *groupsMask=NULL) const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual NxU32 NxScene::raycastAllShapes           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxRay.html">NxRay</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>worldRay</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classNxUserRaycastReport.html">NxUserRaycastReport</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>report</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>shapesType</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32&nbsp;</td>
          <td class="mdname" nowrap> <em>groups</em> = <code>0xffffffff</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>maxDist</em> = <code>NX_MAX_F32</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32&nbsp;</td>
          <td class="mdname" nowrap> <em>hintFlags</em> = <code>0xffffffff</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>groupsMask</em> = <code>NULL</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calls the report's hitCallback() method for all the shapes of type ShapeType intersected by the ray. 
<p>
hintFlags is a combination of <a class="el" href="group__physics.html#ge02ef34f964753cb7f022818a10962e8">NxRaycastBit</a> flags. Returns the number of shapes hit. The point of impact is provided as a parameter to hitCallback().<p>
<dl compact><dt><b>Note:</b></dt><dd>Make certain that the direction vector of <a class="el" href="classNxRay.html">NxRay</a> is normalized.<p>
Because the SDK double buffers shape state, a shape will not be updated until a simulation step is taken. For example the result of setting the global pose is not immediatly visible.</dd></dl>
<h3>Example</h3>
<p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>myRaycastReport : <span class="keyword">public</span> <a class="code" href="classNxUserRaycastReport.html">NxUserRaycastReport</a>
{
    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> onHit(<span class="keyword">const</span> <a class="code" href="structNxRaycastHit.html">NxRaycastHit</a>&amp; hit)
    {
        <a class="code" href="classNxActor.html">NxActor</a> *hitActor = hit.<a class="code" href="structNxRaycastHit.html#9f92c290de92b69a70e87e80ed31e3f6">shape</a>-&gt;<a class="code" href="classNxShape.html#6bb04854463ef8329b1742af9bd9a1d8">getActor</a>();

        <span class="comment">//The ray hit actor, do something...</span>

        <span class="keywordflow">return</span> <span class="keyword">true</span>;
    }
}gMyReport;

...

NxRay worldRay;
worldRay.dir = <a class="code" href="classNxVec3.html">NxVec3</a>(0.0f, 0.0f, 1.0f);
worldRay.orig = <a class="code" href="classNxVec3.html">NxVec3</a>(0.0f, 0.0f, 0.0f); <span class="comment">//along z axis from origin.</span>

gScene-&gt;raycastAllShapes(worldRay, gMyReport, <a class="code" href="group__physics.html#gg001236cc61b749af4eb05a07cfb2857bb0faab9330ffeb9d53791129d495a850">NX_ALL_SHAPES</a>);
</pre></div><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>worldRay</em>&nbsp;</td><td>The ray to cast in the global frame. <b>Range:</b> See <a class="el" href="classNxRay.html">NxRay</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>report</em>&nbsp;</td><td>User callback, to be called when an intersection is encountered. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shapesType</em>&nbsp;</td><td>Choose if to raycast against static, dynamic or both types of shape. See <a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>groups</em>&nbsp;</td><td>Mask used to filter shape objects. See <a class="el" href="classNxShape.html#03de2c71a97d1f3b1b30abc7bdc208d1">NxShape::setGroup</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxDist</em>&nbsp;</td><td>Max distance to check along the ray for intersecting objects. <b>Range:</b> (0,inf) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hintFlags</em>&nbsp;</td><td>Allows the user to specify which field of <a class="el" href="structNxRaycastHit.html">NxRaycastHit</a> they are interested in. See <a class="el" href="group__physics.html#ge02ef34f964753cb7f022818a10962e8">NxRaycastBit</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>groupsMask</em>&nbsp;</td><td>Alternative mask used to filter shapes. See <a class="el" href="classNxShape.html#a8eca1891f54640eabf40da27476c5d2">NxShape::setGroupsMask</a></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the number of shapes hit</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#74f71e39b9e48ee55aec158e02c65dd0">raycastAnyShape()</a> <a class="el" href="classNxScene.html#3134810c29120974a7a316f8ea07e622">raycastAllBounds()</a> <a class="el" href="classNxRay.html">NxRay</a> <a class="el" href="classNxUserRaycastReport.html">NxUserRaycastReport</a> <a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a> <a class="el" href="classNxShape.html#03de2c71a97d1f3b1b30abc7bdc208d1">NxShape.setGroup()</a> <a class="el" href="structNxRaycastHit.html">NxRaycastHit</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="564174af1cc7ce3c313e2de4bbdc45a7"></a><!-- doxytag: member="NxScene::raycastAnyBounds" ref="564174af1cc7ce3c313e2de4bbdc45a7" args="(const NxRay &amp;worldRay, NxShapesType shapesType, NxU32 groups=0xffffffff, NxReal maxDist=NX_MAX_F32, const NxGroupsMask *groupsMask=NULL) const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool NxScene::raycastAnyBounds           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxRay.html">NxRay</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>worldRay</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>shapesType</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32&nbsp;</td>
          <td class="mdname" nowrap> <em>groups</em> = <code>0xffffffff</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>maxDist</em> = <code>NX_MAX_F32</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>groupsMask</em> = <code>NULL</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns true if any axis aligned bounding box enclosing a shape of type shapeType is intersected by the ray. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>Make certain that the direction vector of <a class="el" href="classNxRay.html">NxRay</a> is normalized.<p>
Because the SDK double buffers shape state, a shape will not be updated until a simulation step is taken. For example the result of setting the global pose is not immediatly visible.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>worldRay</em>&nbsp;</td><td>The ray to cast in the global frame. <b>Range:</b> See <a class="el" href="classNxRay.html">NxRay</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shapesType</em>&nbsp;</td><td>Choose if to raycast against static, dynamic or both types of shape. See <a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>groups</em>&nbsp;</td><td>Mask used to filter shape objects. See <a class="el" href="classNxShape.html#03de2c71a97d1f3b1b30abc7bdc208d1">NxShape::setGroup</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxDist</em>&nbsp;</td><td>Max distance to check along the ray for intersecting bounds. <b>Range:</b> (0,inf) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>groupsMask</em>&nbsp;</td><td>Alternative mask used to filter shapes. See <a class="el" href="classNxShape.html#a8eca1891f54640eabf40da27476c5d2">NxShape::setGroupsMask</a></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>true if any axis aligned bounding box enclosing a shape of type shapeType is intersected by the ray</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a> <a class="el" href="classNxRay.html">NxRay</a> <a class="el" href="classNxShape.html#03de2c71a97d1f3b1b30abc7bdc208d1">NxShape.setGroup()</a> <a class="el" href="classNxScene.html#74f71e39b9e48ee55aec158e02c65dd0">raycastAnyShape()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="74f71e39b9e48ee55aec158e02c65dd0"></a><!-- doxytag: member="NxScene::raycastAnyShape" ref="74f71e39b9e48ee55aec158e02c65dd0" args="(const NxRay &amp;worldRay, NxShapesType shapesType, NxU32 groups=0xffffffff, NxReal maxDist=NX_MAX_F32, const NxGroupsMask *groupsMask=NULL, NxShape **cache=NULL) const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool NxScene::raycastAnyShape           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxRay.html">NxRay</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>worldRay</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>shapesType</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32&nbsp;</td>
          <td class="mdname" nowrap> <em>groups</em> = <code>0xffffffff</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>maxDist</em> = <code>NX_MAX_F32</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>groupsMask</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classNxShape.html">NxShape</a> **&nbsp;</td>
          <td class="mdname" nowrap> <em>cache</em> = <code>NULL</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns true if any shape of type ShapeType is intersected by the ray. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>Make certain that the direction vector of <a class="el" href="classNxRay.html">NxRay</a> is normalized.<p>
Because the SDK double buffers shape state, a shape will not be updated until a simulation step is taken. For example the result of setting the global pose is not immediatly visible.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>worldRay</em>&nbsp;</td><td>The ray to cast in the global frame. <b>Range:</b> See <a class="el" href="classNxRay.html">NxRay</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shapesType</em>&nbsp;</td><td>Choose if to raycast against static, dynamic or both types of shape. See <a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>groups</em>&nbsp;</td><td>Mask used to filter shape objects. See <a class="el" href="classNxShape.html#03de2c71a97d1f3b1b30abc7bdc208d1">NxShape::setGroup</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxDist</em>&nbsp;</td><td>Max distance to check along the ray for intersecting objects. <b>Range:</b> (0,inf) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>groupsMask</em>&nbsp;</td><td>Alternative mask used to filter shapes. See <a class="el" href="classNxShape.html#a8eca1891f54640eabf40da27476c5d2">NxShape::setGroupsMask</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cache</em>&nbsp;</td><td>Possible cache for persistent raycasts, filled out by the SDK.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns true if any shape of type ShapeType is intersected by the ray.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a> <a class="el" href="classNxRay.html">NxRay</a> <a class="el" href="classNxShape.html#03de2c71a97d1f3b1b30abc7bdc208d1">NxShape.setGroup()</a> <a class="el" href="classNxScene.html#564174af1cc7ce3c313e2de4bbdc45a7">raycastAnyBounds()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="3a51467c411f214fd7197562ecf25162"></a><!-- doxytag: member="NxScene::raycastClosestBounds" ref="3a51467c411f214fd7197562ecf25162" args="(const NxRay &amp;worldRay, NxShapesType shapeType, NxRaycastHit &amp;hit, NxU32 groups=0xffffffff, NxReal maxDist=NX_MAX_F32, NxU32 hintFlags=0xffffffff, const NxGroupsMask *groupsMask=NULL) const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxShape.html">NxShape</a>* NxScene::raycastClosestBounds           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxRay.html">NxRay</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>worldRay</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>shapeType</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structNxRaycastHit.html">NxRaycastHit</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>hit</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32&nbsp;</td>
          <td class="mdname" nowrap> <em>groups</em> = <code>0xffffffff</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>maxDist</em> = <code>NX_MAX_F32</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32&nbsp;</td>
          <td class="mdname" nowrap> <em>hintFlags</em> = <code>0xffffffff</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>groupsMask</em> = <code>NULL</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the first axis aligned bounding box enclosing a shape of type shapeType that is hit along the ray. 
<p>
The world space intersection point, and the distance along the ray are also provided. hintFlags is a combination of <a class="el" href="group__physics.html#ge02ef34f964753cb7f022818a10962e8">NxRaycastBit</a> flags.<p>
<dl compact><dt><b>Note:</b></dt><dd>Make certain that the direction vector of <a class="el" href="classNxRay.html">NxRay</a> is normalized.<p>
Because the SDK double buffers shape state, a shape will not be updated until a simulation step is taken. For example the result of setting the global pose is not immediatly visible.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>worldRay</em>&nbsp;</td><td>The ray to cast in the global frame. <b>Range:</b> See <a class="el" href="classNxRay.html">NxRay</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shapeType</em>&nbsp;</td><td>Choose if to raycast against static, dynamic or both types of shape. See <a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a>. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>hit</em>&nbsp;</td><td>Description of the intersection. See <a class="el" href="structNxRaycastHit.html">NxRaycastHit</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>groups</em>&nbsp;</td><td>Mask used to filter shape objects. See <a class="el" href="classNxShape.html#03de2c71a97d1f3b1b30abc7bdc208d1">NxShape::setGroup</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxDist</em>&nbsp;</td><td>Max distance to check along the ray for intersecting objects. <b>Range:</b> (0,inf) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hintFlags</em>&nbsp;</td><td>Allows the user to specify which field of <a class="el" href="structNxRaycastHit.html">NxRaycastHit</a> they are interested in. See <a class="el" href="group__physics.html#ge02ef34f964753cb7f022818a10962e8">NxRaycastBit</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>groupsMask</em>&nbsp;</td><td>Alternative mask used to filter shapes. See <a class="el" href="classNxShape.html#a8eca1891f54640eabf40da27476c5d2">NxShape::setGroupsMask</a></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The shape which is hit.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#3134810c29120974a7a316f8ea07e622">raycastAllBounds()</a> <a class="el" href="classNxRay.html">NxRay</a> <a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a> <a class="el" href="structNxRaycastHit.html">NxRaycastHit</a> <a class="el" href="classNxShape.html#03de2c71a97d1f3b1b30abc7bdc208d1">NxShape.setGroup()</a> <a class="el" href="group__physics.html#ge02ef34f964753cb7f022818a10962e8">NxRaycastBit</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="8cfd017296ab965088561ec92d8fe6ea"></a><!-- doxytag: member="NxScene::raycastClosestShape" ref="8cfd017296ab965088561ec92d8fe6ea" args="(const NxRay &amp;worldRay, NxShapesType shapeType, NxRaycastHit &amp;hit, NxU32 groups=0xffffffff, NxReal maxDist=NX_MAX_F32, NxU32 hintFlags=0xffffffff, const NxGroupsMask *groupsMask=NULL, NxShape **cache=NULL) const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxShape.html">NxShape</a>* NxScene::raycastClosestShape           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxRay.html">NxRay</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>worldRay</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>shapeType</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structNxRaycastHit.html">NxRaycastHit</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>hit</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32&nbsp;</td>
          <td class="mdname" nowrap> <em>groups</em> = <code>0xffffffff</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>maxDist</em> = <code>NX_MAX_F32</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32&nbsp;</td>
          <td class="mdname" nowrap> <em>hintFlags</em> = <code>0xffffffff</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>groupsMask</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classNxShape.html">NxShape</a> **&nbsp;</td>
          <td class="mdname" nowrap> <em>cache</em> = <code>NULL</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the first shape of type shapeType that is hit along the ray. 
<p>
The world space intersection point, and the distance along the ray are also provided. hintFlags is a combination of <a class="el" href="group__physics.html#ge02ef34f964753cb7f022818a10962e8">NxRaycastBit</a> flags.<p>
<dl compact><dt><b>Note:</b></dt><dd>Make certain that the direction vector of <a class="el" href="classNxRay.html">NxRay</a> is normalized.<p>
Because the SDK double buffers shape state, a shape will not be updated until a simulation step is taken. For example the result of setting the global pose is not immediatly visible.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>worldRay</em>&nbsp;</td><td>The ray to cast in the global frame. <b>Range:</b> See <a class="el" href="classNxRay.html">NxRay</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shapeType</em>&nbsp;</td><td>Choose if to raycast against static, dynamic or both types of shape. See <a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a>. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>hit</em>&nbsp;</td><td>Description of the intersection. See <a class="el" href="structNxRaycastHit.html">NxRaycastHit</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>groups</em>&nbsp;</td><td>Mask used to filter shape objects. See <a class="el" href="classNxShape.html#03de2c71a97d1f3b1b30abc7bdc208d1">NxShape::setGroup</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxDist</em>&nbsp;</td><td>Max distance to check along the ray for intersecting objects. <b>Range:</b> (0,inf) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hintFlags</em>&nbsp;</td><td>Allows the user to specify which field of <a class="el" href="structNxRaycastHit.html">NxRaycastHit</a> they are interested in. See <a class="el" href="group__physics.html#ge02ef34f964753cb7f022818a10962e8">NxRaycastBit</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>groupsMask</em>&nbsp;</td><td>Alternative mask used to filter shapes. See <a class="el" href="classNxShape.html#a8eca1891f54640eabf40da27476c5d2">NxShape::setGroupsMask</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cache</em>&nbsp;</td><td>Possible cache for persistent raycasts, filled out by the SDK.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The shape which is hit.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#21fdc86f5fcfe33d7b4f6c802c7c3f94">raycastAllShapes()</a> <a class="el" href="classNxRay.html">NxRay</a> <a class="el" href="group__physics.html#g001236cc61b749af4eb05a07cfb2857b">NxShapesType</a> <a class="el" href="structNxRaycastHit.html">NxRaycastHit</a> <a class="el" href="classNxShape.html#03de2c71a97d1f3b1b30abc7bdc208d1">NxShape.setGroup()</a> <a class="el" href="group__physics.html#ge02ef34f964753cb7f022818a10962e8">NxRaycastBit</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="29a7d14b3edfc4c45196f4412958078f"></a><!-- doxytag: member="NxScene::readProfileData" ref="29a7d14b3edfc4c45196f4412958078f" args="(bool clearData)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual const <a class="el" href="classNxProfileData.html">NxProfileData</a>* NxScene::readProfileData           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>clearData</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Accesses internal profiler. If clearData is true, the profile counters are reset. You will most likely want to call readProfileData(true) right after calling <a class="el" href="classNxScene.html#120b86a16a1786546d73a5d22f7d1d55">fetchResults()</a>. If that is not the time you want to read out the data, just call readProfileData(false) at some other place in your code.<p>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes </li>
</ul>
    </td>
  </tr>
</table>
<a class="anchor" name="b20ab7bf376ae2238882964c2c10424e"></a><!-- doxytag: member="NxScene::releaseActor" ref="b20ab7bf376ae2238882964c2c10424e" args="(NxActor &amp;actor)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::releaseActor           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classNxActor.html">NxActor</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>actor</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Deletes the specified actor. 
<p>
Also releases any body and/or shapes associated with the actor.<p>
The actor must be in this scene. Do not keep a reference to the deleted instance. Avoid release calls while the scene is simulating (in between <a class="el" href="classNxScene.html#4016009eb8c4a82959496bdab2cea017">simulate()</a> and <a class="el" href="classNxScene.html#120b86a16a1786546d73a5d22f7d1d55">fetchResults()</a> calls).<p>
Note: deleting a static actor will not wake up any sleeping objects that were sitting on it. Use a kinematic actor instead to get this behavior.<p>
Releasing an actor will affect any joints that are connected to the actor. Such joints will be moved to a list of "dead joints" and automatically deleted upon scene deletion, or explicitly by the user by calling <a class="el" href="classNxScene.html#00578d1d1016a602df2b8e1f161d3ebb">NxScene::releaseJoint()</a>. It is recommended to always remove all joints that reference actors before the actors themselves are removed. It is not possible to retrieve the list of dead joints.<p>
<b>Sleeping:</b> This call will awaken any sleeping actors contacting the deleted actor (directly or indirectly).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor</em>&nbsp;</td><td>The actor to release.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#67d5aeda6c35776fd7fbf3ab43cdaaf2">createActor()</a> <a class="el" href="classNxActor.html">NxActor</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="2f5f8ebb1a394a37631486d3d494551c"></a><!-- doxytag: member="NxScene::releaseCloth" ref="2f5f8ebb1a394a37631486d3d494551c" args="(NxCloth &amp;cloth)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::releaseCloth           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classNxCloth.html">NxCloth</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>cloth</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Deletes the specified cloth. The cloth must be in this scene. Do not keep a reference to the deleted instance. Avoid release calls while the scene is simulating (in between <a class="el" href="classNxScene.html#4016009eb8c4a82959496bdab2cea017">simulate()</a> and <a class="el" href="classNxScene.html#120b86a16a1786546d73a5d22f7d1d55">fetchResults()</a> calls).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cloth</em>&nbsp;</td><td>Cloth to release.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxCloth.html">NxCloth</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="08fae090bb9ef999c3e265cf886a64d7"></a><!-- doxytag: member="NxScene::releaseEffector" ref="08fae090bb9ef999c3e265cf886a64d7" args="(NxEffector &amp;effector)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::releaseEffector           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classNxEffector.html">NxEffector</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>effector</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Deletes the effector passed. 
<p>
Do not keep a reference to the deleted instance. Avoid release calls while the scene is simulating (in between <a class="el" href="classNxScene.html#4016009eb8c4a82959496bdab2cea017">simulate()</a> and <a class="el" href="classNxScene.html#120b86a16a1786546d73a5d22f7d1d55">fetchResults()</a> calls).<p>
<b>Sleeping:</b> Does <b>NOT</b> wake the actor up automatically.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>effector</em>&nbsp;</td><td>The effector to delete.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#daee1f1b73068cf2c32e89268f4d73ed">createSpringAndDamperEffector</a> <a class="el" href="classNxSpringAndDamperEffector.html">NxSpringAndDamperEffector</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="8d1bc41f20de36487a6b681ff9b777c8"></a><!-- doxytag: member="NxScene::releaseFluid" ref="8d1bc41f20de36487a6b681ff9b777c8" args="(NxFluid &amp;fluid)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::releaseFluid           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classNxFluid.html">NxFluid</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>fluid</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Deletes the specified fluid. The fluid must be in this scene. 
<p>
Also releases any screen surface meshes created from the fluid.<p>
Do not keep a reference to the deleted instance. Avoid release calls while the scene is simulating (in between <a class="el" href="classNxScene.html#4016009eb8c4a82959496bdab2cea017">simulate()</a> and <a class="el" href="classNxScene.html#120b86a16a1786546d73a5d22f7d1d55">fetchResults()</a> calls).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fluid</em>&nbsp;</td><td>Fluid to release.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#702dc69b6f663dd0ae87505a9e6a9c79">createFluid()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="0f5c3108de6e31eaba0e413f3c877087"></a><!-- doxytag: member="NxScene::releaseForceField" ref="0f5c3108de6e31eaba0e413f3c877087" args="(NxForceField &amp;forceField)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::releaseForceField           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classNxForceField.html">NxForceField</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>forceField</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Deletes the force field passed. 
<p>
Do not keep a reference to the deleted instance. Avoid release calls while the scene is simulating (in between <a class="el" href="classNxScene.html#4016009eb8c4a82959496bdab2cea017">simulate()</a> and <a class="el" href="classNxScene.html#120b86a16a1786546d73a5d22f7d1d55">fetchResults()</a> calls).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>forceField</em>&nbsp;</td><td>The effector to delete.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes [SW fallback] </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#4440eb8fa1a88501cdeb46e229c3ad6a">createForceField</a> <a class="el" href="classNxForceField.html">NxForceField</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="919b6675e07a2431c20a18673b78fcbf"></a><!-- doxytag: member="NxScene::releaseForceFieldLinearKernel" ref="919b6675e07a2431c20a18673b78fcbf" args="(NxForceFieldLinearKernel &amp;kernel)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::releaseForceFieldLinearKernel           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classNxForceFieldLinearKernel.html">NxForceFieldLinearKernel</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>kernel</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
releases a linear force field kernel 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>kernel</em>&nbsp;</td><td>to be released. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="classNxForceFieldLinearKernel.html">NxForceFieldLinearKernel</a>. See <a class="el" href="classNxForceFieldLinearKernel.html">NxForceFieldLinearKernel</a></dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes [SW fallback] </li>
<li>PS3 : Yes </li>
<li>XB360: Yes </li>
</ul>
    </td>
  </tr>
</table>
<a class="anchor" name="cf4b8692fa10d5ae72b2127df323ecf8"></a><!-- doxytag: member="NxScene::releaseForceFieldMaterial" ref="cf4b8692fa10d5ae72b2127df323ecf8" args="(NxForceFieldMaterial mat)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::releaseForceFieldMaterial           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__physics.html#g6a78f0087de2bc790aff345a36f7552f">NxForceFieldMaterial</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mat</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Releases a forcefield material index and the related column in the scaling table. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mat</em>&nbsp;</td><td>The material index to release.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes [SW fallback] </li>
<li>PS3 : Yes </li>
<li>XB360: Yes </li>
</ul>
    </td>
  </tr>
</table>
<a class="anchor" name="e9836babd691d45473c53abb2c1c50a0"></a><!-- doxytag: member="NxScene::releaseForceFieldShapeGroup" ref="e9836babd691d45473c53abb2c1c50a0" args="(NxForceFieldShapeGroup &amp;group)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::releaseForceFieldShapeGroup           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classNxForceFieldShapeGroup.html">NxForceFieldShapeGroup</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>group</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Releases a force field shape group. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>group</em>&nbsp;</td><td>The group which is to be relased. See <a class="el" href="classNxForceFieldShapeGroup.html">NxForceFieldShapeGroup</a>.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes [SW fallback] </li>
<li>PS3 : Yes </li>
<li>XB360: Yes </li>
</ul>
    </td>
  </tr>
</table>
<a class="anchor" name="0aa4a83affd4f618b83b84b5ffe1db69"></a><!-- doxytag: member="NxScene::releaseForceFieldVariety" ref="0aa4a83affd4f618b83b84b5ffe1db69" args="(NxForceFieldVariety var)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::releaseForceFieldVariety           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__physics.html#g640c39d5ac1c8eafdb90f3f8c585ee2b">NxForceFieldVariety</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>var</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Releases a forcefield variety index and the related row in the scaling table. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mat</em>&nbsp;</td><td>The variery index to release.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes [SW fallback] </li>
<li>PS3 : Yes </li>
<li>XB360: Yes </li>
</ul>
    </td>
  </tr>
</table>
<a class="anchor" name="00578d1d1016a602df2b8e1f161d3ebb"></a><!-- doxytag: member="NxScene::releaseJoint" ref="00578d1d1016a602df2b8e1f161d3ebb" args="(NxJoint &amp;joint)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::releaseJoint           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classNxJoint.html">NxJoint</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>joint</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Deletes the specified joint. 
<p>
The joint must be in this scene. Do not keep a reference to the deleted instance. Avoid release calls while the scene is simulating (in between <a class="el" href="classNxScene.html#4016009eb8c4a82959496bdab2cea017">simulate()</a> and <a class="el" href="classNxScene.html#120b86a16a1786546d73a5d22f7d1d55">fetchResults()</a> calls).<p>
<b>Sleeping:</b> This call wakes the actor(s) if they are sleeping.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>joint</em>&nbsp;</td><td>The joint to release.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes </li>
</ul>
    </td>
  </tr>
</table>
<a class="anchor" name="d50c514ff47e8abedcbcd19eff30be4c"></a><!-- doxytag: member="NxScene::releaseMaterial" ref="d50c514ff47e8abedcbcd19eff30be4c" args="(NxMaterial &amp;material)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::releaseMaterial           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classNxMaterial.html">NxMaterial</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>material</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Deletes the specified material. 
<p>
The material must be in this scene. Do not keep a reference to the deleted instance. If you release a material while shapes or meshes are referencing its material index, the material assignment of these objects becomes undefined. Avoid release calls while the scene is simulating (in between <a class="el" href="classNxScene.html#4016009eb8c4a82959496bdab2cea017">simulate()</a> and <a class="el" href="classNxScene.html#120b86a16a1786546d73a5d22f7d1d55">fetchResults()</a> calls).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>material</em>&nbsp;</td><td>The material to release.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#a16ceef08f12195b0e5e2dd1efd98523">createMaterial()</a> <a class="el" href="classNxMaterial.html">NxMaterial</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="d60ff389056371621715a19b29e10cf0"></a><!-- doxytag: member="NxScene::releaseSceneQuery" ref="d60ff389056371621715a19b29e10cf0" args="(NxSceneQuery &amp;query)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool NxScene::releaseSceneQuery           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classNxSceneQuery.html">NxSceneQuery</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>query</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Release a scene query object. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>query</em>&nbsp;</td><td>The query object to release. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True on success.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes (software) </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#7191a18eb6d75735267a4c33a1e2299a">createSceneQuery()</a> <a class="el" href="classNxSceneQuery.html">NxSceneQuery</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="bbd8f11b2727bb38b6608e951b49c5a0"></a><!-- doxytag: member="NxScene::releaseSoftBody" ref="bbd8f11b2727bb38b6608e951b49c5a0" args="(NxSoftBody &amp;softBody)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::releaseSoftBody           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classNxSoftBody.html">NxSoftBody</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>softBody</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Deletes the specified soft body. The soft body must be in this scene. Do not keep a reference to the deleted instance. Avoid release calls while the scene is simulating (in between <a class="el" href="classNxScene.html#4016009eb8c4a82959496bdab2cea017">simulate()</a> and <a class="el" href="classNxScene.html#120b86a16a1786546d73a5d22f7d1d55">fetchResults()</a> calls).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>softBody</em>&nbsp;</td><td>Soft body to release.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxSoftBody.html">NxSoftBody</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="45ae6fcc592ae3955d251a190399778f"></a><!-- doxytag: member="NxScene::releaseSweepCache" ref="45ae6fcc592ae3955d251a190399778f" args="(NxSweepCache *cache)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::releaseSweepCache           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classNxSweepCache.html">NxSweepCache</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>cache</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Deletes a sweep cache. See the Guide, "Sweep API" section, for more information on sweep caches. Avoid release calls while the scene is simulating (in between <a class="el" href="classNxScene.html#4016009eb8c4a82959496bdab2cea017">simulate()</a> and <a class="el" href="classNxScene.html#120b86a16a1786546d73a5d22f7d1d55">fetchResults()</a> calls). 
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html">NxActor</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="4dc6b5aa41bedad81992e96cebddb5d6"></a><!-- doxytag: member="NxScene::resetEffectorIterator" ref="4dc6b5aa41bedad81992e96cebddb5d6" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::resetEffectorIterator           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Restarts the effector iterator so that the next call to getNextEffector() returns the first effector in the scene. 
<p>
Creating or deleting effectors resets the joint iterator.<p>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#4aaff4a9db595e5b7dc25841819f5489">getNextEffector()</a> <a class="el" href="classNxScene.html#a55199c404c776475f71b0882465c754">getNbEffectors()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="35a7c971541b877f47807f2781c99941"></a><!-- doxytag: member="NxScene::resetForceFieldLinearKernelsIterator" ref="35a7c971541b877f47807f2781c99941" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::resetForceFieldLinearKernelsIterator           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Restarts the linear kernels iterator so that the next call to <a class="el" href="classNxScene.html#0004c1ba77f1b613139969637480dc1e">getNextForceFieldLinearKernel()</a>. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The first shape group in the force scene.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes [SW fallback] </li>
<li>PS3 : Yes </li>
<li>XB360: Yes </li>
</ul>
    </td>
  </tr>
</table>
<a class="anchor" name="6d5d84cadc9bcc4a92f6a76b01163659"></a><!-- doxytag: member="NxScene::resetForceFieldShapeGroupsIterator" ref="6d5d84cadc9bcc4a92f6a76b01163659" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::resetForceFieldShapeGroupsIterator           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Restarts the shape groups iterator so that the next call to <a class="el" href="classNxScene.html#01e1183c4acbcd207bf3f4c4ecc879ed">getNextForceFieldShapeGroup()</a> returns the first shape group in the force scene. 
<p>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes [SW fallback] </li>
<li>PS3 : Yes </li>
<li>XB360: Yes </li>
</ul>
    </td>
  </tr>
</table>
<a class="anchor" name="9f3d1e4408bf99f193cfee52a113cf83"></a><!-- doxytag: member="NxScene::resetJointIterator" ref="9f3d1e4408bf99f193cfee52a113cf83" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::resetJointIterator           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Restarts the joint iterator so that the next call to getNextJoint() returns the first joint in the scene. 
<p>
Creating or deleting joints resets the joint iterator.<p>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#9f3d1e4408bf99f193cfee52a113cf83">resetJointIterator()</a> <a class="el" href="classNxScene.html#6832193dab2b4f8c901a2230cb16eddf">getNbJoints()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="244018b935af9bcd373f3d452965d18e"></a><!-- doxytag: member="NxScene::resetPollForWork" ref="244018b935af9bcd373f3d452965d18e" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::resetPollForWork           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Reset parallel simulation. 
<p>
Resets parallel simulation so that threads calling pollForWork do not return NX_THREAD_SIMULATION_END, but instead wait for a new simulation step to start.<p>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : No </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#02a7bb5a100770f92e70de2685fb0eee">pollForWork()</a> <a class="el" href="group__physics.html#g70ce4c9351d5599a0c9426942d8f3a0d">NxThreadPollResult</a> <a class="el" href="group__physics.html#g01bb907296af882b2e2c6694273d7775">NxThreadWait</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="645b3399372791ec9437a8378cbb4228"></a><!-- doxytag: member="NxScene::saveToDesc" ref="645b3399372791ec9437a8378cbb4228" args="(NxSceneDesc &amp;desc) const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool NxScene::saveToDesc           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classNxSceneDesc.html">NxSceneDesc</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>desc</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Saves the Scene descriptor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>The descriptor used to retrieve the state of the object. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True on success.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxSceneDesc.html">NxSceneDesc</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="c918ed0ade26efb4df810e495924e05c"></a><!-- doxytag: member="NxScene::setActorGroupPairFlags" ref="c918ed0ade26efb4df810e495924e05c" args="(NxActorGroup group1, NxActorGroup group2, NxU32 flags)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::setActorGroupPairFlags           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__physics.html#gd7d66f3c79185448a29cbc084ddcfefb">NxActorGroup</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>group1</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__physics.html#gd7d66f3c79185448a29cbc084ddcfefb">NxActorGroup</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>group2</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32&nbsp;</td>
          <td class="mdname" nowrap> <em>flags</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
With this method one can set contact reporting flags between actors belonging to a pair of groups. 
<p>
It is possible to assign each actor to a group using <a class="el" href="classNxActor.html#3f2e3d34803c146d47264099cf27a7dc">NxActor::setGroup()</a>. This is a different set of groups from the shape groups despite the similar name. Here up to 0xffff different groups are permitted, With this method one can set contact reporting flags between actors belonging to a pair of groups.<p>
The following flags are permitted:<p>
NX_NOTIFY_ON_START_TOUCH NX_NOTIFY_ON_END_TOUCH NX_NOTIFY_ON_TOUCH NX_NOTIFY_ON_START_TOUCH_FORCE_THRESHOLD NX_NOTIFY_ON_END_TOUCH_FORCE_THRESHOLD NX_NOTIFY_ON_TOUCH_FORCE_THRESHOLD NX_NOTIFY_ON_IMPACT NX_NOTIFY_ON_ROLL NX_NOTIFY_ON_SLIDE<p>
See <a class="el" href="group__physics.html#g05983d9ea71be115e74f0a5d6a7559cc">NxContactPairFlag</a>.<p>
Note that finer grain control of pairwise flags is possible using the functions <a class="el" href="classNxScene.html#d2795f18b35cd23e749535459b3e6a22">NxScene::setShapePairFlags()</a> and <a class="el" href="classNxScene.html#124e55cbcbfa0a5bcf6a8f19f36fd5fe">NxScene::setActorPairFlags()</a>.<p>
<b>Sleeping:</b> Does <b>NOT</b> wake the actors up automatically.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>group1</em>&nbsp;</td><td>First group. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>group2</em>&nbsp;</td><td>Second group </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags to control contact reporting. See <a class="el" href="group__physics.html#g05983d9ea71be115e74f0a5d6a7559cc">NxContactPairFlag</a>.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#871ae96ecabb8808e707a1616a3417b0">getActorGroupPairFlags()</a> <a class="el" href="group__physics.html#gd7d66f3c79185448a29cbc084ddcfefb">NxActorGroup</a> <a class="el" href="classNxActor.html#13d0bf7a27e8870eb93e233dbb8107ec">NxActor.getGroup()</a> <a class="el" href="classNxActor.html#3f2e3d34803c146d47264099cf27a7dc">NxActor.setGroup()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="124e55cbcbfa0a5bcf6a8f19f36fd5fe"></a><!-- doxytag: member="NxScene::setActorPairFlags" ref="124e55cbcbfa0a5bcf6a8f19f36fd5fe" args="(NxActor &amp;actorA, NxActor &amp;actorB, NxU32 nxContactPairFlag)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::setActorPairFlags           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classNxActor.html">NxActor</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>actorA</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classNxActor.html">NxActor</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>actorB</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32&nbsp;</td>
          <td class="mdname" nowrap> <em>nxContactPairFlag</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the pair flags for the given pair of actors. 
<p>
The pair flags are a combination of bits defined by <a class="el" href="group__physics.html#g05983d9ea71be115e74f0a5d6a7559cc">NxContactPairFlag</a>. Calling this on an actor that has no shape(s) has no effect. The two actor references must not reference the same actor.<p>
It is important to note that the SDK stores pair flags per shape, even for actor pair flags. This means that shapes should be created before actor pair flags are set, otherwise the pair flags will be ignored.<p>
<b>Sleeping:</b> Does <b>NOT</b> wake the actors up automatically.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actorA</em>&nbsp;</td><td>Actor A </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actorB</em>&nbsp;</td><td>Actor B </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nxContactPairFlag</em>&nbsp;</td><td>New set of contact pair flags. See <a class="el" href="group__physics.html#g05983d9ea71be115e74f0a5d6a7559cc">NxContactPairFlag</a></td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#a6c8692f4c06a00658c2831e80608b7b">getActorPairFlags()</a> <a class="el" href="group__physics.html#g05983d9ea71be115e74f0a5d6a7559cc">NxContactPairFlag</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="892fa4cbd5abae3506c4127e12c96a1b"></a><!-- doxytag: member="NxScene::setClothUserNotify" ref="892fa4cbd5abae3506c4127e12c96a1b" args="(NxClothUserNotify *callback)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::setClothUserNotify           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classNxClothUserNotify.html">NxClothUserNotify</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>callback</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets a user notify object which receives special simulation events when they occur. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>User cloth notification callback. See <a class="el" href="classNxClothUserNotify.html">NxClothUserNotify</a>.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: No </li>
<li>PPU : No </li>
<li>PS3 : No </li>
<li>XB360: No</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxClothUserNotify.html">NxClothUserNotify</a> <a class="el" href="classNxScene.html#57c06bc02979452cd547a7b012869823">getClothUserNotify</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="b3a23eb788d2c6e290e3d14d8d5a2a79"></a><!-- doxytag: member="NxScene::setDominanceGroupPair" ref="b3a23eb788d2c6e290e3d14d8d5a2a79" args="(NxDominanceGroup group1, NxDominanceGroup group2, NxConstraintDominance &amp;dominance)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::setDominanceGroupPair           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__physics.html#gd17c09bc9705b7db96e260dffffdb381">NxDominanceGroup</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>group1</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__physics.html#gd17c09bc9705b7db96e260dffffdb381">NxDominanceGroup</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>group2</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structNxConstraintDominance.html">NxConstraintDominance</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>dominance</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Specifies the dominance behavior of constraints between two actors with two certain dominance groups. 
<p>
It is possible to assign each actor to a dominance groups using <a class="el" href="classNxActor.html#589c806ed21ba3b8abe624e65d9c46a2">NxActor::setDominanceGroup()</a>.<p>
With dominance groups one can have all constraints (contacts and joints) created between actors act in one direction only. This is useful if you want to make sure that the movement of the rider of a vehicle or the pony tail of a character doesn't influence the object it is attached to, while keeping the motion of both inherently physical.<p>
Whenever a constraint (i.e. joint or contact) between two actors (a0, a1) needs to be solved, the groups (g0, g1) of both actors are retrieved. Then the <a class="el" href="structNxConstraintDominance.html">NxConstraintDominance</a> setting for this group pair is retrieved with getDominanceGroupPair(g0, g1).<p>
In the constraint, <a class="el" href="structNxConstraintDominance.html#537cbb66137a51e3c001e8a6769bb960">NxConstraintDominance::dominance0</a> becomes the dominance setting for a0, and <a class="el" href="structNxConstraintDominance.html#46579432cd8bf1ce41361102eb33a470">NxConstraintDominance::dominance1</a> becomes the dominance setting for a1. A dominanceN setting of 1.0f, the default, will permit aN to be pushed or pulled by a(1-N) through the constraint. A dominanceN setting of 0.0f, will however prevent aN to be pushed or pulled by a(1-N) through the constraint. Thus, a <a class="el" href="structNxConstraintDominance.html">NxConstraintDominance</a> of (1.0f, 0.0f) makes the interaction one-way.<p>
The matrix sampled by getDominanceGroupPair(g1, g2) is initialised by default such that:<p>
if g1 == g2, then (1.0f, 1.0f) is returned if g1 &lt; g2, then (0.0f, 1.0f) is returned if g1 &gt; g2, then (1.0f, 0.0f) is returned<p>
In other words, we permit actors in higher groups to be pushed around by actors in lower groups by default.<p>
These settings should cover most applications, and in fact not overriding these settings may likely result in higher performance.<p>
It is not possible to make the matrix asymetric, or to change the diagonal. In other words:<p>
it is not possible to change (g1, g2) if (g1==g2) if you set<p>
(g1, g2) to X, then (g2, g1) will implicitly and automatically be set to ~X, where:<p>
~(1.0f, 1.0f) is (1.0f, 1.0f) ~(0.0f, 1.0f) is (1.0f, 0.0f) ~(1.0f, 0.0f) is (0.0f, 1.0f)<p>
These two restrictions are to make sure that constraints between two actors will always evaluate to the same dominance setting, regardless of which order the actors are passed to the constraint.<p>
Dominance settings are currently specified as floats 0.0f or 1.0f because in the future we may permit arbitrary fractional settings to express 'partly-one-way' interactions.<p>
<b>Sleeping:</b> Does <b>NOT</b> wake actors up automatically.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#44709422d5269f4966451964958c0bd6">getDominanceGroupPair()</a> <a class="el" href="group__physics.html#gd17c09bc9705b7db96e260dffffdb381">NxDominanceGroup</a> <a class="el" href="structNxConstraintDominance.html">NxConstraintDominance</a> <a class="el" href="classNxActor.html#589c806ed21ba3b8abe624e65d9c46a2">NxActor::setDominanceGroup()</a> <a class="el" href="classNxActor.html#0809ec35a615e40824d13bf373ef3587">NxActor::getDominanceGroup()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="e6195bf85df84d67e3918bb92e8bf25c"></a><!-- doxytag: member="NxScene::setDynamicTreeRebuildRateHint" ref="e6195bf85df84d67e3918bb92e8bf25c" args="(NxU32 dynamicTreeRebuildRateHint)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::setDynamicTreeRebuildRateHint           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">NxU32&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>dynamicTreeRebuildRateHint</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the rebuild rate of the dynamic tree pruning structure. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dynamicTreeRebuildRateHint</em>&nbsp;</td><td>Rebuild rate of the dynamic tree pruning structure.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxSceneDesc.html#bcf4bdeab4980bd80dacdddb548d2cdc">NxSceneDesc.dynamicTreeRebuildRateHint</a> <a class="el" href="classNxScene.html#898c074684ead2e0efb5845a123ef2aa">getDynamicTreeRebuildRateHint()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="aeeaf92ff2dfef1b536e615220b2e240"></a><!-- doxytag: member="NxScene::setFilterBool" ref="aeeaf92ff2dfef1b536e615220b2e240" args="(bool flag)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::setFilterBool           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>flag</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Setups filtering's boolean value. See comments for <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a>. 
<p>
<b>Sleeping:</b> Does <b>NOT</b> wake the actors up automatically.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flag</em>&nbsp;</td><td>Boolean value for filter.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#ee66b7fbef5420ad6b16df1e6180def6">setFilterOps()</a> <a class="el" href="classNxScene.html#92135aeafe85554cd926cfe06bae8c54">setFilterConstant0()</a> <a class="el" href="classNxScene.html#504622ffdbd9815dae2e06fcea079cd5">setFilterConstant1()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="92135aeafe85554cd926cfe06bae8c54"></a><!-- doxytag: member="NxScene::setFilterConstant0" ref="92135aeafe85554cd926cfe06bae8c54" args="(const NxGroupsMask &amp;mask)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::setFilterConstant0           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mask</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Setups filtering's K0 value. See comments for <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a>. 
<p>
<b>Sleeping:</b> Does <b>NOT</b> wake the actors up automatically.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mask</em>&nbsp;</td><td>The new group mask. See <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a>.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#ee66b7fbef5420ad6b16df1e6180def6">setFilterOps()</a> <a class="el" href="classNxScene.html#aeeaf92ff2dfef1b536e615220b2e240">setFilterBool()</a> <a class="el" href="classNxScene.html#504622ffdbd9815dae2e06fcea079cd5">setFilterConstant1()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="504622ffdbd9815dae2e06fcea079cd5"></a><!-- doxytag: member="NxScene::setFilterConstant1" ref="504622ffdbd9815dae2e06fcea079cd5" args="(const NxGroupsMask &amp;mask)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::setFilterConstant1           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mask</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Setups filtering's K1 value. See comments for <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a>. 
<p>
<b>Sleeping:</b> Does <b>NOT</b> wake the actors up automatically.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mask</em>&nbsp;</td><td>The new group mask. See <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a>.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#ee66b7fbef5420ad6b16df1e6180def6">setFilterOps()</a> <a class="el" href="classNxScene.html#aeeaf92ff2dfef1b536e615220b2e240">setFilterBool()</a> <a class="el" href="classNxScene.html#92135aeafe85554cd926cfe06bae8c54">setFilterConstant0()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ee66b7fbef5420ad6b16df1e6180def6"></a><!-- doxytag: member="NxScene::setFilterOps" ref="ee66b7fbef5420ad6b16df1e6180def6" args="(NxFilterOp op0, NxFilterOp op1, NxFilterOp op2)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::setFilterOps           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__physics.html#g0bb727ab008ff2a2cfcf2533489b58f2">NxFilterOp</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>op0</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__physics.html#g0bb727ab008ff2a2cfcf2533489b58f2">NxFilterOp</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>op1</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__physics.html#g0bb727ab008ff2a2cfcf2533489b58f2">NxFilterOp</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>op2</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Setups filtering operations. See comments for <a class="el" href="classNxGroupsMask.html">NxGroupsMask</a>. 
<p>
<b>Sleeping:</b> Does <b>NOT</b> wake the actors up automatically.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>op0</em>&nbsp;</td><td>Filter op 0. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>op1</em>&nbsp;</td><td>Filter op 1. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>op2</em>&nbsp;</td><td>Filter op 2.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#aeeaf92ff2dfef1b536e615220b2e240">setFilterBool()</a> <a class="el" href="classNxScene.html#92135aeafe85554cd926cfe06bae8c54">setFilterConstant0()</a> <a class="el" href="classNxScene.html#504622ffdbd9815dae2e06fcea079cd5">setFilterConstant1()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="8262e2bfac8fa7c4e3ca5a2ab949fb86"></a><!-- doxytag: member="NxScene::setFluidUserNotify" ref="8262e2bfac8fa7c4e3ca5a2ab949fb86" args="(NxFluidUserNotify *callback)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::setFluidUserNotify           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classNxFluidUserNotify.html">NxFluidUserNotify</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>callback</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets a user notify object which receives special simulation events when they occur. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>User fluid notification callback. See <a class="el" href="classNxFluidUserNotify.html">NxFluidUserNotify</a>.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: No </li>
<li>PPU : No </li>
<li>PS3 : No </li>
<li>XB360: No</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxFluidUserNotify.html">NxFluidUserNotify</a> <a class="el" href="classNxScene.html#4d92af89425c2955b62abc5a26f5a0e2">getFluidUserNotify</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="3e2a82f1517151b482ec5878230cc934"></a><!-- doxytag: member="NxScene::setForceFieldScale" ref="3e2a82f1517151b482ec5878230cc934" args="(NxForceFieldVariety var, NxForceFieldMaterial mat, NxReal val)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::setForceFieldScale           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__physics.html#g640c39d5ac1c8eafdb90f3f8c585ee2b">NxForceFieldVariety</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__physics.html#g6a78f0087de2bc790aff345a36f7552f">NxForceFieldMaterial</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>mat</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>val</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the scaling value for a given variety/material pair. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>var</em>&nbsp;</td><td>A Variety index. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mat</em>&nbsp;</td><td>A Material index. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>val</em>&nbsp;</td><td>The value to set at the variety/material coordinate in the table. Setting the value to big or to low may cause invalid floats in the kernel output.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes [SW fallback] </li>
<li>PS3 : Yes </li>
<li>XB360: Yes </li>
</ul>
    </td>
  </tr>
</table>
<a class="anchor" name="3d35ff91cee3f0a6b7c0f4afb63b2766"></a><!-- doxytag: member="NxScene::setGravity" ref="3d35ff91cee3f0a6b7c0f4afb63b2766" args="(const NxVec3 &amp;vec)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::setGravity           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>vec</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets a constant gravity for the entire scene. 
<p>
<b>Sleeping:</b> Does <b>NOT</b> wake the actor up automatically.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>vec</em>&nbsp;</td><td>A new gravity vector(e.g. <a class="el" href="classNxVec3.html">NxVec3</a>(0.0f,-9.8f,0.0f) ) <b>Range:</b> force vector</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxSceneDesc.html#5a464293323cfe168685b120f52d82ea">NxSceneDesc.gravity</a> <a class="el" href="classNxScene.html#90d1d018192a6fd4ebe6bb7b4ceb6eae">getGravity()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="5d3b6f687c209e0c7d88d3c7b0ec0d81"></a><!-- doxytag: member="NxScene::setGroupCollisionFlag" ref="5d3b6f687c209e0c7d88d3c7b0ec0d81" args="(NxCollisionGroup group1, NxCollisionGroup group2, bool enable)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::setGroupCollisionFlag           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__physics.html#gb144febecb4fc60da5d48839c14c2501">NxCollisionGroup</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>group1</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__physics.html#gb144febecb4fc60da5d48839c14c2501">NxCollisionGroup</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>group2</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>enable</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Specifies if collision should be performed by a pair of shape groups. 
<p>
It is possible to assign each shape to a collision groups using <a class="el" href="classNxShape.html#03de2c71a97d1f3b1b30abc7bdc208d1">NxShape::setGroup()</a>. With this method one can set whether collisions should be detected between shapes belonging to a given pair of groups. Initially all pairs are enabled.<p>
Collision detection between two shapes a and b occurs if: getGroupCollisionFlag(a-&gt;getGroup(), b-&gt;getGroup()) &amp;&amp; isEnabledPair(a,b) is true.<p>
Fluids can be assigned to collision groups as well.<p>
NxCollisionGroup is an integer between 0 and 31.<p>
<b>Sleeping:</b> Does <b>NOT</b> wake the associated actors up automatically.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>group1</em>&nbsp;</td><td>First group. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>group2</em>&nbsp;</td><td>Second group. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>enable</em>&nbsp;</td><td>True to enable collision between the groups.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__physics.html#gb144febecb4fc60da5d48839c14c2501">NxCollisionGroup</a> <a class="el" href="classNxScene.html#c4d2b48b89c0398869399b5db6e4ec0b">getGroupCollisionFlag()</a> <a class="el" href="classNxShape.html#03de2c71a97d1f3b1b30abc7bdc208d1">NxShape.setGroup()</a> <a class="el" href="classNxShape.html#00020779ec876e57b4a9f839f2fbeaca">NxShape.getGroup()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="6c9f687bded62d2edfacfc858a563a0a"></a><!-- doxytag: member="NxScene::setMaxCPUForLoadBalancing" ref="6c9f687bded62d2edfacfc858a563a0a" args="(NxReal cpuFraction)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::setMaxCPUForLoadBalancing           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>cpuFraction</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Not yet implemented! 
<p>
Call to set the maximum CPU for use when load-balancing.<p>
The SDK may choose to balance physics load by simulating assets on the CPU which could otherwise be simulated on the PPU. Use this function to allocate a portion of the CPU for this purpose. Note that the SDK only load-balances assets created in compartments with the attribute NX_DC_PPU_AUTO_ASSIGN, and that the default CPU allocated is zero.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cpuFraction</em>&nbsp;</td><td>The maximum fraction of the total host CPU to use - for example 0.2 would equate to 20% of a single core or might use 10% of each core or 20% of one core on a dual-core CPU.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__physics.html#gac08043a87fe6aad42e754660079a521">NxDeviceCode</a> <a class="el" href="classNxScene.html#2b8afea9fdd7a6037c241e4968ab33d9">getMaxCPUForLoadBalancing()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="d2795f18b35cd23e749535459b3e6a22"></a><!-- doxytag: member="NxScene::setShapePairFlags" ref="d2795f18b35cd23e749535459b3e6a22" args="(NxShape &amp;shapeA, NxShape &amp;shapeB, NxU32 nxContactPairFlag)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::setShapePairFlags           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classNxShape.html">NxShape</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>shapeA</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classNxShape.html">NxShape</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>shapeB</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32&nbsp;</td>
          <td class="mdname" nowrap> <em>nxContactPairFlag</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Similar to <a class="el" href="classNxScene.html#124e55cbcbfa0a5bcf6a8f19f36fd5fe">setActorPairFlags()</a>, but for a pair of shapes. 
<p>
NX_IGNORE_PAIR is the only thing allowed as a shape pair flag. All of the NX_NOTIFY flags should be used at the actor level. The two shape references must not reference the same shape.<p>
<b>Sleeping:</b> Does <b>NOT</b> wake the associated actors up automatically.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shapeA</em>&nbsp;</td><td>Shape A </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shapeB</em>&nbsp;</td><td>Shape B </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nxContactPairFlag</em>&nbsp;</td><td>New set of shape contact pair flags.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#4c30521d2686d4054c432279aba65ed6">getShapePairFlags()</a> <a class="el" href="group__physics.html#g05983d9ea71be115e74f0a5d6a7559cc">NxContactPairFlag</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="f0d657dc1b0a822ac5943cb548c6a60e"></a><!-- doxytag: member="NxScene::setSoftBodyUserNotify" ref="f0d657dc1b0a822ac5943cb548c6a60e" args="(NxSoftBodyUserNotify *callback)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::setSoftBodyUserNotify           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classNxSoftBodyUserNotify.html">NxSoftBodyUserNotify</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>callback</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets a user notify object which receives special simulation events when they occur. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>User softbody notification callback. See <a class="el" href="classNxSoftBodyUserNotify.html">NxSoftBodyUserNotify</a>.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: No </li>
<li>PPU : No </li>
<li>PS3 : No </li>
<li>XB360: No</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxSoftBodyUserNotify.html">NxSoftBodyUserNotify</a> <a class="el" href="classNxScene.html#8492f05f61d16f19b4e3f63209ad48e9">getSoftBodyUserNotify</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="7e9e9d9826bc43f2d0ac6a1d8181b92d"></a><!-- doxytag: member="NxScene::setSolverBatchSize" ref="7e9e9d9826bc43f2d0ac6a1d8181b92d" args="(NxU32 solverBatchSize)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::setSolverBatchSize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">NxU32&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>solverBatchSize</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the number of actors required to spawn a separate rigid body solver thread. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>If internal multi threading is disabled (see <a class="el" href="group__physics.html#gg19b64b752f22309935028abaec2f7e58681691a24266e278b384f8aaf1244d30">NX_SF_ENABLE_MULTITHREAD</a>) this call will have no effect.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>solverBatchSize</em>&nbsp;</td><td>Number of actors required to spawn a separate rigid body solver thread.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Not applicable </li>
<li>PS3 : Not applicable </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxSceneDesc.html#5a6dcbdde5e31efaeafcddf272dba3e7">NxSceneDesc.solverBatchSize</a> <a class="el" href="classNxScene.html#d436aa74d8aa4d30951a823a2adb5194">getSolverBatchSize()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="3f78154dfd007fbf8b6f74884f94657d"></a><!-- doxytag: member="NxScene::setTiming" ref="3f78154dfd007fbf8b6f74884f94657d" args="(NxReal maxTimestep=1.0f/60.0f, NxU32 maxIter=8, NxTimeStepMethod method=NX_TIMESTEP_FIXED)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::setTiming           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>maxTimestep</em> = <code>1.0f/60.0f</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32&nbsp;</td>
          <td class="mdname" nowrap> <em>maxIter</em> = <code>8</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__physics.html#gb0121e5b18e9aab4ef5619d3749e5a6e">NxTimeStepMethod</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>method</em> = <code>NX_TIMESTEP_FIXED</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets simulation timing parameters used in simulate(elapsedTime). 
<p>
If method is NX_TIMESTEP_FIXED, elapsedTime(<a class="el" href="classNxScene.html#4016009eb8c4a82959496bdab2cea017">simulate()</a> parameter) is internally subdivided into up to maxIter substeps no larger than maxTimestep.<p>
If elapsedTime is not a multiple of maxTimestep then any remaining time is accumulated to be added onto the elapsedTime for the next time step.<p>
If more sub steps than maxIter are needed to advance the simulation by elapsed time, then the remaining time is also accumulated for the next call to <a class="el" href="classNxScene.html#4016009eb8c4a82959496bdab2cea017">simulate()</a>.<p>
The timestep method of TIMESTEP_FIXED is strongly preferred for stable, reproducible simulation.<p>
Alternatively NX_TIMESTEP_VARIABLE can be used, in this case the first two parameters are not used. See also <a class="el" href="group__physics.html#gb0121e5b18e9aab4ef5619d3749e5a6e">NxTimeStepMethod</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxTimestep</em>&nbsp;</td><td>Maximum size of a substep. <b>Range:</b> (0,inf) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxIter</em>&nbsp;</td><td>Maximum number of iterations to divide a timestep into. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>method</em>&nbsp;</td><td>Method to use for timestep (either variable time step or fixed). See <a class="el" href="group__physics.html#gb0121e5b18e9aab4ef5619d3749e5a6e">NxTimeStepMethod</a>.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#dc1375a6e1b406c8165ec1f11366ef3e">flushStream()</a> <a class="el" href="classNxScene.html#4016009eb8c4a82959496bdab2cea017">simulate()</a> <a class="el" href="classNxScene.html#120b86a16a1786546d73a5d22f7d1d55">fetchResults()</a> <a class="el" href="classNxScene.html#5b852665897d56a5f58da38b458718aa">checkResults()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="5b73eede587ac90cbebf8561de8421a2"></a><!-- doxytag: member="NxScene::setUserActorPairFiltering" ref="5b73eede587ac90cbebf8561de8421a2" args="(NxUserActorPairFiltering *callback)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::setUserActorPairFiltering           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classNxUserActorPairFiltering.html">NxUserActorPairFiltering</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>callback</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the custom actor pair filtering to use for this scene. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>callback</em>&nbsp;</td><td>Filtering class that defines the callback to use for custom pair filtering.</td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxUserActorPairFiltering.html">NxUserActorPairFiltering</a> <a class="el" href="classNxScene.html#6cf0420a2cbf0873bf5b65b5f1ad1d92">getUserActorPairFiltering</a> <a class="el" href="classNxActor.html#a579d708b79eb4b52d3a1ced14659282">NxActor::resetUserActorPairFiltering</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="6731ff076b2594d44d14b734ed8c660e"></a><!-- doxytag: member="NxScene::setUserContactModify" ref="6731ff076b2594d44d14b734ed8c660e" args="(NxUserContactModify *callback)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::setUserContactModify           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classNxUserContactModify.html">NxUserContactModify</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>callback</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets a user callback object, which receives callbacks on all contacts generated for specified actors. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>Asynchronous user contact modification callback. See <a class="el" href="classNxUserContactModify.html">NxUserContactModify</a>.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes </li>
</ul>
    </td>
  </tr>
</table>
<a class="anchor" name="9d9b93fb3217760b45280735a9e5a1a3"></a><!-- doxytag: member="NxScene::setUserContactReport" ref="9d9b93fb3217760b45280735a9e5a1a3" args="(NxUserContactReport *callback)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::setUserContactReport           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classNxUserContactReport.html">NxUserContactReport</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>callback</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets a contact report object which receives collision contact events. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>User contact callback. See <a class="el" href="classNxUserContactReport.html">NxUserContactReport</a>.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxUserContactReport.html">NxUserContactReport</a> <a class="el" href="classNxScene.html#4b67e9defeb1d26f63ff02f243d7f340">getUserContactReport()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="c0b9531f514d0219651a507ae197a0a2"></a><!-- doxytag: member="NxScene::setUserNotify" ref="c0b9531f514d0219651a507ae197a0a2" args="(NxUserNotify *callback)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::setUserNotify           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classNxUserNotify.html">NxUserNotify</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>callback</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets a user notify object which receives special simulation events when they occur. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>User notification callback. See <a class="el" href="classNxUserNotify.html">NxUserNotify</a>.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxUserNotify.html">NxUserNotify</a> <a class="el" href="classNxScene.html#8a7f769f5cf233f440fb12dcc5000020">getUserNotify</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="d0e23eeeef568ff2fd6b5b538c2ce3c7"></a><!-- doxytag: member="NxScene::setUserTriggerReport" ref="d0e23eeeef568ff2fd6b5b538c2ce3c7" args="(NxUserTriggerReport *callback)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::setUserTriggerReport           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classNxUserTriggerReport.html">NxUserTriggerReport</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>callback</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets a trigger report object which receives collision trigger events. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>User trigger callback. See <a class="el" href="classNxUserTriggerReport.html">NxUserTriggerReport</a>.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxUserTriggerReport.html">NxUserTriggerReport</a> <a class="el" href="classNxScene.html#f343081b5d86e7791d7dfe480b975ed8">getUserTriggerReport()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="941e68977c4fc3d971430b721ca3fc51"></a><!-- doxytag: member="NxScene::shutdownWorkerThreads" ref="941e68977c4fc3d971430b721ca3fc51" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::shutdownWorkerThreads           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Release threads which are blocking to allow the SDK to be destroyed safely. 
<p>
Note: This also applies to SDK managed threads. So calling shutdownWorkerThreads will release all threads which are waiting using NX_WAIT_SHUTDOWN, which includes internal SDK threads.<p>
When internal threads are released by <a class="el" href="classNxScene.html#941e68977c4fc3d971430b721ca3fc51">shutdownWorkerThreads()</a> they will exit.<p>
In a typical application, the user should call shutdownWorkerThreads prior to destroying the scene. Then they will block until all user owned threads have left the API. It is then safe to release the scene.<p>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : No </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#dfda8a6ede9094e911684f4135793a41">pollForBackgroundWork()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="4016009eb8c4a82959496bdab2cea017"></a><!-- doxytag: member="NxScene::simulate" ref="4016009eb8c4a82959496bdab2cea017" args="(NxReal elapsedTime)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::simulate           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>elapsedTime</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Advances the simulation by an elapsedTime time. 
<p>
If elapsedTime is large, it is internally subdivided according to parameters provided with the <a class="el" href="classNxScene.html#3f78154dfd007fbf8b6f74884f94657d">setTiming()</a> method. See <a class="el" href="classNxScene.html#3f78154dfd007fbf8b6f74884f94657d">setTiming()</a> for a more detailed discussion of the elapsedTime parameter and time stepping behavior.<p>
Calls to <a class="el" href="classNxScene.html#4016009eb8c4a82959496bdab2cea017">simulate()</a> should pair with calls to <a class="el" href="classNxScene.html#120b86a16a1786546d73a5d22f7d1d55">fetchResults()</a>: Each <a class="el" href="classNxScene.html#120b86a16a1786546d73a5d22f7d1d55">fetchResults()</a> invocation corresponds to exactly one <a class="el" href="classNxScene.html#4016009eb8c4a82959496bdab2cea017">simulate()</a> invocation; calling <a class="el" href="classNxScene.html#4016009eb8c4a82959496bdab2cea017">simulate()</a> twice without an intervening <a class="el" href="classNxScene.html#120b86a16a1786546d73a5d22f7d1d55">fetchResults()</a> or <a class="el" href="classNxScene.html#120b86a16a1786546d73a5d22f7d1d55">fetchResults()</a> twice without an intervening <a class="el" href="classNxScene.html#4016009eb8c4a82959496bdab2cea017">simulate()</a> causes an error condition.<p>
scene-&gt;<a class="el" href="classNxScene.html#4016009eb8c4a82959496bdab2cea017">simulate()</a>; ...do some processing until physics is computed... scene-&gt;<a class="el" href="classNxScene.html#120b86a16a1786546d73a5d22f7d1d55">fetchResults()</a>; ...now results of run may be retrieved.<p>
Applications should not modify physics objects between calls to <a class="el" href="classNxScene.html#4016009eb8c4a82959496bdab2cea017">simulate()</a> and <a class="el" href="classNxScene.html#120b86a16a1786546d73a5d22f7d1d55">fetchResults()</a>;<p>
This method replaces startRun().<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>elapsedTime</em>&nbsp;</td><td>Amount of time to advance simulation by. <b>Range:</b> (0,inf)</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#120b86a16a1786546d73a5d22f7d1d55">fetchResults()</a> <a class="el" href="classNxScene.html#5b852665897d56a5f58da38b458718aa">checkResults()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="b42c1c7b5cdd7fd3c6d506607e08705c"></a><!-- doxytag: member="NxScene::unlockQueries" ref="b42c1c7b5cdd7fd3c6d506607e08705c" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxScene::unlockQueries           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Unlock parallel raycast/overlap queries. 
<p>
See <a class="el" href="classNxScene.html#f981d709d15a827f5aca98b14e77400e">lockQueries()</a> for more details.<p>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : No </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html#f981d709d15a827f5aca98b14e77400e">lockQueries()</a> </dd></dl>
    </td>
  </tr>
</table>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="2e3f19f751545ab7daf272a14320caff"></a><!-- doxytag: member="NxScene::extLink" ref="2e3f19f751545ab7daf272a14320caff" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void* <a class="el" href="classNxScene.html#2e3f19f751545ab7daf272a14320caff">NxScene::extLink</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
reserved for linkage with other Ageia components. Applications and SDK should not modify 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="d0d0d7ad66c7110490dfd791e6e259e0"></a><!-- doxytag: member="NxScene::userData" ref="d0d0d7ad66c7110490dfd791e6e259e0" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void* <a class="el" href="classNxScene.html#d0d0d7ad66c7110490dfd791e6e259e0">NxScene::userData</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
user can assign this to whatever, usually to create a 1:1 relationship with a user object. 
<p>
    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="NxScene_8h-source.html">NxScene.h</a></ul>

<hr style="width: 100%; height: 2px;"><a><br>
</a>
Copyright &copy; 2008 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</body>
</html>
