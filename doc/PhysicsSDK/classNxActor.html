<html>
<head>
<title>Physics SDK API Reference: NxActor Class Reference</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">

<LINK HREF="../stylesheet.css" REL="stylesheet" TYPE="text/css">

</head>

<body bgcolor="#FFFFFF">
<img alt="" src="images/PhysXlogo.png" align="middle"> <br>

<center>

<hr>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp;  </center>
<hr>
<!-- Generated by Doxygen 1.4.6-NO -->
<h1>NxActor Class Reference<br>
<small>
[<a class="el" href="group__physics.html">Physics</a>]</small>
</h1><!-- doxytag: class="NxActor" --><code>#include &lt;<a class="el" href="NxActor_8h-source.html">NxActor.h</a>&gt;</code>
<p>
<a href="classNxActor-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
<a class="el" href="classNxActor.html">NxActor</a> is the main simulation object in the physics SDK. 
<p>
The actor is owned by and contained in a <a class="el" href="classNxScene.html">NxScene</a>.<p>
An actor may optionally encapsulate a dynamic rigid body by setting the body member of the actor's descriptor when it is created. Otherwise the actor will be static (fixed in the world).<p>
<h3>Creation</h3>
<p>
Instances of this class are created by calling <a class="el" href="classNxScene.html#67d5aeda6c35776fd7fbf3ab43cdaaf2">NxScene::createActor()</a> and deleted with <a class="el" href="classNxScene.html#b20ab7bf376ae2238882964c2c10424e">NxScene::releaseActor()</a>.<p>
See <a class="el" href="classNxActorDescBase.html">NxActorDescBase</a> for a more detailed description of the parameters which can be set when creating an actor.<p>
Example (Static Actor):<p>
<div class="fragment"><pre class="fragment">
<span class="comment">// Create a static 'ground plane' actor.</span>
<a class="code" href="classNxPlaneShapeDesc.html">NxPlaneShapeDesc</a> planeDesc;

<a class="code" href="classNxActorDesc.html">NxActorDesc</a> actorDesc;
actorDesc.<a class="code" href="classNxActorDesc.html#af2ab4a05b5c1bf31304681d92d50864">shapes</a>.<a class="code" href="classNxArray.html#576f4b2ad6907d94811396ffe4cb3b58">pushBack</a>(&amp;planeDesc);

<a class="code" href="classNxActor.html">NxActor</a> *staticActor=gScene-&gt;createActor(actorDesc);


</pre></div><p>
Example (Dynamic Actor):<p>
<div class="fragment"><pre class="fragment"><span class="comment">// Create a dynamic 'box' actor. A dynamic actor has a non NULL body.</span>

actorDesc.<a class="code" href="group__physics.html#gf9ac3dba255dd1ab763937769c86f023">setToDefault</a>();<span class="comment">//reset to default values.</span>

<a class="code" href="classNxBodyDesc.html">NxBodyDesc</a> bodyDesc;
<a class="code" href="classNxBoxShapeDesc.html">NxBoxShapeDesc</a> boxDesc;

boxDesc.<a class="code" href="classNxBoxShapeDesc.html#856859ba5099473437603f26db081978">dimensions</a>.<a class="code" href="group__foundation.html#gdb1aeed688a311a5760f05e88d9b448e">set</a>(0.5f,0.5f,0.5f); <span class="comment">// The actor has one shape, a 1m cube.</span>
actorDesc.<a class="code" href="classNxActorDesc.html#af2ab4a05b5c1bf31304681d92d50864">shapes</a>.<a class="code" href="classNxArray.html#576f4b2ad6907d94811396ffe4cb3b58">pushBack</a>(&amp;boxDesc);

actorDesc.<a class="code" href="classNxActorDescBase.html#f2b2adaa376faa628f83b6e5b857a486">body</a> = &amp;bodyDesc;
actorDesc.<a class="code" href="classNxActorDescBase.html#b0ea9bea795de81d22ada690234b50dd">density</a> = 10;
actorDesc.<a class="code" href="classNxActorDescBase.html#346e7a6b428697eb139ce28ea30282ca">globalPose</a>.<a class="code" href="classNxMat34.html#100ef206c72ba807404b3a147783635c">t</a> = <a class="code" href="classNxVec3.html">NxVec3</a>(0.0f,10.0f,0.0f);<span class="comment">// set initial position.</span>

<a class="code" href="classNxActor.html">NxActor</a> *dynamicActor=gScene-&gt;createActor(actorDesc);   
</pre></div><p>
<h3>Visualizations</h3>
<p>
<ul>
<li><a class="el" href="group__physics.html#ggf21616f5cf8b8444c9e36705ca9865ddbfa5e2ecfcd39589558cb15b89f066b9">NX_VISUALIZE_ACTOR_AXES</a> </li>
<li><a class="el" href="group__physics.html#ggf21616f5cf8b8444c9e36705ca9865ddd90c9f5350565a102d417acb016bcfe2">NX_VISUALIZE_BODY_AXES</a> </li>
<li><a class="el" href="group__physics.html#ggf21616f5cf8b8444c9e36705ca9865dd8ffc530f8a652818782e64e88505a639">NX_VISUALIZE_BODY_MASS_AXES</a> </li>
<li><a class="el" href="group__physics.html#ggf21616f5cf8b8444c9e36705ca9865dd3b9d43cd74a75ddf8071f977cf77dfff">NX_VISUALIZE_BODY_LIN_VELOCITY</a> </li>
<li><a class="el" href="group__physics.html#ggf21616f5cf8b8444c9e36705ca9865dd0825df1d0c4dd3e7f3c36b1b8ef4110f">NX_VISUALIZE_BODY_ANG_VELOCITY</a> </li>
<li><a class="el" href="group__physics.html#ggf21616f5cf8b8444c9e36705ca9865dd60b527bc7a78cc5e8afd42f10451a893">NX_VISUALIZE_BODY_JOINT_GROUPS</a></li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActorDesc.html">NxActorDesc</a> <a class="el" href="classNxBodyDesc.html">NxBodyDesc</a> <a class="el" href="classNxScene.html#67d5aeda6c35776fd7fbf3ab43cdaaf2">NxScene.createActor()</a> <a class="el" href="classNxScene.html#b20ab7bf376ae2238882964c2c10424e">NxScene.releaseActor()</a> </dd></dl>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxScene.html">NxScene</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#62061c657183e9e50d19e16169c7d20c">getScene</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the scene which this actor belongs to.  <a href="#62061c657183e9e50d19e16169c7d20c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#4a4dd0f6459f62c9e265df94b2989aae">saveToDesc</a> (<a class="el" href="classNxActorDescBase.html">NxActorDescBase</a> &amp;desc)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Saves the state of the actor to the passed descriptor.  <a href="#4a4dd0f6459f62c9e265df94b2989aae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#2b6c86db5bb50044dcddbc8d76c1e93d">setName</a> (const char *name)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a name string for the object that can be retrieved with <a class="el" href="classNxActor.html#41d5cd1b7e48dc555fbb7dda4545aa55">getName()</a>.  <a href="#2b6c86db5bb50044dcddbc8d76c1e93d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#41d5cd1b7e48dc555fbb7dda4545aa55">getName</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the name string set with <a class="el" href="classNxActor.html#2b6c86db5bb50044dcddbc8d76c1e93d">setName()</a>.  <a href="#41d5cd1b7e48dc555fbb7dda4545aa55"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#3f2e3d34803c146d47264099cf27a7dc">setGroup</a> (<a class="el" href="group__physics.html#gd7d66f3c79185448a29cbc084ddcfefb">NxActorGroup</a> actorGroup)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns the actor to a user defined group of actors.  <a href="#3f2e3d34803c146d47264099cf27a7dc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__physics.html#gd7d66f3c79185448a29cbc084ddcfefb">NxActorGroup</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#13d0bf7a27e8870eb93e233dbb8107ec">getGroup</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the value set with <a class="el" href="classNxActor.html#3f2e3d34803c146d47264099cf27a7dc">setGroup()</a>.  <a href="#13d0bf7a27e8870eb93e233dbb8107ec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#589c806ed21ba3b8abe624e65d9c46a2">setDominanceGroup</a> (<a class="el" href="group__physics.html#gd17c09bc9705b7db96e260dffffdb381">NxDominanceGroup</a> dominanceGroup)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns dynamic actors a dominance group identifier.  <a href="#589c806ed21ba3b8abe624e65d9c46a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__physics.html#gd17c09bc9705b7db96e260dffffdb381">NxDominanceGroup</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#0809ec35a615e40824d13bf373ef3587">getDominanceGroup</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the value set with <a class="el" href="classNxActor.html#589c806ed21ba3b8abe624e65d9c46a2">setDominanceGroup()</a>.  <a href="#0809ec35a615e40824d13bf373ef3587"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#5d3d4b28d89babc607a5e913c2f9c231">raiseActorFlag</a> (<a class="el" href="group__physics.html#g842f6182bd4946039cabba84d3c8ee55">NxActorFlag</a> actorFlag)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Raises a particular actor flag.  <a href="#5d3d4b28d89babc607a5e913c2f9c231"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#ae1624ce4d7bc8c03a3ae30f97e217b6">clearActorFlag</a> (<a class="el" href="group__physics.html#g842f6182bd4946039cabba84d3c8ee55">NxActorFlag</a> actorFlag)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears a particular actor flag.  <a href="#ae1624ce4d7bc8c03a3ae30f97e217b6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#2413bc309700e33398453278691ce295">readActorFlag</a> (<a class="el" href="group__physics.html#g842f6182bd4946039cabba84d3c8ee55">NxActorFlag</a> actorFlag) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads a particular actor flag.  <a href="#2413bc309700e33398453278691ce295"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#a579d708b79eb4b52d3a1ced14659282">resetUserActorPairFiltering</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset the user actor pair filtering state for this actor. This will cause filtering callbacks to be called again for any pairs involving this actor. Use this method when you wish to change the filtering policy of an actor that may already be in contact with other actors.  <a href="#a579d708b79eb4b52d3a1ced14659282"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#348a39286d0ea72188c75e6301ee9fb9">isDynamic</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the actor is dynamic.  <a href="#348a39286d0ea72188c75e6301ee9fb9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#a2db5e21761b5edb2f159782a23ecbec">computeKineticEnergy</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the total kinetic (rotational and translational) energy of the object.  <a href="#a2db5e21761b5edb2f159782a23ecbec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#3d49c23e8a262e4f78387dda14549baa">raiseBodyFlag</a> (<a class="el" href="group__physics.html#g5b0f3262d34ee89b46e2f285d2052513">NxBodyFlag</a> bodyFlag)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Raises a particular body flag.  <a href="#3d49c23e8a262e4f78387dda14549baa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#021e9ab6e222599cffcb9095c0ad39a7">clearBodyFlag</a> (<a class="el" href="group__physics.html#g5b0f3262d34ee89b46e2f285d2052513">NxBodyFlag</a> bodyFlag)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears a particular body flag.  <a href="#021e9ab6e222599cffcb9095c0ad39a7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#d40b479de4ab975d54c5c5cc41699a66">readBodyFlag</a> (<a class="el" href="group__physics.html#g5b0f3262d34ee89b46e2f285d2052513">NxBodyFlag</a> bodyFlag) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads a particular body flag.  <a href="#d40b479de4ab975d54c5c5cc41699a66"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#504a53936be2dcc2762349ad846872dd">saveBodyToDesc</a> (<a class="el" href="classNxBodyDesc.html">NxBodyDesc</a> &amp;bodyDesc)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Saves the body information of a dynamic actor to the passed body descriptor.  <a href="#504a53936be2dcc2762349ad846872dd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#928d70f4e509322678da747de322bc26">setSolverIterationCount</a> (NxU32 iterCount)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the solver iteration count for the body.  <a href="#928d70f4e509322678da747de322bc26"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual NxU32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#d24021d2a57fef1c2c66c537b25c19a8">getSolverIterationCount</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the solver iteration count.  <a href="#d24021d2a57fef1c2c66c537b25c19a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#d744903886f3d2f817db1709f3344790">getContactReportThreshold</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the force threshold for contact reports.  <a href="#d744903886f3d2f817db1709f3344790"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#3b9af44989cb866ea5397e32bc54c3f8">setContactReportThreshold</a> (<a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a> threshold)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the force threshold for contact reports.  <a href="#3b9af44989cb866ea5397e32bc54c3f8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual NxU32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#90ebad2a4ff81c39b4bf4ceb7a6e9a7d">getContactReportFlags</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the actor's contact report flags.  <a href="#90ebad2a4ff81c39b4bf4ceb7a6e9a7d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#439d8c2044ad99e009db436f23b957bd">setContactReportFlags</a> (NxU32 flags)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the actor's contact report flags.  <a href="#439d8c2044ad99e009db436f23b957bd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual NxU32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#7c5a99bd0aa92fcd82ca0326a63003d4">linearSweep</a> (const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;motion, NxU32 flags, void *<a class="el" href="classNxActor.html#40f0b150b42d632f5646d549be95b305">userData</a>, NxU32 nbShapes, <a class="el" href="structNxSweepQueryHit.html">NxSweepQueryHit</a> *shapes, <a class="el" href="classNxUserEntityReport.html">NxUserEntityReport</a>&lt; <a class="el" href="structNxSweepQueryHit.html">NxSweepQueryHit</a> &gt; *callback, const <a class="el" href="classNxSweepCache.html">NxSweepCache</a> *sweepCache=NULL)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a linear sweep through space with the actor.  <a href="#7c5a99bd0aa92fcd82ca0326a63003d4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxCompartment.html">NxCompartment</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#660e05bec2e5c100e36461858b104750">getCompartment</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the actor's simulation compartment, if any.  <a href="#660e05bec2e5c100e36461858b104750"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__physics.html#g6a78f0087de2bc790aff345a36f7552f">NxForceFieldMaterial</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#9b799560bb12cd7ee15f77ee07d4c307">getForceFieldMaterial</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the actor's force field material index, default index is 0.  <a href="#9b799560bb12cd7ee15f77ee07d4c307"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#7b1a009bb5b57cf98e5983fffe377bb2">setForceFieldMaterial</a> (<a class="el" href="group__physics.html#g6a78f0087de2bc790aff345a36f7552f">NxForceFieldMaterial</a>)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the actor's force field material index, default index is 0.  <a href="#7b1a009bb5b57cf98e5983fffe377bb2"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Global Pose Manipulation</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#f93c356e369a3bb597d82884f1a7d093">setGlobalPose</a> (const <a class="el" href="classNxMat34.html">NxMat34</a> &amp;mat)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Methods for setting a dynamic actor's pose in the world.  <a href="#f93c356e369a3bb597d82884f1a7d093"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#4daa5f22e293c6e5285aa60f4e9f1c64">setGlobalPosition</a> (const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;vec)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a dynamic actor's position in the world.  <a href="#4daa5f22e293c6e5285aa60f4e9f1c64"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#f7a9b57b9709f7d0ce65023f69f7e56d">setGlobalOrientation</a> (const <a class="el" href="classNxMat33.html">NxMat33</a> &amp;mat)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a dynamic actor's orientation in the world.  <a href="#f7a9b57b9709f7d0ce65023f69f7e56d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#17828ae6bbd157fdce20b8182a7448c7">setGlobalOrientationQuat</a> (const <a class="el" href="classNxQuat.html">NxQuat</a> &amp;mat)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a dynamic actor's orientation in the world.  <a href="#17828ae6bbd157fdce20b8182a7448c7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxMat34.html">NxMat34</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#6b7682f757f66754c2ae09c990580729">getGlobalPose</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the actors world space transform.  <a href="#6b7682f757f66754c2ae09c990580729"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxVec3.html">NxVec3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#f81aaa2fbe517aa236acede75e241522">getGlobalPosition</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the actors world space position.  <a href="#f81aaa2fbe517aa236acede75e241522"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxMat33.html">NxMat33</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#e97d7d8704e754c9601a8a48f2163a29">getGlobalOrientation</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the actors world space orientation.  <a href="#e97d7d8704e754c9601a8a48f2163a29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxQuat.html">NxQuat</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#b0d6d60a03c4f1b139a7ce5b899282f2">getGlobalOrientationQuat</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the actors world space orientation.  <a href="#b0d6d60a03c4f1b139a7ce5b899282f2"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Kinematic Actors</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#5451ce58c1ae9fad377484dc132ce668">moveGlobalPose</a> (const <a class="el" href="classNxMat34.html">NxMat34</a> &amp;mat)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The moveGlobal* calls serve to move kinematically controlled dynamic actors through the game world.  <a href="#5451ce58c1ae9fad377484dc132ce668"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#0e867df07dc631dc212760f01bd7d45c">moveGlobalPosition</a> (const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;vec)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The moveGlobal* calls serve to move kinematically controlled dynamic actors through the game world.  <a href="#0e867df07dc631dc212760f01bd7d45c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#82282b99e9d92e5e099e14a7d8a7a17c">moveGlobalOrientation</a> (const <a class="el" href="classNxMat33.html">NxMat33</a> &amp;mat)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The moveGlobal* calls serve to move kinematically controlled dynamic actors through the game world.  <a href="#82282b99e9d92e5e099e14a7d8a7a17c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#59f9de4ef9f288dc4a2a7332930b544e">moveGlobalOrientationQuat</a> (const <a class="el" href="classNxQuat.html">NxQuat</a> &amp;quat)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The moveGlobal* calls serve to move kinematically controlled dynamic actors through the game world.  <a href="#59f9de4ef9f288dc4a2a7332930b544e"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Shapes</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxShape.html">NxShape</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#d8046d5b12fbae2fd18a3b293ea980ad">createShape</a> (const <a class="el" href="classNxShapeDesc.html">NxShapeDesc</a> &amp;desc)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new shape and adds it to the list of shapes of this actor.  <a href="#d8046d5b12fbae2fd18a3b293ea980ad"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#4f62ce88753b117a5a608a6bbe693001">releaseShape</a> (<a class="el" href="classNxShape.html">NxShape</a> &amp;shape)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes the specified shape.  <a href="#4f62ce88753b117a5a608a6bbe693001"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual NxU32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#1cb42016cbafd4a5aa2c5ff4ce63d997">getNbShapes</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of shapes assigned to the actor.  <a href="#1cb42016cbafd4a5aa2c5ff4ce63d997"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxShape.html">NxShape</a> *const *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#d83def360c7cfc2df5154c2027ee6773">getShapes</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an array of shape pointers belonging to the actor.  <a href="#d83def360c7cfc2df5154c2027ee6773"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Mass Manipulation</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#28eaedf46e44aa650a788afce1a74799">setCMassOffsetLocalPose</a> (const <a class="el" href="classNxMat34.html">NxMat34</a> &amp;mat)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The setCMassOffsetLocal*() methods set the pose of the center of mass relative to the actor.  <a href="#28eaedf46e44aa650a788afce1a74799"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#f61452dd6c0d2cada9c40596e4fd5eaa">setCMassOffsetLocalPosition</a> (const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;vec)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The setCMassOffsetLocal*() methods set the pose of the center of mass relative to the actor.  <a href="#f61452dd6c0d2cada9c40596e4fd5eaa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#e7471526cbec9e27d9738b5d970db4e1">setCMassOffsetLocalOrientation</a> (const <a class="el" href="classNxMat33.html">NxMat33</a> &amp;mat)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The setCMassOffsetLocal*() methods set the pose of the center of mass relative to the actor.  <a href="#e7471526cbec9e27d9738b5d970db4e1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#e95d79850f3bcc02883c78cc34250adc">setCMassOffsetGlobalPose</a> (const <a class="el" href="classNxMat34.html">NxMat34</a> &amp;mat)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The setCMassOffsetGlobal*() methods set the pose of the center of mass relative to world space.  <a href="#e95d79850f3bcc02883c78cc34250adc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#4aca9311911904ce9f10ad354149200e">setCMassOffsetGlobalPosition</a> (const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;vec)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The setCMassOffsetGlobal*() methods set the pose of the center of mass relative to world space.  <a href="#4aca9311911904ce9f10ad354149200e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#241a765f9ca99b4955a83a8cd84ca12f">setCMassOffsetGlobalOrientation</a> (const <a class="el" href="classNxMat33.html">NxMat33</a> &amp;mat)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The setCMassOffsetGlobal*() methods set the pose of the center of mass relative to world space.  <a href="#241a765f9ca99b4955a83a8cd84ca12f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#5bb24ff15036985025015eac64f1152e">setCMassGlobalPose</a> (const <a class="el" href="classNxMat34.html">NxMat34</a> &amp;mat)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The setCMassGlobal*() methods move the actor by setting the pose of the center of mass.  <a href="#5bb24ff15036985025015eac64f1152e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#63e168f3985047f5cb71f6a5bc9f1ebe">setCMassGlobalPosition</a> (const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;vec)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The setCMassGlobal*() methods move the actor by setting the pose of the center of mass.  <a href="#63e168f3985047f5cb71f6a5bc9f1ebe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#2b2f6cd961358096977f69904302078c">setCMassGlobalOrientation</a> (const <a class="el" href="classNxMat33.html">NxMat33</a> &amp;mat)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The setCMassGlobal*() methods move the actor by setting the pose of the center of mass.  <a href="#2b2f6cd961358096977f69904302078c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxMat34.html">NxMat34</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#9897478c423daa7ae0be40d711d72216">getCMassLocalPose</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The getCMassLocal*() methods retrieve the center of mass pose relative to the actor.  <a href="#9897478c423daa7ae0be40d711d72216"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxVec3.html">NxVec3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#28c97a79a9cbf5a0f6a79b867e99425e">getCMassLocalPosition</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The getCMassLocal*() methods retrieve the center of mass pose relative to the actor.  <a href="#28c97a79a9cbf5a0f6a79b867e99425e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxMat33.html">NxMat33</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#66b0c98f4b665bf8ed6fc2a23cd20151">getCMassLocalOrientation</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The getCMassLocal*() methods retrieve the center of mass pose relative to the actor.  <a href="#66b0c98f4b665bf8ed6fc2a23cd20151"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxMat34.html">NxMat34</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#1470497e1b04a7e5bf2a6834a9eddc31">getCMassGlobalPose</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The getCMassGlobal*() methods retrieve the center of mass pose in world space.  <a href="#1470497e1b04a7e5bf2a6834a9eddc31"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxVec3.html">NxVec3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#804fb98297766de715d2e79eeff9db9c">getCMassGlobalPosition</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The getCMassGlobal*() methods retrieve the center of mass pose in world space.  <a href="#804fb98297766de715d2e79eeff9db9c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxMat33.html">NxMat33</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#df0c2124bdc42f11ce8cfec8abbfaa30">getCMassGlobalOrientation</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The getCMassGlobal*() methods retrieve the center of mass pose in world space.  <a href="#df0c2124bdc42f11ce8cfec8abbfaa30"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#1f64986638e085cd62a82a1f029ce29f">setMass</a> (<a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a> mass)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the mass of a dynamic actor.  <a href="#1f64986638e085cd62a82a1f029ce29f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#bddfefef2f494f1592cdaee18013ed69">getMass</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the mass of the actor.  <a href="#bddfefef2f494f1592cdaee18013ed69"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#fdd5c9c2a24a326e444743d93799c3a6">setMassSpaceInertiaTensor</a> (const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;m)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the inertia tensor, using a parameter specified in mass space coordinates.  <a href="#fdd5c9c2a24a326e444743d93799c3a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxVec3.html">NxVec3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#47bf4351e368c360c598e05079e0337c">getMassSpaceInertiaTensor</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the diagonal inertia tensor of the actor relative to the mass coordinate frame.  <a href="#47bf4351e368c360c598e05079e0337c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxMat33.html">NxMat33</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#9cdddce8794823eebaf036f769c050fc">getGlobalInertiaTensor</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the inertia tensor of the actor relative to the world coordinate frame.  <a href="#9cdddce8794823eebaf036f769c050fc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxMat33.html">NxMat33</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#1778632bd8370ce8c0df159283cca97d">getGlobalInertiaTensorInverse</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the inverse of the inertia tensor of the actor relative to the world coordinate frame.  <a href="#1778632bd8370ce8c0df159283cca97d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#8949ba1c4b34408cf20c33fcbcb2016a">updateMassFromShapes</a> (<a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a> density, <a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a> totalMass)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Recomputes a dynamic actor's mass properties from its shapes.  <a href="#8949ba1c4b34408cf20c33fcbcb2016a"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Damping</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#79bc94be0beb90538460d4393854349b">setLinearDamping</a> (<a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a> linDamp)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the linear damping coefficient.  <a href="#79bc94be0beb90538460d4393854349b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#d88b80155a233e0d2f32e406acd9ec6e">getLinearDamping</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the linear damping coefficient.  <a href="#d88b80155a233e0d2f32e406acd9ec6e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#01a17cd835e78b04de9451255772a6f3">setAngularDamping</a> (<a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a> angDamp)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the angular damping coefficient.  <a href="#01a17cd835e78b04de9451255772a6f3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#112ea7c29f49719816eab0cc6a25b6f7">getAngularDamping</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the angular damping coefficient.  <a href="#112ea7c29f49719816eab0cc6a25b6f7"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Velocity</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#3109aa69b2cf09b340b622a3e4509620">setLinearVelocity</a> (const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;linVel)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the linear velocity of the actor.  <a href="#3109aa69b2cf09b340b622a3e4509620"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#7528388b02798682b09470aaa755b7b3">setAngularVelocity</a> (const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;angVel)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the angular velocity of the actor.  <a href="#7528388b02798682b09470aaa755b7b3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxVec3.html">NxVec3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#b7c9eaeae7a6363523f10c660cb19468">getLinearVelocity</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the linear velocity of an actor.  <a href="#b7c9eaeae7a6363523f10c660cb19468"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxVec3.html">NxVec3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#41ef0ee9e37b5afb52a125a2212be507">getAngularVelocity</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the angular velocity of the actor.  <a href="#41ef0ee9e37b5afb52a125a2212be507"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#b5a92000f85cad10c0fe1553dcbc1a5d">setMaxAngularVelocity</a> (<a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a> maxAngVel)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lets you set the maximum angular velocity permitted for this actor.  <a href="#b5a92000f85cad10c0fe1553dcbc1a5d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#8cbf35f56b3a36154127a8ab98950794">getMaxAngularVelocity</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the maximum angular velocity permitted for this actor.  <a href="#8cbf35f56b3a36154127a8ab98950794"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">CCD</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#aaac779605a86fc9dc91de0422f38807">setCCDMotionThreshold</a> (<a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a> thresh)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the CCD Motion Threshold.  <a href="#aaac779605a86fc9dc91de0422f38807"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#b20f5e37073cf1e692e76c0c9d44ccc1">getCCDMotionThreshold</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the CCD Motion threshold for this actor.  <a href="#b20f5e37073cf1e692e76c0c9d44ccc1"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Momentum</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#5b68e76f72476013feb078fc227a9e6a">setLinearMomentum</a> (const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;linMoment)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the linear momentum of the actor.  <a href="#5b68e76f72476013feb078fc227a9e6a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#89045d712932139196698354ad5866aa">setAngularMomentum</a> (const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;angMoment)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the angular momentum of the actor.  <a href="#89045d712932139196698354ad5866aa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxVec3.html">NxVec3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#439cad6fb757784e330b433c1aa22d57">getLinearMomentum</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the linear momentum of an actor.  <a href="#439cad6fb757784e330b433c1aa22d57"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxVec3.html">NxVec3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#d481a71c4af358963b40276222da755e">getAngularMomentum</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the angular momentum of an actor.  <a href="#d481a71c4af358963b40276222da755e"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Forces</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#4320adedfa1c5cbf88d53372bcc12e6a">addForceAtPos</a> (const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;force, const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;pos, <a class="el" href="group__physics.html#gf67abdbf9c3b48bcb59ec077213024ca">NxForceMode</a> mode=NX_FORCE, bool wakeup=true)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies a force (or impulse) defined in the global coordinate frame, acting at a particular point in global coordinates, to the actor.  <a href="#4320adedfa1c5cbf88d53372bcc12e6a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#6fb445b7baf26d820b7b40c30c4bdb95">addForceAtLocalPos</a> (const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;force, const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;pos, <a class="el" href="group__physics.html#gf67abdbf9c3b48bcb59ec077213024ca">NxForceMode</a> mode=NX_FORCE, bool wakeup=true)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies a force (or impulse) defined in the global coordinate frame, acting at a particular point in local coordinates, to the actor.  <a href="#6fb445b7baf26d820b7b40c30c4bdb95"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#7ba3cf3c324a48b7fb08549fac849a04">addLocalForceAtPos</a> (const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;force, const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;pos, <a class="el" href="group__physics.html#gf67abdbf9c3b48bcb59ec077213024ca">NxForceMode</a> mode=NX_FORCE, bool wakeup=true)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies a force (or impulse) defined in the actor local coordinate frame, acting at a particular point in global coordinates, to the actor.  <a href="#7ba3cf3c324a48b7fb08549fac849a04"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#c5d12fc5a2cccdbba4c7f582b4227bf1">addLocalForceAtLocalPos</a> (const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;force, const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;pos, <a class="el" href="group__physics.html#gf67abdbf9c3b48bcb59ec077213024ca">NxForceMode</a> mode=NX_FORCE, bool wakeup=true)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies a force (or impulse) defined in the actor local coordinate frame, acting at a particular point in local coordinates, to the actor.  <a href="#c5d12fc5a2cccdbba4c7f582b4227bf1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#850983026eff5741524ec3b99b872fc9">addForce</a> (const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;force, <a class="el" href="group__physics.html#gf67abdbf9c3b48bcb59ec077213024ca">NxForceMode</a> mode=NX_FORCE, bool wakeup=true)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies a force (or impulse) defined in the global coordinate frame to the actor.  <a href="#850983026eff5741524ec3b99b872fc9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#e346b2f47c7524fe3d546ceade9fa88e">addLocalForce</a> (const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;force, <a class="el" href="group__physics.html#gf67abdbf9c3b48bcb59ec077213024ca">NxForceMode</a> mode=NX_FORCE, bool wakeup=true)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies a force (or impulse) defined in the actor local coordinate frame to the actor.  <a href="#e346b2f47c7524fe3d546ceade9fa88e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#2ae5a1bb9fb393cfcd59e7825d76adb5">addTorque</a> (const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;torque, <a class="el" href="group__physics.html#gf67abdbf9c3b48bcb59ec077213024ca">NxForceMode</a> mode=NX_FORCE, bool wakeup=true)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies an impulsive torque defined in the global coordinate frame to the actor.  <a href="#2ae5a1bb9fb393cfcd59e7825d76adb5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#c961fb77c377c204e03d1569ba0b0c53">addLocalTorque</a> (const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;torque, <a class="el" href="group__physics.html#gf67abdbf9c3b48bcb59ec077213024ca">NxForceMode</a> mode=NX_FORCE, bool wakeup=true)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies an impulsive torque defined in the actor local coordinate frame to the actor.  <a href="#c961fb77c377c204e03d1569ba0b0c53"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Point Velocity</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxVec3.html">NxVec3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#9003453270279803f0b25b7e6919c009">getPointVelocity</a> (const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;point) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the velocity of a point given in world coordinates if it were attached to the actor and moving with it.  <a href="#9003453270279803f0b25b7e6919c009"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classNxVec3.html">NxVec3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#c92a93f8e378736d93f52373e2d418b8">getLocalPointVelocity</a> (const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;point) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the velocity of a point given in body local coordinates as if it were attached to the actor and moving with it.  <a href="#c92a93f8e378736d93f52373e2d418b8"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Sleeping</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#529efc4d1ee46a7f42da2675913600f5">isGroupSleeping</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if this body and all the actors it is touching or is linked to with joints are sleeping.  <a href="#529efc4d1ee46a7f42da2675913600f5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#d42ee1a227f0ee512837ee8a250725f4">isSleeping</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if this body is sleeping.  <a href="#d42ee1a227f0ee512837ee8a250725f4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#0fbe05f29e7c786cb56a484376b01714">getSleepLinearVelocity</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the linear velocity below which an actor may go to sleep.  <a href="#0fbe05f29e7c786cb56a484376b01714"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#4e29571507ee435c74ccda913a13888c">setSleepLinearVelocity</a> (<a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a> threshold)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the linear velocity below which an actor may go to sleep.  <a href="#4e29571507ee435c74ccda913a13888c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#d9cf5337c1ca98761f036eb6b6f5268c">getSleepAngularVelocity</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the angular velocity below which an actor may go to sleep.  <a href="#d9cf5337c1ca98761f036eb6b6f5268c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#08ba74338fa41fd7d904e4e28c629089">setSleepAngularVelocity</a> (<a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a> threshold)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the angular velocity below which an actor may go to sleep.  <a href="#08ba74338fa41fd7d904e4e28c629089"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#2e77d74a928ea62456b0156e98061ea7">getSleepEnergyThreshold</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the energy below which an actor may go to sleep.  <a href="#2e77d74a928ea62456b0156e98061ea7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#1680326ee54d224d7cbe2e373a5599ad">setSleepEnergyThreshold</a> (<a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a> threshold)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the energy threshold below which an actor may go to sleep.  <a href="#1680326ee54d224d7cbe2e373a5599ad"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#f3548981641eec58a3761331682298b7">wakeUp</a> (<a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a> wakeCounterValue=NX_SLEEP_INTERVAL)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wakes up the actor if it is sleeping.  <a href="#f3548981641eec58a3761331682298b7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#708cf737477f4787e0a4983ff391c02c">putToSleep</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Forces the actor to sleep.  <a href="#708cf737477f4787e0a4983ff391c02c"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#40f0b150b42d632f5646d549be95b305">userData</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">user can assign this to whatever, usually to create a 1:1 relationship with a user object.  <a href="#40f0b150b42d632f5646d549be95b305"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">NX_INLINE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#1bcd6fd4ddff02a8b4cda30db69f53fa">NxActor</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNxActor.html#89d6fbda6ca2ae384d7e30e40254d0c6">~NxActor</a> ()</td></tr>

</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="1bcd6fd4ddff02a8b4cda30db69f53fa"></a><!-- doxytag: member="NxActor::NxActor" ref="1bcd6fd4ddff02a8b4cda30db69f53fa" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">NX_INLINE NxActor::NxActor           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline, protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="89d6fbda6ca2ae384d7e30e40254d0c6"></a><!-- doxytag: member="NxActor::~NxActor" ref="89d6fbda6ca2ae384d7e30e40254d0c6" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual NxActor::~NxActor           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="850983026eff5741524ec3b99b872fc9"></a><!-- doxytag: member="NxActor::addForce" ref="850983026eff5741524ec3b99b872fc9" args="(const NxVec3 &amp;force, NxForceMode mode=NX_FORCE, bool wakeup=true)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::addForce           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>force</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__physics.html#gf67abdbf9c3b48bcb59ec077213024ca">NxForceMode</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>mode</em> = <code>NX_FORCE</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>wakeup</em> = <code>true</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Applies a force (or impulse) defined in the global coordinate frame to the actor. 
<p>
<b>This will not induce a torque</b>.<p>
<a class="el" href="group__physics.html#gf67abdbf9c3b48bcb59ec077213024ca">NxForceMode</a> determines if the force is to be conventional or impulsive.<p>
The actor must be dynamic.<p>
<b>Sleeping:</b> This call wakes the actor if it is sleeping and the wakeup parameter is true (default).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>force</em>&nbsp;</td><td>Force/Impulse to apply defined in the global frame. <b>Range:</b> force vector </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mode</em>&nbsp;</td><td>The mode to use when applying the force/impulse(see <a class="el" href="group__physics.html#gf67abdbf9c3b48bcb59ec077213024ca">NxForceMode</a>) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wakeup</em>&nbsp;</td><td>Specify if the call should wake up the actor.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__physics.html#gf67abdbf9c3b48bcb59ec077213024ca">NxForceMode</a> <p>
<a class="el" href="classNxActor.html#4320adedfa1c5cbf88d53372bcc12e6a">addForceAtPos()</a> <a class="el" href="classNxActor.html#6fb445b7baf26d820b7b40c30c4bdb95">addForceAtLocalPos()</a> <a class="el" href="classNxActor.html#7ba3cf3c324a48b7fb08549fac849a04">addLocalForceAtPos()</a> <a class="el" href="classNxActor.html#c5d12fc5a2cccdbba4c7f582b4227bf1">addLocalForceAtLocalPos()</a> <a class="el" href="classNxActor.html#e346b2f47c7524fe3d546ceade9fa88e">addLocalForce()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="6fb445b7baf26d820b7b40c30c4bdb95"></a><!-- doxytag: member="NxActor::addForceAtLocalPos" ref="6fb445b7baf26d820b7b40c30c4bdb95" args="(const NxVec3 &amp;force, const NxVec3 &amp;pos, NxForceMode mode=NX_FORCE, bool wakeup=true)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::addForceAtLocalPos           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>force</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__physics.html#gf67abdbf9c3b48bcb59ec077213024ca">NxForceMode</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>mode</em> = <code>NX_FORCE</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>wakeup</em> = <code>true</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Applies a force (or impulse) defined in the global coordinate frame, acting at a particular point in local coordinates, to the actor. 
<p>
Note that if the force does not act along the center of mass of the actor, this will also add the corresponding torque. Because forces are reset at the end of every timestep, you can maintain a total external force on an object by calling this once every frame.<p>
<a class="el" href="group__physics.html#gf67abdbf9c3b48bcb59ec077213024ca">NxForceMode</a> determines if the force is to be conventional or impulsive.<p>
The actor must be dynamic.<p>
<b>Sleeping:</b> This call wakes the actor if it is sleeping and the wakeup parameter is true (default).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>force</em>&nbsp;</td><td>Force/impulse to add, defined in the global frame. <b>Range:</b> force vector </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pos</em>&nbsp;</td><td>Position in the local frame to add the force at. <b>Range:</b> position vector </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mode</em>&nbsp;</td><td>The mode to use when applying the force/impulse(see <a class="el" href="group__physics.html#gf67abdbf9c3b48bcb59ec077213024ca">NxForceMode</a>) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wakeup</em>&nbsp;</td><td>Specify if the call should wake up the actor.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__physics.html#gf67abdbf9c3b48bcb59ec077213024ca">NxForceMode</a> <p>
<a class="el" href="classNxActor.html#4320adedfa1c5cbf88d53372bcc12e6a">addForceAtPos()</a> <a class="el" href="classNxActor.html#7ba3cf3c324a48b7fb08549fac849a04">addLocalForceAtPos()</a> <a class="el" href="classNxActor.html#c5d12fc5a2cccdbba4c7f582b4227bf1">addLocalForceAtLocalPos()</a> <a class="el" href="classNxActor.html#850983026eff5741524ec3b99b872fc9">addForce()</a> <a class="el" href="classNxActor.html#e346b2f47c7524fe3d546ceade9fa88e">addLocalForce()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="4320adedfa1c5cbf88d53372bcc12e6a"></a><!-- doxytag: member="NxActor::addForceAtPos" ref="4320adedfa1c5cbf88d53372bcc12e6a" args="(const NxVec3 &amp;force, const NxVec3 &amp;pos, NxForceMode mode=NX_FORCE, bool wakeup=true)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::addForceAtPos           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>force</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__physics.html#gf67abdbf9c3b48bcb59ec077213024ca">NxForceMode</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>mode</em> = <code>NX_FORCE</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>wakeup</em> = <code>true</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Applies a force (or impulse) defined in the global coordinate frame, acting at a particular point in global coordinates, to the actor. 
<p>
Note that if the force does not act along the center of mass of the actor, this will also add the corresponding torque. Because forces are reset at the end of every timestep, you can maintain a total external force on an object by calling this once every frame.<p>
<a class="el" href="group__physics.html#gf67abdbf9c3b48bcb59ec077213024ca">NxForceMode</a> determines if the force is to be conventional or impulsive.<p>
The actor must be dynamic.<p>
<b>Sleeping:</b> This call wakes the actor if it is sleeping and the wakeup parameter is true (default).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>force</em>&nbsp;</td><td>Force/impulse to add, defined in the global frame. <b>Range:</b> force vector </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pos</em>&nbsp;</td><td>Position in the global frame to add the force at. <b>Range:</b> position vector </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mode</em>&nbsp;</td><td>The mode to use when applying the force/impulse(see <a class="el" href="group__physics.html#gf67abdbf9c3b48bcb59ec077213024ca">NxForceMode</a>) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wakeup</em>&nbsp;</td><td>Specify if the call should wake up the actor.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__physics.html#gf67abdbf9c3b48bcb59ec077213024ca">NxForceMode</a> <p>
<a class="el" href="classNxActor.html#6fb445b7baf26d820b7b40c30c4bdb95">addForceAtLocalPos()</a> <a class="el" href="classNxActor.html#7ba3cf3c324a48b7fb08549fac849a04">addLocalForceAtPos()</a> <a class="el" href="classNxActor.html#c5d12fc5a2cccdbba4c7f582b4227bf1">addLocalForceAtLocalPos()</a> <a class="el" href="classNxActor.html#850983026eff5741524ec3b99b872fc9">addForce()</a> <a class="el" href="classNxActor.html#e346b2f47c7524fe3d546ceade9fa88e">addLocalForce()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="e346b2f47c7524fe3d546ceade9fa88e"></a><!-- doxytag: member="NxActor::addLocalForce" ref="e346b2f47c7524fe3d546ceade9fa88e" args="(const NxVec3 &amp;force, NxForceMode mode=NX_FORCE, bool wakeup=true)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::addLocalForce           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>force</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__physics.html#gf67abdbf9c3b48bcb59ec077213024ca">NxForceMode</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>mode</em> = <code>NX_FORCE</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>wakeup</em> = <code>true</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Applies a force (or impulse) defined in the actor local coordinate frame to the actor. 
<p>
<b>This will not induce a torque</b>.<p>
<a class="el" href="group__physics.html#gf67abdbf9c3b48bcb59ec077213024ca">NxForceMode</a> determines if the force is to be conventional or impulsive.<p>
The actor must be dynamic.<p>
<b>Sleeping:</b> This call wakes the actor if it is sleeping and the wakeup parameter is true (default).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>force</em>&nbsp;</td><td>Force/Impulse to apply defined in the local frame. <b>Range:</b> force vector </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mode</em>&nbsp;</td><td>The mode to use when applying the force/impulse(see <a class="el" href="group__physics.html#gf67abdbf9c3b48bcb59ec077213024ca">NxForceMode</a>) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wakeup</em>&nbsp;</td><td>Specify if the call should wake up the actor.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__physics.html#gf67abdbf9c3b48bcb59ec077213024ca">NxForceMode</a> <p>
<a class="el" href="classNxActor.html#4320adedfa1c5cbf88d53372bcc12e6a">addForceAtPos()</a> <a class="el" href="classNxActor.html#6fb445b7baf26d820b7b40c30c4bdb95">addForceAtLocalPos()</a> <a class="el" href="classNxActor.html#7ba3cf3c324a48b7fb08549fac849a04">addLocalForceAtPos()</a> <a class="el" href="classNxActor.html#c5d12fc5a2cccdbba4c7f582b4227bf1">addLocalForceAtLocalPos()</a> <a class="el" href="classNxActor.html#850983026eff5741524ec3b99b872fc9">addForce()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="c5d12fc5a2cccdbba4c7f582b4227bf1"></a><!-- doxytag: member="NxActor::addLocalForceAtLocalPos" ref="c5d12fc5a2cccdbba4c7f582b4227bf1" args="(const NxVec3 &amp;force, const NxVec3 &amp;pos, NxForceMode mode=NX_FORCE, bool wakeup=true)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::addLocalForceAtLocalPos           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>force</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__physics.html#gf67abdbf9c3b48bcb59ec077213024ca">NxForceMode</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>mode</em> = <code>NX_FORCE</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>wakeup</em> = <code>true</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Applies a force (or impulse) defined in the actor local coordinate frame, acting at a particular point in local coordinates, to the actor. 
<p>
Note that if the force does not act along the center of mass of the actor, this will also add the corresponding torque. Because forces are reset at the end of every timestep, you can maintain a total external force on an object by calling this once every frame.<p>
<a class="el" href="group__physics.html#gf67abdbf9c3b48bcb59ec077213024ca">NxForceMode</a> determines if the force is to be conventional or impulsive.<p>
The actor must be dynamic.<p>
<b>Sleeping:</b> This call wakes the actor if it is sleeping and the wakeup parameter is true (default).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>force</em>&nbsp;</td><td>Force/impulse to add, defined in the local frame. <b>Range:</b> force vector </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pos</em>&nbsp;</td><td>Position in the local frame to add the force at. <b>Range:</b> position vector </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mode</em>&nbsp;</td><td>The mode to use when applying the force/impulse(see <a class="el" href="group__physics.html#gf67abdbf9c3b48bcb59ec077213024ca">NxForceMode</a>) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wakeup</em>&nbsp;</td><td>Specify if the call should wake up the actor.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__physics.html#gf67abdbf9c3b48bcb59ec077213024ca">NxForceMode</a> <p>
<a class="el" href="classNxActor.html#4320adedfa1c5cbf88d53372bcc12e6a">addForceAtPos()</a> <a class="el" href="classNxActor.html#6fb445b7baf26d820b7b40c30c4bdb95">addForceAtLocalPos()</a> <a class="el" href="classNxActor.html#7ba3cf3c324a48b7fb08549fac849a04">addLocalForceAtPos()</a> <a class="el" href="classNxActor.html#850983026eff5741524ec3b99b872fc9">addForce()</a> <a class="el" href="classNxActor.html#e346b2f47c7524fe3d546ceade9fa88e">addLocalForce()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="7ba3cf3c324a48b7fb08549fac849a04"></a><!-- doxytag: member="NxActor::addLocalForceAtPos" ref="7ba3cf3c324a48b7fb08549fac849a04" args="(const NxVec3 &amp;force, const NxVec3 &amp;pos, NxForceMode mode=NX_FORCE, bool wakeup=true)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::addLocalForceAtPos           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>force</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__physics.html#gf67abdbf9c3b48bcb59ec077213024ca">NxForceMode</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>mode</em> = <code>NX_FORCE</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>wakeup</em> = <code>true</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Applies a force (or impulse) defined in the actor local coordinate frame, acting at a particular point in global coordinates, to the actor. 
<p>
Note that if the force does not act along the center of mass of the actor, this will also add the corresponding torque. Because forces are reset at the end of every timestep, you can maintain a total external force on an object by calling this once every frame.<p>
<a class="el" href="group__physics.html#gf67abdbf9c3b48bcb59ec077213024ca">NxForceMode</a> determines if the force is to be conventional or impulsive.<p>
The actor must be dynamic.<p>
<b>Sleeping:</b> This call wakes the actor if it is sleeping and the wakeup parameter is true (default).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>force</em>&nbsp;</td><td>Force/impulse to add, defined in the local frame. <b>Range:</b> force vector </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pos</em>&nbsp;</td><td>Position in the global frame to add the force at. <b>Range:</b> position vector </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mode</em>&nbsp;</td><td>The mode to use when applying the force/impulse(see <a class="el" href="group__physics.html#gf67abdbf9c3b48bcb59ec077213024ca">NxForceMode</a>) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wakeup</em>&nbsp;</td><td>Specify if the call should wake up the actor.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__physics.html#gf67abdbf9c3b48bcb59ec077213024ca">NxForceMode</a> <p>
<a class="el" href="classNxActor.html#4320adedfa1c5cbf88d53372bcc12e6a">addForceAtPos()</a> <a class="el" href="classNxActor.html#6fb445b7baf26d820b7b40c30c4bdb95">addForceAtLocalPos()</a> <a class="el" href="classNxActor.html#c5d12fc5a2cccdbba4c7f582b4227bf1">addLocalForceAtLocalPos()</a> <a class="el" href="classNxActor.html#850983026eff5741524ec3b99b872fc9">addForce()</a> <a class="el" href="classNxActor.html#e346b2f47c7524fe3d546ceade9fa88e">addLocalForce()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="c961fb77c377c204e03d1569ba0b0c53"></a><!-- doxytag: member="NxActor::addLocalTorque" ref="c961fb77c377c204e03d1569ba0b0c53" args="(const NxVec3 &amp;torque, NxForceMode mode=NX_FORCE, bool wakeup=true)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::addLocalTorque           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>torque</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__physics.html#gf67abdbf9c3b48bcb59ec077213024ca">NxForceMode</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>mode</em> = <code>NX_FORCE</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>wakeup</em> = <code>true</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Applies an impulsive torque defined in the actor local coordinate frame to the actor. 
<p>
<a class="el" href="group__physics.html#gf67abdbf9c3b48bcb59ec077213024ca">NxForceMode</a> determines if the torque is to be conventional or impulsive.<p>
The actor must be dynamic.<p>
<b>Sleeping:</b> This call wakes the actor if it is sleeping and the wakeup parameter is true (default).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>torque</em>&nbsp;</td><td>Torque to apply defined in the local frame. <b>Range:</b> torque vector </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mode</em>&nbsp;</td><td>The mode to use when applying the force/impulse(see <a class="el" href="group__physics.html#gf67abdbf9c3b48bcb59ec077213024ca">NxForceMode</a>). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wakeup</em>&nbsp;</td><td>Specify if the call should wake up the actor.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__physics.html#gf67abdbf9c3b48bcb59ec077213024ca">NxForceMode</a> <a class="el" href="classNxActor.html#2ae5a1bb9fb393cfcd59e7825d76adb5">addTorque()</a> <a class="el" href="classNxActor.html#850983026eff5741524ec3b99b872fc9">addForce()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="2ae5a1bb9fb393cfcd59e7825d76adb5"></a><!-- doxytag: member="NxActor::addTorque" ref="2ae5a1bb9fb393cfcd59e7825d76adb5" args="(const NxVec3 &amp;torque, NxForceMode mode=NX_FORCE, bool wakeup=true)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::addTorque           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>torque</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__physics.html#gf67abdbf9c3b48bcb59ec077213024ca">NxForceMode</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>mode</em> = <code>NX_FORCE</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>wakeup</em> = <code>true</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Applies an impulsive torque defined in the global coordinate frame to the actor. 
<p>
<a class="el" href="group__physics.html#gf67abdbf9c3b48bcb59ec077213024ca">NxForceMode</a> determines if the torque is to be conventional or impulsive.<p>
The actor must be dynamic.<p>
<b>Sleeping:</b> This call wakes the actor if it is sleeping and the wakeup parameter is true (default).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>torque</em>&nbsp;</td><td>Torque to apply defined in the global frame. <b>Range:</b> torque vector </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mode</em>&nbsp;</td><td>The mode to use when applying the force/impulse(see <a class="el" href="group__physics.html#gf67abdbf9c3b48bcb59ec077213024ca">NxForceMode</a>). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wakeup</em>&nbsp;</td><td>Specify if the call should wake up the actor.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__physics.html#gf67abdbf9c3b48bcb59ec077213024ca">NxForceMode</a> <a class="el" href="classNxActor.html#c961fb77c377c204e03d1569ba0b0c53">addLocalTorque()</a> <a class="el" href="classNxActor.html#850983026eff5741524ec3b99b872fc9">addForce()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ae1624ce4d7bc8c03a3ae30f97e217b6"></a><!-- doxytag: member="NxActor::clearActorFlag" ref="ae1624ce4d7bc8c03a3ae30f97e217b6" args="(NxActorFlag actorFlag)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::clearActorFlag           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__physics.html#g842f6182bd4946039cabba84d3c8ee55">NxActorFlag</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>actorFlag</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Clears a particular actor flag. 
<p>
See the list of flags <a class="el" href="group__physics.html#g842f6182bd4946039cabba84d3c8ee55">NxActorFlag</a><p>
<b>Sleeping:</b> Does <b>NOT</b> wake the actor up automatically.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actorFlag</em>&nbsp;</td><td>The actor flag to clear. See <a class="el" href="group__physics.html#g842f6182bd4946039cabba84d3c8ee55">NxActorFlag</a>.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__physics.html#g842f6182bd4946039cabba84d3c8ee55">NxActorFlag</a> <a class="el" href="classNxActor.html#5d3d4b28d89babc607a5e913c2f9c231">raiseActorFlag()</a> <a class="el" href="classNxActor.html#2413bc309700e33398453278691ce295">readActorFlag()</a> <a class="el" href="classNxActorDescBase.html#d28bfce0c84155afad39ef95d31e8667">NxActorDesc.flags</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="021e9ab6e222599cffcb9095c0ad39a7"></a><!-- doxytag: member="NxActor::clearBodyFlag" ref="021e9ab6e222599cffcb9095c0ad39a7" args="(NxBodyFlag bodyFlag)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::clearBodyFlag           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__physics.html#g5b0f3262d34ee89b46e2f285d2052513">NxBodyFlag</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>bodyFlag</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Clears a particular body flag. 
<p>
See <a class="el" href="group__physics.html#g5b0f3262d34ee89b46e2f285d2052513">NxBodyFlag</a> for a list of flags.<p>
The actor must be dynamic.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bodyFlag</em>&nbsp;</td><td>Body flag to clear. See <a class="el" href="group__physics.html#g5b0f3262d34ee89b46e2f285d2052513">NxBodyFlag</a>.</td></tr>
  </table>
</dl>
Sleeping: Does NOT wake the actor up automatically.<p>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Partial (supports NX_BF_KINEMATIC, NX_BF_DISABLE_GRAVITY) </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__physics.html#g5b0f3262d34ee89b46e2f285d2052513">NxBodyFlag</a> <a class="el" href="classNxActor.html#3d49c23e8a262e4f78387dda14549baa">raiseBodyFlag()</a> <a class="el" href="classNxActor.html#d40b479de4ab975d54c5c5cc41699a66">readBodyFlag()</a> <a class="el" href="classNxBodyDesc.html#ee23f13dce74a198c7a91fc0ac12f01e">NxBodyDesc.flags</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a2db5e21761b5edb2f159782a23ecbec"></a><!-- doxytag: member="NxActor::computeKineticEnergy" ref="a2db5e21761b5edb2f159782a23ecbec" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a> NxActor::computeKineticEnergy           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Computes the total kinetic (rotational and translational) energy of the object. 
<p>
The actor must be dynamic.<p>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>Returns:</b></dt><dd>The kinetic energy of the actor. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="d8046d5b12fbae2fd18a3b293ea980ad"></a><!-- doxytag: member="NxActor::createShape" ref="d8046d5b12fbae2fd18a3b293ea980ad" args="(const NxShapeDesc &amp;desc)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxShape.html">NxShape</a>* NxActor::createShape           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxShapeDesc.html">NxShapeDesc</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>desc</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a new shape and adds it to the list of shapes of this actor. 
<p>
This invalidates the pointer returned by <a class="el" href="classNxActor.html#d83def360c7cfc2df5154c2027ee6773">getShapes()</a>.<p>
<dl compact><dt><b>Note:</b></dt><dd>Mass properties of dynamic actors will not automatically be recomputed to reflect the new mass distribution implied by the shape. Follow this call with a call to <a class="el" href="classNxActor.html#8949ba1c4b34408cf20c33fcbcb2016a">updateMassFromShapes()</a> to do that.<p>
Creating compounds with a very large number of shapes may adversly affect performance and stability. When performing collision tests between a pair of actors containing multiple shapes, a collision check is performed between each pair of shapes. This results in N^2 running time.</dd></dl>
<b>Sleeping:</b> Does <b>NOT</b> wake the actor up automatically.<p>
Only a subset of the shape types are supported in hardware scenes (others will fall back to running in software):-<p>
Fluids:<p>
<ul>
<li>Compounds are supported </li>
<li><a class="el" href="classNxBoxShape.html">NxBoxShape</a> </li>
<li><a class="el" href="classNxCapsuleShape.html">NxCapsuleShape</a> </li>
<li><a class="el" href="classNxSphereShape.html">NxSphereShape</a> </li>
<li><a class="el" href="classNxConvexShape.html">NxConvexShape</a></li>
</ul>
Hardware Rigid bodies:<p>
<ul>
<li>Compounds are supported </li>
<li><a class="el" href="classNxBoxShape.html">NxBoxShape</a> </li>
<li><a class="el" href="classNxSphereShape.html">NxSphereShape</a> </li>
<li><a class="el" href="classNxCapsuleShape.html">NxCapsuleShape</a> </li>
<li><a class="el" href="classNxConvexShape.html">NxConvexShape</a> (software fallback for &gt; 32 vertices or faces) </li>
<li><a class="el" href="classNxTriangleMeshShape.html">NxTriangleMeshShape</a> </li>
<li><a class="el" href="classNxPlaneShape.html">NxPlaneShape</a></li>
</ul>
In addition mesh pages must be mapped into PPU memory for hardware scenes. No collision detection will be performed with portions of the mesh which have not been mapped to PPU memory. See <a class="el" href="classNxTriangleMeshShape.html#fa27416b71436fe29a55d8990dbadf0f">NxTriangleMeshShape.mapPageInstance()</a><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>The descriptor for the new shape. See e.g. <a class="el" href="classNxSphereShapeDesc.html">NxSphereShapeDesc</a>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The newly create shape.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes (Software fallback in some cases) </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxShape.html">NxShape</a> <a class="el" href="classNxShapeDesc.html">NxShapeDesc</a> <p>
<a class="el" href="classNxBoxShape.html">NxBoxShape</a> <a class="el" href="classNxCapsuleShape.html">NxCapsuleShape</a> <a class="el" href="classNxConvexShape.html">NxConvexShape</a> <a class="el" href="classNxPlaneShape.html">NxPlaneShape</a> <a class="el" href="classNxSphereShape.html">NxSphereShape</a> <a class="el" href="classNxTriangleMeshShape.html">NxTriangleMeshShape</a> <a class="el" href="classNxWheelShape.html">NxWheelShape</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="112ea7c29f49719816eab0cc6a25b6f7"></a><!-- doxytag: member="NxActor::getAngularDamping" ref="112ea7c29f49719816eab0cc6a25b6f7" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a> NxActor::getAngularDamping           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the angular damping coefficient. 
<p>
The actor must be dynamic.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The angular damping coefficient associated with this actor.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#01a17cd835e78b04de9451255772a6f3">setAngularDamping()</a> <a class="el" href="classNxBodyDesc.html#351a711ee84d0f69f5c0ed1337b300ba">NxBodyDesc.angularDamping</a> <a class="el" href="classNxActor.html#d88b80155a233e0d2f32e406acd9ec6e">getLinearDamping()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="d481a71c4af358963b40276222da755e"></a><!-- doxytag: member="NxActor::getAngularMomentum" ref="d481a71c4af358963b40276222da755e" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxVec3.html">NxVec3</a> NxActor::getAngularMomentum           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the angular momentum of an actor. 
<p>
The angular momentum is equal to the angular velocity times the global space inertia tensor.<p>
The actor must be dynamic.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The angular momentum for the actor.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#89045d712932139196698354ad5866aa">setAngularMomentum()</a> <a class="el" href="classNxActor.html#439cad6fb757784e330b433c1aa22d57">getLinearMomentum()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="41ef0ee9e37b5afb52a125a2212be507"></a><!-- doxytag: member="NxActor::getAngularVelocity" ref="41ef0ee9e37b5afb52a125a2212be507" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxVec3.html">NxVec3</a> NxActor::getAngularVelocity           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the angular velocity of the actor. 
<p>
The actor must be dynamic.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The angular velocity of the actor.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#7528388b02798682b09470aaa755b7b3">setAngularVelocity()</a> <a class="el" href="classNxActor.html#b7c9eaeae7a6363523f10c660cb19468">getLinearVelocity()</a> <a class="el" href="classNxBodyDesc.html#95336965da3939b862dd3f7b2e7c1101">NxBodyDesc.angularVelocity</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="b20f5e37073cf1e692e76c0c9d44ccc1"></a><!-- doxytag: member="NxActor::getCCDMotionThreshold" ref="b20f5e37073cf1e692e76c0c9d44ccc1" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a> NxActor::getCCDMotionThreshold           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the CCD Motion threshold for this actor. 
<p>
The actor must be dynamic.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The CCD threshold for the actor.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#aaac779605a86fc9dc91de0422f38807">setCCDMotionThreshold</a> <a class="el" href="group__physics.html#gf21616f5cf8b8444c9e36705ca9865dd">NxParameter</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="df0c2124bdc42f11ce8cfec8abbfaa30"></a><!-- doxytag: member="NxActor::getCMassGlobalOrientation" ref="df0c2124bdc42f11ce8cfec8abbfaa30" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxMat33.html">NxMat33</a> NxActor::getCMassGlobalOrientation           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The getCMassGlobal*() methods retrieve the center of mass pose in world space. 
<p>
The actor must be dynamic.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The orientation of the mass frame relative to the global frame.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#1470497e1b04a7e5bf2a6834a9eddc31">getCMassGlobalPose()</a> <a class="el" href="classNxActor.html#804fb98297766de715d2e79eeff9db9c">getCMassGlobalPosition()</a> <a class="el" href="classNxActor.html#9897478c423daa7ae0be40d711d72216">getCMassLocalPose()</a> <p>
<a class="el" href="classNxBodyDesc.html#45fedd6e30ac62fe66ce4a42db2514e1">NxBodyDesc.massLocalPose</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="1470497e1b04a7e5bf2a6834a9eddc31"></a><!-- doxytag: member="NxActor::getCMassGlobalPose" ref="1470497e1b04a7e5bf2a6834a9eddc31" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxMat34.html">NxMat34</a> NxActor::getCMassGlobalPose           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The getCMassGlobal*() methods retrieve the center of mass pose in world space. 
<p>
The actor must be dynamic.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The Mass transform for this actor relative to the global frame.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#804fb98297766de715d2e79eeff9db9c">getCMassGlobalPosition()</a> <a class="el" href="classNxActor.html#df0c2124bdc42f11ce8cfec8abbfaa30">getCMassGlobalOrientation()</a> <a class="el" href="classNxActor.html#9897478c423daa7ae0be40d711d72216">getCMassLocalPose()</a> <p>
<a class="el" href="classNxBodyDesc.html#45fedd6e30ac62fe66ce4a42db2514e1">NxBodyDesc.massLocalPose</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="804fb98297766de715d2e79eeff9db9c"></a><!-- doxytag: member="NxActor::getCMassGlobalPosition" ref="804fb98297766de715d2e79eeff9db9c" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxVec3.html">NxVec3</a> NxActor::getCMassGlobalPosition           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The getCMassGlobal*() methods retrieve the center of mass pose in world space. 
<p>
The actor must be dynamic.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The position of the center of mass relative to the global frame.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#1470497e1b04a7e5bf2a6834a9eddc31">getCMassGlobalPose()</a> <a class="el" href="classNxActor.html#df0c2124bdc42f11ce8cfec8abbfaa30">getCMassGlobalOrientation()</a> <a class="el" href="classNxActor.html#9897478c423daa7ae0be40d711d72216">getCMassLocalPose()</a> <p>
<a class="el" href="classNxBodyDesc.html#45fedd6e30ac62fe66ce4a42db2514e1">NxBodyDesc.massLocalPose</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="66b0c98f4b665bf8ed6fc2a23cd20151"></a><!-- doxytag: member="NxActor::getCMassLocalOrientation" ref="66b0c98f4b665bf8ed6fc2a23cd20151" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxMat33.html">NxMat33</a> NxActor::getCMassLocalOrientation           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The getCMassLocal*() methods retrieve the center of mass pose relative to the actor. 
<p>
The actor must be dynamic.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The mass orientation relative to the actors frame.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#9897478c423daa7ae0be40d711d72216">getCMassLocalPose()</a> <a class="el" href="classNxActor.html#28c97a79a9cbf5a0f6a79b867e99425e">getCMassLocalPosition()</a> <a class="el" href="classNxActor.html#1470497e1b04a7e5bf2a6834a9eddc31">getCMassGlobalPose()</a> <p>
<a class="el" href="classNxBodyDesc.html#45fedd6e30ac62fe66ce4a42db2514e1">NxBodyDesc.massLocalPose</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="9897478c423daa7ae0be40d711d72216"></a><!-- doxytag: member="NxActor::getCMassLocalPose" ref="9897478c423daa7ae0be40d711d72216" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxMat34.html">NxMat34</a> NxActor::getCMassLocalPose           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The getCMassLocal*() methods retrieve the center of mass pose relative to the actor. 
<p>
The actor must be dynamic.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The center of mass pose relative to the actor.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#28c97a79a9cbf5a0f6a79b867e99425e">getCMassLocalPosition()</a> <a class="el" href="classNxActor.html#66b0c98f4b665bf8ed6fc2a23cd20151">getCMassLocalOrientation()</a> <a class="el" href="classNxActor.html#1470497e1b04a7e5bf2a6834a9eddc31">getCMassGlobalPose()</a> <p>
<a class="el" href="classNxBodyDesc.html#45fedd6e30ac62fe66ce4a42db2514e1">NxBodyDesc.massLocalPose</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="28c97a79a9cbf5a0f6a79b867e99425e"></a><!-- doxytag: member="NxActor::getCMassLocalPosition" ref="28c97a79a9cbf5a0f6a79b867e99425e" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxVec3.html">NxVec3</a> NxActor::getCMassLocalPosition           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The getCMassLocal*() methods retrieve the center of mass pose relative to the actor. 
<p>
The actor must be dynamic.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The center of mass position relative to the actor.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#9897478c423daa7ae0be40d711d72216">getCMassLocalPose()</a> <a class="el" href="classNxActor.html#66b0c98f4b665bf8ed6fc2a23cd20151">getCMassLocalOrientation()</a> <a class="el" href="classNxActor.html#1470497e1b04a7e5bf2a6834a9eddc31">getCMassGlobalPose()</a> <p>
<a class="el" href="classNxBodyDesc.html#45fedd6e30ac62fe66ce4a42db2514e1">NxBodyDesc.massLocalPose</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="660e05bec2e5c100e36461858b104750"></a><!-- doxytag: member="NxActor::getCompartment" ref="660e05bec2e5c100e36461858b104750" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxCompartment.html">NxCompartment</a>* NxActor::getCompartment           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the actor's simulation compartment, if any. 
<p>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxCompartment.html">NxCompartment</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="90ebad2a4ff81c39b4bf4ceb7a6e9a7d"></a><!-- doxytag: member="NxActor::getContactReportFlags" ref="90ebad2a4ff81c39b4bf4ceb7a6e9a7d" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual NxU32 NxActor::getContactReportFlags           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the actor's contact report flags. 
<p>
See <a class="el" href="classNxActor.html#439d8c2044ad99e009db436f23b957bd">setContactReportFlags()</a>.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The contact reporting flags associated with this actor.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#439d8c2044ad99e009db436f23b957bd">setContactReportFlags</a> <a class="el" href="group__physics.html#g05983d9ea71be115e74f0a5d6a7559cc">NxContactPairFlag</a> <a class="el" href="classNxActorDescBase.html#ce34b0242412943ef6864c2ac54c6e64">NxActorDesc::contactReportFlags</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="d744903886f3d2f817db1709f3344790"></a><!-- doxytag: member="NxActor::getContactReportThreshold" ref="d744903886f3d2f817db1709f3344790" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a> NxActor::getContactReportThreshold           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the force threshold for contact reports. 
<p>
The contact report threshold is a force threshold. If the force between two actors exceeds this threshold for either of the two actors, a contact report will be generated according to the union of both actors' contact report threshold flags. See <a class="el" href="classNxActor.html#90ebad2a4ff81c39b4bf4ceb7a6e9a7d">getContactReportFlags()</a>.<p>
The actor must be dynamic. The threshold used for a collision between a dynamic actor and the static environment is the threshold of the dynamic actor, and all contacts with static actors are summed to find the total normal force.<p>
<dl compact><dt><b>Returns:</b></dt><dd>Force threshold for contact reports.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#3b9af44989cb866ea5397e32bc54c3f8">setContactReportThreshold</a> <a class="el" href="classNxActor.html#90ebad2a4ff81c39b4bf4ceb7a6e9a7d">getContactReportFlags</a> <a class="el" href="group__physics.html#g05983d9ea71be115e74f0a5d6a7559cc">NxContactPairFlag</a> <a class="el" href="classNxBodyDesc.html#f019d3ffb7e762719c16d9f6127cdfc3">NxBodyDesc::contactReportThreshold</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="0809ec35a615e40824d13bf373ef3587"></a><!-- doxytag: member="NxActor::getDominanceGroup" ref="0809ec35a615e40824d13bf373ef3587" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="group__physics.html#gd17c09bc9705b7db96e260dffffdb381">NxDominanceGroup</a> NxActor::getDominanceGroup           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the value set with <a class="el" href="classNxActor.html#589c806ed21ba3b8abe624e65d9c46a2">setDominanceGroup()</a>. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The dominance group of this actor.</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#589c806ed21ba3b8abe624e65d9c46a2">setDominanceGroup()</a> <a class="el" href="group__physics.html#gd17c09bc9705b7db96e260dffffdb381">NxDominanceGroup</a> <a class="el" href="classNxScene.html#b3a23eb788d2c6e290e3d14d8d5a2a79">NxScene::setDominanceGroupPair()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="9b799560bb12cd7ee15f77ee07d4c307"></a><!-- doxytag: member="NxActor::getForceFieldMaterial" ref="9b799560bb12cd7ee15f77ee07d4c307" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="group__physics.html#g6a78f0087de2bc790aff345a36f7552f">NxForceFieldMaterial</a> NxActor::getForceFieldMaterial           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the actor's force field material index, default index is 0. 
<p>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes [SW fallback] </li>
<li>PS3 : Yes </li>
<li>XB360: Yes </li>
</ul>
    </td>
  </tr>
</table>
<a class="anchor" name="9cdddce8794823eebaf036f769c050fc"></a><!-- doxytag: member="NxActor::getGlobalInertiaTensor" ref="9cdddce8794823eebaf036f769c050fc" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxMat33.html">NxMat33</a> NxActor::getGlobalInertiaTensor           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the inertia tensor of the actor relative to the world coordinate frame. 
<p>
The actor must be dynamic.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The global frame inertia tensor of this actor.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#1778632bd8370ce8c0df159283cca97d">getGlobalInertiaTensorInverse()</a> <a class="el" href="classNxBodyDesc.html#df34de0163d0d8825513c2f8da30b47a">NxBodyDesc.massSpaceInertia</a> <a class="el" href="classNxActor.html#fdd5c9c2a24a326e444743d93799c3a6">setMassSpaceInertiaTensor()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="1778632bd8370ce8c0df159283cca97d"></a><!-- doxytag: member="NxActor::getGlobalInertiaTensorInverse" ref="1778632bd8370ce8c0df159283cca97d" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxMat33.html">NxMat33</a> NxActor::getGlobalInertiaTensorInverse           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the inverse of the inertia tensor of the actor relative to the world coordinate frame. 
<p>
The actor must be dynamic.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The inverse of the inertia tensor in the global frame.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#9cdddce8794823eebaf036f769c050fc">getGlobalInertiaTensor()</a> <a class="el" href="classNxBodyDesc.html#df34de0163d0d8825513c2f8da30b47a">NxBodyDesc.massSpaceInertia</a> <a class="el" href="classNxActor.html#fdd5c9c2a24a326e444743d93799c3a6">setMassSpaceInertiaTensor()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="e97d7d8704e754c9601a8a48f2163a29"></a><!-- doxytag: member="NxActor::getGlobalOrientation" ref="e97d7d8704e754c9601a8a48f2163a29" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxMat33.html">NxMat33</a> NxActor::getGlobalOrientation           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the actors world space orientation. 
<p>
The getGlobal*() methods retrieve the actor's current actor space to world space transformation.<p>
<dl compact><dt><b>Returns:</b></dt><dd>Global orientation of object.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#b0d6d60a03c4f1b139a7ce5b899282f2">getGlobalOrientationQuat()</a> <a class="el" href="classNxActor.html#f7a9b57b9709f7d0ce65023f69f7e56d">setGlobalOrientation()</a> <a class="el" href="classNxActor.html#6b7682f757f66754c2ae09c990580729">getGlobalPose()</a> <a class="el" href="classNxActor.html#f81aaa2fbe517aa236acede75e241522">getGlobalPosition()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="b0d6d60a03c4f1b139a7ce5b899282f2"></a><!-- doxytag: member="NxActor::getGlobalOrientationQuat" ref="b0d6d60a03c4f1b139a7ce5b899282f2" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxQuat.html">NxQuat</a> NxActor::getGlobalOrientationQuat           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the actors world space orientation. 
<p>
The getGlobal*() methods retrieve the actor's current actor space to world space transformation.<p>
<dl compact><dt><b>Returns:</b></dt><dd>Global orientation of the actor as a quaternion.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#e97d7d8704e754c9601a8a48f2163a29">getGlobalOrientation()</a> <a class="el" href="classNxActor.html#f7a9b57b9709f7d0ce65023f69f7e56d">setGlobalOrientation()</a> <a class="el" href="classNxActor.html#6b7682f757f66754c2ae09c990580729">getGlobalPose()</a> <a class="el" href="classNxActor.html#f81aaa2fbe517aa236acede75e241522">getGlobalPosition()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="6b7682f757f66754c2ae09c990580729"></a><!-- doxytag: member="NxActor::getGlobalPose" ref="6b7682f757f66754c2ae09c990580729" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxMat34.html">NxMat34</a> NxActor::getGlobalPose           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the actors world space transform. 
<p>
The getGlobal*() methods retrieve the actor's current actor space to world space transformation.<p>
<dl compact><dt><b>Returns:</b></dt><dd>Global pose matrix of object.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#f93c356e369a3bb597d82884f1a7d093">setGlobalPose()</a> <a class="el" href="classNxActor.html#f81aaa2fbe517aa236acede75e241522">getGlobalPosition()</a> <a class="el" href="classNxActor.html#e97d7d8704e754c9601a8a48f2163a29">getGlobalOrientation()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="f81aaa2fbe517aa236acede75e241522"></a><!-- doxytag: member="NxActor::getGlobalPosition" ref="f81aaa2fbe517aa236acede75e241522" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxVec3.html">NxVec3</a> NxActor::getGlobalPosition           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the actors world space position. 
<p>
The getGlobal*() methods retrieve the actor's current actor space to world space transformation.<p>
<dl compact><dt><b>Returns:</b></dt><dd>Global position of object.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#4daa5f22e293c6e5285aa60f4e9f1c64">setGlobalPosition()</a> <a class="el" href="classNxActor.html#6b7682f757f66754c2ae09c990580729">getGlobalPose()</a> <a class="el" href="classNxActor.html#e97d7d8704e754c9601a8a48f2163a29">getGlobalOrientation()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="13d0bf7a27e8870eb93e233dbb8107ec"></a><!-- doxytag: member="NxActor::getGroup" ref="13d0bf7a27e8870eb93e233dbb8107ec" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="group__physics.html#gd7d66f3c79185448a29cbc084ddcfefb">NxActorGroup</a> NxActor::getGroup           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the value set with <a class="el" href="classNxActor.html#3f2e3d34803c146d47264099cf27a7dc">setGroup()</a>. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The group ID of this actor.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : No </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#3f2e3d34803c146d47264099cf27a7dc">setGroup()</a> <a class="el" href="group__physics.html#gd7d66f3c79185448a29cbc084ddcfefb">NxActorGroup</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="d88b80155a233e0d2f32e406acd9ec6e"></a><!-- doxytag: member="NxActor::getLinearDamping" ref="d88b80155a233e0d2f32e406acd9ec6e" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a> NxActor::getLinearDamping           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the linear damping coefficient. 
<p>
The actor must be dynamic.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The linear damping coefficient associated with this actor.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#79bc94be0beb90538460d4393854349b">setLinearDamping()</a> <a class="el" href="classNxActor.html#112ea7c29f49719816eab0cc6a25b6f7">getAngularDamping()</a> <a class="el" href="classNxBodyDesc.html#a5c0ec194846727d13d6c735ac2e5d1a">NxBodyDesc.linearDamping</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="439cad6fb757784e330b433c1aa22d57"></a><!-- doxytag: member="NxActor::getLinearMomentum" ref="439cad6fb757784e330b433c1aa22d57" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxVec3.html">NxVec3</a> NxActor::getLinearMomentum           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the linear momentum of an actor. 
<p>
The momentum is equal to the velocity times the mass.<p>
The actor must be dynamic.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The linear momentum for the actor.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#5b68e76f72476013feb078fc227a9e6a">setLinearMomentum()</a> <a class="el" href="classNxActor.html#d481a71c4af358963b40276222da755e">getAngularMomentum()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="b7c9eaeae7a6363523f10c660cb19468"></a><!-- doxytag: member="NxActor::getLinearVelocity" ref="b7c9eaeae7a6363523f10c660cb19468" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxVec3.html">NxVec3</a> NxActor::getLinearVelocity           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the linear velocity of an actor. 
<p>
The actor must be dynamic.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The linear velocity of the actor.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#3109aa69b2cf09b340b622a3e4509620">setLinearVelocity()</a> <a class="el" href="classNxActor.html#41ef0ee9e37b5afb52a125a2212be507">getAngularVelocity()</a> <a class="el" href="classNxBodyDesc.html#ccbb4c762cf11737a0a91e36874ecd66">NxBodyDesc.linearVelocity</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="c92a93f8e378736d93f52373e2d418b8"></a><!-- doxytag: member="NxActor::getLocalPointVelocity" ref="c92a93f8e378736d93f52373e2d418b8" args="(const NxVec3 &amp;point) const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxVec3.html">NxVec3</a> NxActor::getLocalPointVelocity           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>point</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Computes the velocity of a point given in body local coordinates as if it were attached to the actor and moving with it. 
<p>
The actor must be dynamic.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>point</em>&nbsp;</td><td>Point we wish to determine the velocity of, defined in the body local frame. <b>Range:</b> position vector </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The velocity, in the global frame, of the point.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#9003453270279803f0b25b7e6919c009">getPointVelocity()</a> <a class="el" href="classNxBodyDesc.html#ccbb4c762cf11737a0a91e36874ecd66">NxBodyDesc.linearVelocity</a> <a class="el" href="classNxBodyDesc.html#95336965da3939b862dd3f7b2e7c1101">NxBodyDesc.angularVelocity</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="bddfefef2f494f1592cdaee18013ed69"></a><!-- doxytag: member="NxActor::getMass" ref="bddfefef2f494f1592cdaee18013ed69" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a> NxActor::getMass           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the mass of the actor. 
<p>
Static actors will always return 0.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The mass of this actor.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#1f64986638e085cd62a82a1f029ce29f">setMass()</a> <a class="el" href="classNxBodyDesc.html#ca2dff6c4201ea1f6c98ba1872d78cfc">NxBodyDesc.mass</a> <a class="el" href="classNxActor.html#fdd5c9c2a24a326e444743d93799c3a6">setMassSpaceInertiaTensor()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="47bf4351e368c360c598e05079e0337c"></a><!-- doxytag: member="NxActor::getMassSpaceInertiaTensor" ref="47bf4351e368c360c598e05079e0337c" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxVec3.html">NxVec3</a> NxActor::getMassSpaceInertiaTensor           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the diagonal inertia tensor of the actor relative to the mass coordinate frame. 
<p>
This method retrieves a mass frame inertia vector. If you want a global frame inertia tensor(3x3 matrix), then see <a class="el" href="classNxActor.html#9cdddce8794823eebaf036f769c050fc">getGlobalInertiaTensor()</a>.<p>
The actor must be dynamic.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The mass space inertia tensor of this actor.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxBodyDesc.html#df34de0163d0d8825513c2f8da30b47a">NxBodyDesc.massSpaceInertia</a> <a class="el" href="classNxActor.html#fdd5c9c2a24a326e444743d93799c3a6">setMassSpaceInertiaTensor()</a> <a class="el" href="classNxActor.html#1f64986638e085cd62a82a1f029ce29f">setMass()</a> CMassOffsetLocalPose() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="8cbf35f56b3a36154127a8ab98950794"></a><!-- doxytag: member="NxActor::getMaxAngularVelocity" ref="8cbf35f56b3a36154127a8ab98950794" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a> NxActor::getMaxAngularVelocity           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the maximum angular velocity permitted for this actor. 
<p>
The actor must be dynamic.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The maximum allowed angular velocity for this actor.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#b5a92000f85cad10c0fe1553dcbc1a5d">setMaxAngularVelocity</a> <a class="el" href="classNxBodyDesc.html#bab160fcce9598c95d74b9f52c0d327e">NxBodyDesc.maxAngularVelocity</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="41d5cd1b7e48dc555fbb7dda4545aa55"></a><!-- doxytag: member="NxActor::getName" ref="41d5cd1b7e48dc555fbb7dda4545aa55" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual const char* NxActor::getName           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the name string set with <a class="el" href="classNxActor.html#2b6c86db5bb50044dcddbc8d76c1e93d">setName()</a>. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Name string associated with object.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#2b6c86db5bb50044dcddbc8d76c1e93d">setName()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="1cb42016cbafd4a5aa2c5ff4ce63d997"></a><!-- doxytag: member="NxActor::getNbShapes" ref="1cb42016cbafd4a5aa2c5ff4ce63d997" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual NxU32 NxActor::getNbShapes           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the number of shapes assigned to the actor. 
<p>
You can use <a class="el" href="classNxActor.html#d83def360c7cfc2df5154c2027ee6773">getShapes()</a> to retrieve an array of shape pointers.<p>
For static actors it is not possible to release all actors associated with the shape. An attempt to remove the last shape will be ignored.<p>
<dl compact><dt><b>Returns:</b></dt><dd>Number of shapes associated with this actor.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxShape.html">NxShape</a> <a class="el" href="classNxActor.html#d83def360c7cfc2df5154c2027ee6773">getShapes()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="9003453270279803f0b25b7e6919c009"></a><!-- doxytag: member="NxActor::getPointVelocity" ref="9003453270279803f0b25b7e6919c009" args="(const NxVec3 &amp;point) const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxVec3.html">NxVec3</a> NxActor::getPointVelocity           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>point</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Computes the velocity of a point given in world coordinates if it were attached to the actor and moving with it. 
<p>
The actor must be dynamic.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>point</em>&nbsp;</td><td>Point we wish to determine the velocity for, defined in the global frame. <b>Range:</b> position vector </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The velocity of point in the global frame.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#c92a93f8e378736d93f52373e2d418b8">getLocalPointVelocity()</a> <a class="el" href="classNxBodyDesc.html#ccbb4c762cf11737a0a91e36874ecd66">NxBodyDesc.linearVelocity</a> <a class="el" href="classNxBodyDesc.html#95336965da3939b862dd3f7b2e7c1101">NxBodyDesc.angularVelocity</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="62061c657183e9e50d19e16169c7d20c"></a><!-- doxytag: member="NxActor::getScene" ref="62061c657183e9e50d19e16169c7d20c" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxScene.html">NxScene</a>&amp; NxActor::getScene           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the scene which this actor belongs to. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Owner Scene.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxScene.html">NxScene</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="d83def360c7cfc2df5154c2027ee6773"></a><!-- doxytag: member="NxActor::getShapes" ref="d83def360c7cfc2df5154c2027ee6773" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="classNxShape.html">NxShape</a>* const* NxActor::getShapes           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns an array of shape pointers belonging to the actor. 
<p>
These are the shapes used by the actor for collision detection.<p>
You can retrieve the number of shape pointers by calling <a class="el" href="classNxActor.html#1cb42016cbafd4a5aa2c5ff4ce63d997">getNbShapes()</a><p>
Note: Adding or removing shapes with <a class="el" href="classNxActor.html#d8046d5b12fbae2fd18a3b293ea980ad">createShape()</a> or <a class="el" href="classNxActor.html#4f62ce88753b117a5a608a6bbe693001">releaseShape()</a> will invalidate the pointer.<p>
<dl compact><dt><b>Returns:</b></dt><dd>Array of shapes which are associated with this actor.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxShape.html">NxShape</a> <a class="el" href="classNxActor.html#1cb42016cbafd4a5aa2c5ff4ce63d997">getNbShapes()</a> <a class="el" href="classNxActor.html#d8046d5b12fbae2fd18a3b293ea980ad">createShape()</a> <a class="el" href="classNxActor.html#4f62ce88753b117a5a608a6bbe693001">releaseShape()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="d9cf5337c1ca98761f036eb6b6f5268c"></a><!-- doxytag: member="NxActor::getSleepAngularVelocity" ref="d9cf5337c1ca98761f036eb6b6f5268c" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a> NxActor::getSleepAngularVelocity           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the angular velocity below which an actor may go to sleep. 
<p>
Actors whose angular velocity is above this threshold will not be put to sleep.<p>
The actor must be dynamic.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The threshold angular velocity for sleeping.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#529efc4d1ee46a7f42da2675913600f5">isGroupSleeping()</a> <a class="el" href="classNxActor.html#d42ee1a227f0ee512837ee8a250725f4">isSleeping()</a> <a class="el" href="classNxActor.html#0fbe05f29e7c786cb56a484376b01714">getSleepLinearVelocity()</a> <a class="el" href="classNxActor.html#d9cf5337c1ca98761f036eb6b6f5268c">getSleepAngularVelocity()</a> <a class="el" href="classNxActor.html#f3548981641eec58a3761331682298b7">wakeUp()</a> <a class="el" href="classNxActor.html#708cf737477f4787e0a4983ff391c02c">putToSleep()</a> <a class="el" href="classNxActor.html#08ba74338fa41fd7d904e4e28c629089">setSleepAngularVelocity()</a> <a class="el" href="classNxActor.html#1680326ee54d224d7cbe2e373a5599ad">setSleepEnergyThreshold()</a> <a class="el" href="classNxActor.html#2e77d74a928ea62456b0156e98061ea7">getSleepEnergyThreshold()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="2e77d74a928ea62456b0156e98061ea7"></a><!-- doxytag: member="NxActor::getSleepEnergyThreshold" ref="2e77d74a928ea62456b0156e98061ea7" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a> NxActor::getSleepEnergyThreshold           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the energy below which an actor may go to sleep. 
<p>
Actors whose energy is above this threshold will not be put to sleep.<p>
The actor must be dynamic.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The energy threshold for sleeping.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#529efc4d1ee46a7f42da2675913600f5">isGroupSleeping()</a> <a class="el" href="classNxActor.html#d42ee1a227f0ee512837ee8a250725f4">isSleeping()</a> <a class="el" href="classNxActor.html#0fbe05f29e7c786cb56a484376b01714">getSleepLinearVelocity()</a> <a class="el" href="classNxActor.html#d9cf5337c1ca98761f036eb6b6f5268c">getSleepAngularVelocity()</a> <a class="el" href="classNxActor.html#f3548981641eec58a3761331682298b7">wakeUp()</a> <a class="el" href="classNxActor.html#708cf737477f4787e0a4983ff391c02c">putToSleep()</a> <a class="el" href="classNxActor.html#08ba74338fa41fd7d904e4e28c629089">setSleepAngularVelocity()</a> <a class="el" href="classNxBodyDesc.html#3573812de588ecfa626795b1306e181d">NxBodyDesc.sleepEnergyThreshold</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="0fbe05f29e7c786cb56a484376b01714"></a><!-- doxytag: member="NxActor::getSleepLinearVelocity" ref="0fbe05f29e7c786cb56a484376b01714" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual <a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a> NxActor::getSleepLinearVelocity           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the linear velocity below which an actor may go to sleep. 
<p>
Actors whose linear velocity is above this threshold will not be put to sleep.<p>
The actor must be dynamic.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#d42ee1a227f0ee512837ee8a250725f4">isSleeping</a></dd></dl>
<dl compact><dt><b>Returns:</b></dt><dd>The threshold linear velocity for sleeping.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#529efc4d1ee46a7f42da2675913600f5">isGroupSleeping()</a> <a class="el" href="classNxActor.html#d42ee1a227f0ee512837ee8a250725f4">isSleeping()</a> <a class="el" href="classNxActor.html#0fbe05f29e7c786cb56a484376b01714">getSleepLinearVelocity()</a> <a class="el" href="classNxActor.html#d9cf5337c1ca98761f036eb6b6f5268c">getSleepAngularVelocity()</a> <a class="el" href="classNxActor.html#f3548981641eec58a3761331682298b7">wakeUp()</a> <a class="el" href="classNxActor.html#708cf737477f4787e0a4983ff391c02c">putToSleep()</a> <a class="el" href="classNxActor.html#4e29571507ee435c74ccda913a13888c">setSleepLinearVelocity()</a> <a class="el" href="classNxActor.html#1680326ee54d224d7cbe2e373a5599ad">setSleepEnergyThreshold()</a> <a class="el" href="classNxActor.html#2e77d74a928ea62456b0156e98061ea7">getSleepEnergyThreshold()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="d24021d2a57fef1c2c66c537b25c19a8"></a><!-- doxytag: member="NxActor::getSolverIterationCount" ref="d24021d2a57fef1c2c66c537b25c19a8" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual NxU32 NxActor::getSolverIterationCount           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieves the solver iteration count. 
<p>
See <a class="el" href="classNxActor.html#928d70f4e509322678da747de322bc26">setSolverIterationCount()</a>.<p>
The actor must be dynamic.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The solver iteration count for this body.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#928d70f4e509322678da747de322bc26">setSolverIterationCount()</a> <a class="el" href="classNxBodyDesc.html#6fe9a4d43a13afa702ffe66ec9abcf9b">NxBodyDesc.solverIterationCount</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="348a39286d0ea72188c75e6301ee9fb9"></a><!-- doxytag: member="NxActor::isDynamic" ref="348a39286d0ea72188c75e6301ee9fb9" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool NxActor::isDynamic           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns true if the actor is dynamic. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>True if this is a dynamic actor.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxBodyDesc.html">NxBodyDesc</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="529efc4d1ee46a7f42da2675913600f5"></a><!-- doxytag: member="NxActor::isGroupSleeping" ref="529efc4d1ee46a7f42da2675913600f5" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool NxActor::isGroupSleeping           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns true if this body and all the actors it is touching or is linked to with joints are sleeping. 
<p>
When an actor does not move for a period of time, it is no longer simulated in order to save time. This state is called sleeping. However, because the object automatically wakes up when it is either touched by an awake object, or one of its properties is changed by the user, the entire sleep mechanism should be transparent to the user.<p>
(Note: From version 2.5 this method is identical to <a class="el" href="classNxActor.html#d42ee1a227f0ee512837ee8a250725f4">isSleeping()</a>)<p>
The actor must be dynamic.<p>
<dl compact><dt><b>Returns:</b></dt><dd>True if the actor's group is sleeping.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : No </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#529efc4d1ee46a7f42da2675913600f5">isGroupSleeping()</a> <a class="el" href="classNxActor.html#d42ee1a227f0ee512837ee8a250725f4">isSleeping()</a> <a class="el" href="classNxActor.html#0fbe05f29e7c786cb56a484376b01714">getSleepLinearVelocity()</a> <a class="el" href="classNxActor.html#d9cf5337c1ca98761f036eb6b6f5268c">getSleepAngularVelocity()</a> <a class="el" href="classNxActor.html#f3548981641eec58a3761331682298b7">wakeUp()</a> <a class="el" href="classNxActor.html#708cf737477f4787e0a4983ff391c02c">putToSleep()</a> <a class="el" href="classNxActor.html#2e77d74a928ea62456b0156e98061ea7">getSleepEnergyThreshold()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="d42ee1a227f0ee512837ee8a250725f4"></a><!-- doxytag: member="NxActor::isSleeping" ref="d42ee1a227f0ee512837ee8a250725f4" args="() const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool NxActor::isSleeping           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns true if this body is sleeping. 
<p>
When an actor does not move for a period of time, it is no longer simulated in order to save time. This state is called sleeping. However, because the object automatically wakes up when it is either touched by an awake object, or one of its properties is changed by the user, the entire sleep mechanism should be transparent to the user.<p>
If an actor is asleep after the call to <a class="el" href="classNxScene.html#120b86a16a1786546d73a5d22f7d1d55">NxScene::fetchResults()</a> returns, it is guaranteed that the pose of the actor was not changed. You can use this information to avoid updating the transforms of associated of dependent objects.<p>
The actor must be dynamic.<p>
<dl compact><dt><b>Returns:</b></dt><dd>True if the actor is sleeping.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#529efc4d1ee46a7f42da2675913600f5">isGroupSleeping()</a> <a class="el" href="classNxActor.html#d42ee1a227f0ee512837ee8a250725f4">isSleeping()</a> <a class="el" href="classNxActor.html#0fbe05f29e7c786cb56a484376b01714">getSleepLinearVelocity()</a> <a class="el" href="classNxActor.html#d9cf5337c1ca98761f036eb6b6f5268c">getSleepAngularVelocity()</a> <a class="el" href="classNxActor.html#f3548981641eec58a3761331682298b7">wakeUp()</a> <a class="el" href="classNxActor.html#708cf737477f4787e0a4983ff391c02c">putToSleep()</a> <a class="el" href="classNxActor.html#2e77d74a928ea62456b0156e98061ea7">getSleepEnergyThreshold()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="7c5a99bd0aa92fcd82ca0326a63003d4"></a><!-- doxytag: member="NxActor::linearSweep" ref="7c5a99bd0aa92fcd82ca0326a63003d4" args="(const NxVec3 &amp;motion, NxU32 flags, void *userData, NxU32 nbShapes, NxSweepQueryHit *shapes, NxUserEntityReport&lt; NxSweepQueryHit &gt; *callback, const NxSweepCache *sweepCache=NULL)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual NxU32 NxActor::linearSweep           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>motion</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32&nbsp;</td>
          <td class="mdname" nowrap> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>userData</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>NxU32&nbsp;</td>
          <td class="mdname" nowrap> <em>nbShapes</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structNxSweepQueryHit.html">NxSweepQueryHit</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>shapes</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classNxUserEntityReport.html">NxUserEntityReport</a>&lt; <a class="el" href="structNxSweepQueryHit.html">NxSweepQueryHit</a> &gt; *&nbsp;</td>
          <td class="mdname" nowrap> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const <a class="el" href="classNxSweepCache.html">NxSweepCache</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>sweepCache</em> = <code>NULL</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Performs a linear sweep through space with the actor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>motion</em>&nbsp;</td><td>Length and direction of the sweep </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags controlling the mode of the sweep </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>userData</em>&nbsp;</td><td>User data to impart to the returned data struct </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nbShapes</em>&nbsp;</td><td>Maximum number of shapes to report <b>Range:</b> [1,NX_MAX_U32] </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>shapes</em>&nbsp;</td><td>Pointer to buffer for reported shapes </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>Callback function invoked on the closest hit (if any) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sweepCache</em>&nbsp;</td><td>Sweep cache to use with the query</td></tr>
  </table>
</dl>
The function sweeps the entire actor, with all its shapes, through space and reports any shapes in the scene with which they intersect. Apart from the number of shapes intersected in this way, and the shapes intersected, information on the closest intersection is put in an <a class="el" href="structNxSweepQueryHit.html">NxSweepQueryHit</a> structure which can be processed in the callback function if provided. Which shapes in the scene are regarded is specified through the flags parameter. For persistent sweeps, a sweep cache may be used to improve performance. A sweep cache may be created through <a class="el" href="classNxScene.html#17e15e9f9626bb5f3ca6c6ee86f28745">NxScene::createSweepCache()</a>. Note that trigger shapes possibly contained in the actor are automatically filtered out.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The number of hits reported.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="structNxSweepQueryHit.html">NxSweepQueryHit</a> <a class="el" href="group__physics.html#g3b13edbb56b767ba6fe057052f37ec0d">NxSweepFlags</a> <a class="el" href="classNxUserEntityReport.html">NxUserEntityReport</a> <a class="el" href="classNxScene.html">NxScene</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="82282b99e9d92e5e099e14a7d8a7a17c"></a><!-- doxytag: member="NxActor::moveGlobalOrientation" ref="82282b99e9d92e5e099e14a7d8a7a17c" args="(const NxMat33 &amp;mat)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::moveGlobalOrientation           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxMat33.html">NxMat33</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mat</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The moveGlobal* calls serve to move kinematically controlled dynamic actors through the game world. 
<p>
See moveGlobalPose() for more information.<p>
<b>Sleeping:</b> This call wakes the actor if it is sleeping.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mat</em>&nbsp;</td><td>The desired orientation for the kinematic actor, in the global frame. <b>Range:</b> rotation matrix.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>Although it is possible to only specify the orientation, it might be needed to also specify the body position, using <a class="el" href="classNxActor.html#0e867df07dc631dc212760f01bd7d45c">moveGlobalPosition()</a>. If you don't do this, the actor position can start to drift, because of numerical imprecision.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#59f9de4ef9f288dc4a2a7332930b544e">moveGlobalOrientationQuat()</a> <a class="el" href="classNxActor.html#0e867df07dc631dc212760f01bd7d45c">moveGlobalPosition()</a> <a class="el" href="classNxActor.html#5451ce58c1ae9fad377484dc132ce668">moveGlobalPose()</a> <a class="el" href="group__physics.html#g5b0f3262d34ee89b46e2f285d2052513">NxBodyFlag</a> <a class="el" href="classNxActor.html#3d49c23e8a262e4f78387dda14549baa">raiseBodyFlag()</a> <a class="el" href="classNxBodyDesc.html#ee23f13dce74a198c7a91fc0ac12f01e">NxBodyDesc.flags</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="59f9de4ef9f288dc4a2a7332930b544e"></a><!-- doxytag: member="NxActor::moveGlobalOrientationQuat" ref="59f9de4ef9f288dc4a2a7332930b544e" args="(const NxQuat &amp;quat)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::moveGlobalOrientationQuat           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxQuat.html">NxQuat</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>quat</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The moveGlobal* calls serve to move kinematically controlled dynamic actors through the game world. 
<p>
See moveGlobalPose() for more information.<p>
<b>Sleeping:</b> This call wakes the actor if it is sleeping.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>quat</em>&nbsp;</td><td>The desired orientation quaternion for the kinematic actor, in the global frame.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#0e867df07dc631dc212760f01bd7d45c">moveGlobalPosition()</a> <a class="el" href="classNxActor.html#5451ce58c1ae9fad377484dc132ce668">moveGlobalPose()</a> <a class="el" href="group__physics.html#g5b0f3262d34ee89b46e2f285d2052513">NxBodyFlag</a> <a class="el" href="classNxActor.html#3d49c23e8a262e4f78387dda14549baa">raiseBodyFlag()</a> <a class="el" href="classNxBodyDesc.html#ee23f13dce74a198c7a91fc0ac12f01e">NxBodyDesc.flags</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="5451ce58c1ae9fad377484dc132ce668"></a><!-- doxytag: member="NxActor::moveGlobalPose" ref="5451ce58c1ae9fad377484dc132ce668" args="(const NxMat34 &amp;mat)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::moveGlobalPose           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxMat34.html">NxMat34</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mat</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The moveGlobal* calls serve to move kinematically controlled dynamic actors through the game world. 
<p>
You set a dynamic actor to be kinematic using the NX_BF_KINEMATIC body flag, used either in the <a class="el" href="classNxBodyDesc.html">NxBodyDesc</a> or with <a class="el" href="classNxActor.html#3d49c23e8a262e4f78387dda14549baa">raiseBodyFlag()</a>.<p>
The move command will result in a velocity that, when successfully carried out (i.e. the motion is not blocked due to joints or collisions) inside run*(), will move the body into the desired pose. After the move is carried out during a single time step, the velocity is returned to zero. Thus, you must continuously call this in every time step for kinematic actors so that they move along a path.<p>
These functions simply store the move destination until run*() is called, so consecutive calls will simply overwrite the stored target variable.<p>
Note that in the future we will provide a mechanism for the motion to be blocked in certain cases (such as when a box jams in an automatic door), but currently the motion is always fully carried out.<p>
<b>Sleeping:</b> This call wakes the actor if it is sleeping.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mat</em>&nbsp;</td><td>The desired pose for the kinematic actor, in the global frame. <b>Range:</b> rigid body transform.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#0e867df07dc631dc212760f01bd7d45c">moveGlobalPosition()</a> <a class="el" href="classNxActor.html#82282b99e9d92e5e099e14a7d8a7a17c">moveGlobalOrientation()</a> <a class="el" href="classNxActor.html#59f9de4ef9f288dc4a2a7332930b544e">moveGlobalOrientationQuat()</a> <a class="el" href="group__physics.html#g5b0f3262d34ee89b46e2f285d2052513">NxBodyFlag</a> <a class="el" href="classNxActor.html#3d49c23e8a262e4f78387dda14549baa">raiseBodyFlag()</a> <a class="el" href="classNxBodyDesc.html#ee23f13dce74a198c7a91fc0ac12f01e">NxBodyDesc.flags</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="0e867df07dc631dc212760f01bd7d45c"></a><!-- doxytag: member="NxActor::moveGlobalPosition" ref="0e867df07dc631dc212760f01bd7d45c" args="(const NxVec3 &amp;vec)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::moveGlobalPosition           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>vec</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The moveGlobal* calls serve to move kinematically controlled dynamic actors through the game world. 
<p>
See moveGlobalPose() for more information.<p>
<b>Sleeping:</b> This call wakes the actor if it is sleeping.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>vec</em>&nbsp;</td><td>The desired position for the kinematic actor, in the global frame. <b>Range:</b> position vector</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#5451ce58c1ae9fad377484dc132ce668">moveGlobalPose()</a> <a class="el" href="classNxActor.html#82282b99e9d92e5e099e14a7d8a7a17c">moveGlobalOrientation()</a> <a class="el" href="classNxActor.html#59f9de4ef9f288dc4a2a7332930b544e">moveGlobalOrientationQuat()</a> <a class="el" href="group__physics.html#g5b0f3262d34ee89b46e2f285d2052513">NxBodyFlag</a> <a class="el" href="classNxActor.html#3d49c23e8a262e4f78387dda14549baa">raiseBodyFlag()</a> <a class="el" href="classNxBodyDesc.html#ee23f13dce74a198c7a91fc0ac12f01e">NxBodyDesc.flags</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="708cf737477f4787e0a4983ff391c02c"></a><!-- doxytag: member="NxActor::putToSleep" ref="708cf737477f4787e0a4983ff391c02c" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::putToSleep           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Forces the actor to sleep. 
<p>
The actor will stay asleep until the next call to simulate, and will not wake up until then even when otherwise it would (for example a force is applied to it). It can however wake up during the next simulate call.<p>
The actor must be dynamic.<p>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#529efc4d1ee46a7f42da2675913600f5">isGroupSleeping()</a> <a class="el" href="classNxActor.html#d42ee1a227f0ee512837ee8a250725f4">isSleeping()</a> <a class="el" href="classNxActor.html#0fbe05f29e7c786cb56a484376b01714">getSleepLinearVelocity()</a> <a class="el" href="classNxActor.html#d9cf5337c1ca98761f036eb6b6f5268c">getSleepAngularVelocity()</a> <a class="el" href="classNxActor.html#f3548981641eec58a3761331682298b7">wakeUp()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="5d3d4b28d89babc607a5e913c2f9c231"></a><!-- doxytag: member="NxActor::raiseActorFlag" ref="5d3d4b28d89babc607a5e913c2f9c231" args="(NxActorFlag actorFlag)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::raiseActorFlag           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__physics.html#g842f6182bd4946039cabba84d3c8ee55">NxActorFlag</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>actorFlag</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Raises a particular actor flag. 
<p>
See the list of flags <a class="el" href="group__physics.html#g842f6182bd4946039cabba84d3c8ee55">NxActorFlag</a><p>
<b>Sleeping:</b> Does <b>NOT</b> wake the actor up automatically.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actorFlag</em>&nbsp;</td><td>The actor flag to raise(set). See <a class="el" href="group__physics.html#g842f6182bd4946039cabba84d3c8ee55">NxActorFlag</a>.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__physics.html#g842f6182bd4946039cabba84d3c8ee55">NxActorFlag</a> <a class="el" href="classNxActor.html#ae1624ce4d7bc8c03a3ae30f97e217b6">clearActorFlag()</a> <a class="el" href="classNxActor.html#2413bc309700e33398453278691ce295">readActorFlag()</a> <a class="el" href="classNxActorDescBase.html#d28bfce0c84155afad39ef95d31e8667">NxActorDesc.flags</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="3d49c23e8a262e4f78387dda14549baa"></a><!-- doxytag: member="NxActor::raiseBodyFlag" ref="3d49c23e8a262e4f78387dda14549baa" args="(NxBodyFlag bodyFlag)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::raiseBodyFlag           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__physics.html#g5b0f3262d34ee89b46e2f285d2052513">NxBodyFlag</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>bodyFlag</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Raises a particular body flag. 
<p>
See the actors body flags. See <a class="el" href="group__physics.html#g5b0f3262d34ee89b46e2f285d2052513">NxBodyFlag</a> for a list of flags.<p>
The actor must be dynamic.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bodyFlag</em>&nbsp;</td><td>Body flag to raise(set). See <a class="el" href="group__physics.html#g5b0f3262d34ee89b46e2f285d2052513">NxBodyFlag</a>.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Partial (supports NX_BF_KINEMATIC, NX_BF_DISABLE_GRAVITY) </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__physics.html#g5b0f3262d34ee89b46e2f285d2052513">NxBodyFlag</a> <a class="el" href="classNxActor.html#021e9ab6e222599cffcb9095c0ad39a7">clearBodyFlag()</a> <a class="el" href="classNxActor.html#d40b479de4ab975d54c5c5cc41699a66">readBodyFlag()</a> <a class="el" href="classNxBodyDesc.html#ee23f13dce74a198c7a91fc0ac12f01e">NxBodyDesc.flags</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="2413bc309700e33398453278691ce295"></a><!-- doxytag: member="NxActor::readActorFlag" ref="2413bc309700e33398453278691ce295" args="(NxActorFlag actorFlag) const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool NxActor::readActorFlag           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__physics.html#g842f6182bd4946039cabba84d3c8ee55">NxActorFlag</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>actorFlag</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Reads a particular actor flag. 
<p>
See the list of flags <a class="el" href="group__physics.html#g842f6182bd4946039cabba84d3c8ee55">NxActorFlag</a><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actorFlag</em>&nbsp;</td><td>The actor flag to retrieve. See <a class="el" href="group__physics.html#g842f6182bd4946039cabba84d3c8ee55">NxActorFlag</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The value of the actor flag.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__physics.html#g842f6182bd4946039cabba84d3c8ee55">NxActorFlag</a> <a class="el" href="classNxActor.html#5d3d4b28d89babc607a5e913c2f9c231">raiseActorFlag()</a> <a class="el" href="classNxActor.html#ae1624ce4d7bc8c03a3ae30f97e217b6">clearActorFlag()</a> <a class="el" href="classNxActorDescBase.html#d28bfce0c84155afad39ef95d31e8667">NxActorDesc.flags</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="d40b479de4ab975d54c5c5cc41699a66"></a><!-- doxytag: member="NxActor::readBodyFlag" ref="d40b479de4ab975d54c5c5cc41699a66" args="(NxBodyFlag bodyFlag) const =0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool NxActor::readBodyFlag           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__physics.html#g5b0f3262d34ee89b46e2f285d2052513">NxBodyFlag</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>bodyFlag</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Reads a particular body flag. 
<p>
See <a class="el" href="group__physics.html#g5b0f3262d34ee89b46e2f285d2052513">NxBodyFlag</a> for a list of flags.<p>
The actor must be dynamic.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bodyFlag</em>&nbsp;</td><td>Body flag to retrieve. See <a class="el" href="group__physics.html#g5b0f3262d34ee89b46e2f285d2052513">NxBodyFlag</a>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The value of the body flag specified by bodyFlag.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Partial (supports NX_BF_KINEMATIC, NX_BF_DISABLE_GRAVITY) </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__physics.html#g5b0f3262d34ee89b46e2f285d2052513">NxBodyFlag</a> <a class="el" href="classNxActor.html#3d49c23e8a262e4f78387dda14549baa">raiseBodyFlag()</a> <a class="el" href="classNxActor.html#021e9ab6e222599cffcb9095c0ad39a7">clearBodyFlag()</a> <a class="el" href="classNxBodyDesc.html#ee23f13dce74a198c7a91fc0ac12f01e">NxBodyDesc.flags</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="4f62ce88753b117a5a608a6bbe693001"></a><!-- doxytag: member="NxActor::releaseShape" ref="4f62ce88753b117a5a608a6bbe693001" args="(NxShape &amp;shape)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::releaseShape           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classNxShape.html">NxShape</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>shape</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Deletes the specified shape. 
<p>
This invalidates the pointer returned by <a class="el" href="classNxActor.html#d83def360c7cfc2df5154c2027ee6773">getShapes()</a>. Avoid release calls while the scene is simulating (in between simulate() and fetchResults() calls). Note that mass properties for the actor are unchanged by this call unless <a class="el" href="classNxActor.html#8949ba1c4b34408cf20c33fcbcb2016a">updateMassFromShapes</a> is also called.<p>
<b>Sleeping:</b> Does <b>NOT</b> wake the actor up automatically.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shape</em>&nbsp;</td><td>Shape to be released.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxShape.html">NxShape</a> <p>
<a class="el" href="classNxBoxShape.html">NxBoxShape</a> <a class="el" href="classNxCapsuleShape.html">NxCapsuleShape</a> <a class="el" href="classNxConvexShape.html">NxConvexShape</a> <a class="el" href="classNxPlaneShape.html">NxPlaneShape</a> <a class="el" href="classNxSphereShape.html">NxSphereShape</a> <a class="el" href="classNxTriangleMeshShape.html">NxTriangleMeshShape</a> <a class="el" href="classNxWheelShape.html">NxWheelShape</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a579d708b79eb4b52d3a1ced14659282"></a><!-- doxytag: member="NxActor::resetUserActorPairFiltering" ref="a579d708b79eb4b52d3a1ced14659282" args="()=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::resetUserActorPairFiltering           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Reset the user actor pair filtering state for this actor. This will cause filtering callbacks to be called again for any pairs involving this actor. Use this method when you wish to change the filtering policy of an actor that may already be in contact with other actors. 
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxUserActorPairFiltering.html">NxUserActorPairFiltering</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="504a53936be2dcc2762349ad846872dd"></a><!-- doxytag: member="NxActor::saveBodyToDesc" ref="504a53936be2dcc2762349ad846872dd" args="(NxBodyDesc &amp;bodyDesc)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool NxActor::saveBodyToDesc           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classNxBodyDesc.html">NxBodyDesc</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>bodyDesc</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Saves the body information of a dynamic actor to the passed body descriptor. 
<p>
This method only save the dynamic(body) state for the actor. The user should use <a class="el" href="classNxActor.html#4a4dd0f6459f62c9e265df94b2989aae">saveToDesc()</a> to save the state common between static and dynamic actors. Plus manually saving the shapes belonging to the actor.<p>
The actor must be dynamic.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>bodyDesc</em>&nbsp;</td><td>Descriptor to save the state of the body to. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True for a dynamic body. Otherwise False.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxBodyDesc.html">NxBodyDesc</a> <a class="el" href="classNxActor.html#4a4dd0f6459f62c9e265df94b2989aae">saveToDesc()</a> getShape() </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="4a4dd0f6459f62c9e265df94b2989aae"></a><!-- doxytag: member="NxActor::saveToDesc" ref="4a4dd0f6459f62c9e265df94b2989aae" args="(NxActorDescBase &amp;desc)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::saveToDesc           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classNxActorDescBase.html">NxActorDescBase</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>desc</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Saves the state of the actor to the passed descriptor. 
<p>
This method does not save out any shapes belonging to the actor to the descriptor's shape vector, nor does it write to its body member. You have to iterate through the shapes of the actor and save them manually. In addition for dynamic actors you have to call the <a class="el" href="classNxActor.html#504a53936be2dcc2762349ad846872dd">saveBodyToDesc()</a> method.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>Descriptor to save object state to.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActorDesc.html">NxActorDesc</a> <a class="el" href="classNxActorDescBase.html">NxActorDescBase</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="01a17cd835e78b04de9451255772a6f3"></a><!-- doxytag: member="NxActor::setAngularDamping" ref="01a17cd835e78b04de9451255772a6f3" args="(NxReal angDamp)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::setAngularDamping           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>angDamp</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the angular damping coefficient. 
<p>
Zero represents no damping.<p>
The angular damping coefficient must be nonnegative.<p>
The actor must be dynamic.<p>
<b>Default:</b> 0.05<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>angDamp</em>&nbsp;</td><td>Angular damping coefficient. <b>Range:</b> [0,inf)</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#112ea7c29f49719816eab0cc6a25b6f7">getAngularDamping()</a> <a class="el" href="classNxBodyDesc.html#351a711ee84d0f69f5c0ed1337b300ba">NxBodyDesc.angularDamping</a> <a class="el" href="classNxActor.html#79bc94be0beb90538460d4393854349b">setLinearDamping()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="89045d712932139196698354ad5866aa"></a><!-- doxytag: member="NxActor::setAngularMomentum" ref="89045d712932139196698354ad5866aa" args="(const NxVec3 &amp;angMoment)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::setAngularMomentum           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>angMoment</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the angular momentum of the actor. 
<p>
Note that if you continuously set the angular velocity of an actor yourself, forces such as friction will not be able to rotate the actor, because forces directly influence only the velocity of actor.<p>
The actor must be dynamic.<p>
<b>Sleeping:</b> This call wakes the actor if it is sleeping.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>angMoment</em>&nbsp;</td><td>New angular momentum. <b>Range:</b> angular momentum vector</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#d481a71c4af358963b40276222da755e">getAngularMomentum()</a> <a class="el" href="classNxActor.html#5b68e76f72476013feb078fc227a9e6a">setLinearMomentum()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="7528388b02798682b09470aaa755b7b3"></a><!-- doxytag: member="NxActor::setAngularVelocity" ref="7528388b02798682b09470aaa755b7b3" args="(const NxVec3 &amp;angVel)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::setAngularVelocity           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>angVel</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the angular velocity of the actor. 
<p>
Note that if you continuously set the angular velocity of an actor yourself, forces such as friction will not be able to rotate the actor, because forces directly influence only the velocity/momentum.<p>
The actor must be dynamic.<p>
<b>Sleeping:</b> This call wakes the actor if it is sleeping.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>angVel</em>&nbsp;</td><td>New angular velocity of actor. <b>Range:</b> angular velocity vector</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#41ef0ee9e37b5afb52a125a2212be507">getAngularVelocity()</a> <a class="el" href="classNxActor.html#3109aa69b2cf09b340b622a3e4509620">setLinearVelocity()</a> <a class="el" href="classNxBodyDesc.html#95336965da3939b862dd3f7b2e7c1101">NxBodyDesc.angularVelocity</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="aaac779605a86fc9dc91de0422f38807"></a><!-- doxytag: member="NxActor::setCCDMotionThreshold" ref="aaac779605a86fc9dc91de0422f38807" args="(NxReal thresh)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::setCCDMotionThreshold           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>thresh</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the CCD Motion Threshold. 
<p>
If CCD is globally enabled (parameter NX_CONTINUOUS_CD), it is still skipped for bodies which have no point on any of their shapes moving more than CCDMotionThreshold distance in one time step.<p>
Hence, CCD is always performed if the threshold is 0.<p>
The actor must be dynamic and the CCD motion threshold must be non-negative.<p>
<h3>Visualizations:</h3>
<p>
<ul>
<li><a class="el" href="group__physics.html#ggf21616f5cf8b8444c9e36705ca9865ddb56a34a8567de340c9d71e624815a267">NX_VISUALIZE_COLLISION_CCD</a> </li>
<li><a class="el" href="group__physics.html#ggf21616f5cf8b8444c9e36705ca9865dd693033967ae92c69141a701ccd619fc3">NX_VISUALIZE_COLLISION_SKELETONS</a></li>
</ul>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>thresh</em>&nbsp;</td><td>CCD Motion threshold. <b>Range:</b> [0,inf)</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#b20f5e37073cf1e692e76c0c9d44ccc1">getCCDMotionThreshold</a> <a class="el" href="group__physics.html#gf21616f5cf8b8444c9e36705ca9865dd">NxParameter</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="2b2f6cd961358096977f69904302078c"></a><!-- doxytag: member="NxActor::setCMassGlobalOrientation" ref="2b2f6cd961358096977f69904302078c" args="(const NxMat33 &amp;mat)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::setCMassGlobalOrientation           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxMat33.html">NxMat33</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mat</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The setCMassGlobal*() methods move the actor by setting the pose of the center of mass. 
<p>
See setCMassGlobalPose() for more information.<p>
The actor must be dynamic.<p>
<b>Sleeping:</b> This call wakes the actor if it is sleeping.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mat</em>&nbsp;</td><td>Actors new orientation, from the transformation of the mass frame to the global frame. <b>Range:</b> rotation matrix.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#5bb24ff15036985025015eac64f1152e">setCMassGlobalPose()</a> <a class="el" href="classNxActor.html#63e168f3985047f5cb71f6a5bc9f1ebe">setCMassGlobalPosition()</a> <a class="el" href="classNxActor.html#9897478c423daa7ae0be40d711d72216">getCMassLocalPose()</a> <p>
<a class="el" href="classNxBodyDesc.html#45fedd6e30ac62fe66ce4a42db2514e1">NxBodyDesc.massLocalPose</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="5bb24ff15036985025015eac64f1152e"></a><!-- doxytag: member="NxActor::setCMassGlobalPose" ref="5bb24ff15036985025015eac64f1152e" args="(const NxMat34 &amp;mat)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::setCMassGlobalPose           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxMat34.html">NxMat34</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mat</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The setCMassGlobal*() methods move the actor by setting the pose of the center of mass. 
<p>
Here the transform between the center of mass and the actor frame is held fixed and the actor to world transform is updated.<p>
The actor must be dynamic.<p>
<b>Sleeping:</b> This call wakes the actor if it is sleeping.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mat</em>&nbsp;</td><td>Actors new pose, from the transformation of the mass frame to the global frame. <b>Range:</b> rigid body transform.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#63e168f3985047f5cb71f6a5bc9f1ebe">setCMassGlobalPosition()</a> <a class="el" href="classNxActor.html#2b2f6cd961358096977f69904302078c">setCMassGlobalOrientation()</a> <a class="el" href="classNxActor.html#9897478c423daa7ae0be40d711d72216">getCMassLocalPose()</a> <p>
<a class="el" href="classNxBodyDesc.html#45fedd6e30ac62fe66ce4a42db2514e1">NxBodyDesc.massLocalPose</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="63e168f3985047f5cb71f6a5bc9f1ebe"></a><!-- doxytag: member="NxActor::setCMassGlobalPosition" ref="63e168f3985047f5cb71f6a5bc9f1ebe" args="(const NxVec3 &amp;vec)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::setCMassGlobalPosition           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>vec</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The setCMassGlobal*() methods move the actor by setting the pose of the center of mass. 
<p>
See setCMassGlobalPose() for more information.<p>
The actor must be dynamic.<p>
<b>Sleeping:</b> This call wakes the actor if it is sleeping.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>vec</em>&nbsp;</td><td>Actors new position, from the transformation of the mass frame to the global frame. <b>Range:</b> position vector</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#5bb24ff15036985025015eac64f1152e">setCMassGlobalPose()</a> <a class="el" href="classNxActor.html#2b2f6cd961358096977f69904302078c">setCMassGlobalOrientation()</a> <a class="el" href="classNxActor.html#9897478c423daa7ae0be40d711d72216">getCMassLocalPose()</a> <p>
<a class="el" href="classNxBodyDesc.html#45fedd6e30ac62fe66ce4a42db2514e1">NxBodyDesc.massLocalPose</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="241a765f9ca99b4955a83a8cd84ca12f"></a><!-- doxytag: member="NxActor::setCMassOffsetGlobalOrientation" ref="241a765f9ca99b4955a83a8cd84ca12f" args="(const NxMat33 &amp;mat)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::setCMassOffsetGlobalOrientation           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxMat33.html">NxMat33</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mat</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The setCMassOffsetGlobal*() methods set the pose of the center of mass relative to world space. 
<p>
See setCMassOffsetGlobalPose() for more information.<p>
The actor must be dynamic.<p>
<b>Sleeping:</b> This call wakes the actor if it is sleeping.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mat</em>&nbsp;</td><td>Mass frame orientation offset relative to the global frame. <b>Range:</b> rotation matrix.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#e95d79850f3bcc02883c78cc34250adc">setCMassOffsetGlobalPose()</a> <a class="el" href="classNxActor.html#4aca9311911904ce9f10ad354149200e">setCMassOffsetGlobalPosition()</a> <p>
<a class="el" href="classNxBodyDesc.html#45fedd6e30ac62fe66ce4a42db2514e1">NxBodyDesc.massLocalPose</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="e95d79850f3bcc02883c78cc34250adc"></a><!-- doxytag: member="NxActor::setCMassOffsetGlobalPose" ref="e95d79850f3bcc02883c78cc34250adc" args="(const NxMat34 &amp;mat)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::setCMassOffsetGlobalPose           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxMat34.html">NxMat34</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mat</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The setCMassOffsetGlobal*() methods set the pose of the center of mass relative to world space. 
<p>
Note that this will simply transform the parameter to actor space and then call setCMassLocal*(). In other words it only shifts the center of mass but does not move the actor.<p>
The actor must be dynamic.<p>
<dl compact><dt><b>Note:</b></dt><dd>Setting an unrealistic center of mass which is a long way from the body can make it difficult for the SDK to solve constraints. Perhaps leading to instability and jittering bodies.</dd></dl>
<b>Sleeping:</b> This call wakes the actor if it is sleeping.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mat</em>&nbsp;</td><td>Mass frame offset transform relative to the global frame. <b>Range:</b> rigid body transform.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#4aca9311911904ce9f10ad354149200e">setCMassOffsetGlobalPosition()</a> <a class="el" href="classNxActor.html#241a765f9ca99b4955a83a8cd84ca12f">setCMassOffsetGlobalOrientation()</a> <p>
<a class="el" href="classNxBodyDesc.html#45fedd6e30ac62fe66ce4a42db2514e1">NxBodyDesc.massLocalPose</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="4aca9311911904ce9f10ad354149200e"></a><!-- doxytag: member="NxActor::setCMassOffsetGlobalPosition" ref="4aca9311911904ce9f10ad354149200e" args="(const NxVec3 &amp;vec)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::setCMassOffsetGlobalPosition           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>vec</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The setCMassOffsetGlobal*() methods set the pose of the center of mass relative to world space. 
<p>
See setCMassOffsetGlobalPose() for more information.<p>
<dl compact><dt><b>Note:</b></dt><dd>Setting an unrealistic center of mass which is a long way from the body can make it difficult for the SDK to solve constraints. Perhaps leading to instability and jittering bodies.</dd></dl>
The actor must be dynamic.<p>
<b>Sleeping:</b> This call wakes the actor if it is sleeping.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>vec</em>&nbsp;</td><td>Mass frame offset relative to the global frame. <b>Range:</b> position vector</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#e95d79850f3bcc02883c78cc34250adc">setCMassOffsetGlobalPose()</a> <a class="el" href="classNxActor.html#241a765f9ca99b4955a83a8cd84ca12f">setCMassOffsetGlobalOrientation()</a> <p>
<a class="el" href="classNxBodyDesc.html#45fedd6e30ac62fe66ce4a42db2514e1">NxBodyDesc.massLocalPose</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="e7471526cbec9e27d9738b5d970db4e1"></a><!-- doxytag: member="NxActor::setCMassOffsetLocalOrientation" ref="e7471526cbec9e27d9738b5d970db4e1" args="(const NxMat33 &amp;mat)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::setCMassOffsetLocalOrientation           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxMat33.html">NxMat33</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mat</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The setCMassOffsetLocal*() methods set the pose of the center of mass relative to the actor. 
<p>
See setCMassOffsetLocalPose() for more information.<p>
The actor must be dynamic.<p>
<b>Sleeping:</b> This call wakes the actor if it is sleeping.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mat</em>&nbsp;</td><td>Mass frame orientation offset relative to the actor frame. <b>Range:</b> rotation matrix.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#28eaedf46e44aa650a788afce1a74799">setCMassOffsetLocalPose()</a> <a class="el" href="classNxActor.html#f61452dd6c0d2cada9c40596e4fd5eaa">setCMassOffsetLocalPosition()</a> <a class="el" href="classNxActor.html#e95d79850f3bcc02883c78cc34250adc">setCMassOffsetGlobalPose()</a> <p>
<a class="el" href="classNxBodyDesc.html#45fedd6e30ac62fe66ce4a42db2514e1">NxBodyDesc.massLocalPose</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="28eaedf46e44aa650a788afce1a74799"></a><!-- doxytag: member="NxActor::setCMassOffsetLocalPose" ref="28eaedf46e44aa650a788afce1a74799" args="(const NxMat34 &amp;mat)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::setCMassOffsetLocalPose           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxMat34.html">NxMat34</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mat</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The setCMassOffsetLocal*() methods set the pose of the center of mass relative to the actor. 
<p>
Methods that automatically compute the center of mass such as <a class="el" href="classNxActor.html#8949ba1c4b34408cf20c33fcbcb2016a">updateMassFromShapes()</a> as well as computing the mass and inertia using the actors shapes, will set this pose automatically.<p>
The actor must be dynamic.<p>
<dl compact><dt><b>Note:</b></dt><dd>Changing this transform will not move the actor in the world!<p>
Setting an unrealistic center of mass which is a long way from the body can make it difficult for the SDK to solve constraints. Perhaps leading to instability and jittering bodies.</dd></dl>
<b>Sleeping:</b> This call wakes the actor if it is sleeping.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mat</em>&nbsp;</td><td>Mass frame offset transform relative to the actor frame. <b>Range:</b> rigid body transform.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#f61452dd6c0d2cada9c40596e4fd5eaa">setCMassOffsetLocalPosition()</a> <a class="el" href="classNxActor.html#e7471526cbec9e27d9738b5d970db4e1">setCMassOffsetLocalOrientation()</a> <a class="el" href="classNxActor.html#e95d79850f3bcc02883c78cc34250adc">setCMassOffsetGlobalPose()</a> <p>
<a class="el" href="classNxBodyDesc.html#45fedd6e30ac62fe66ce4a42db2514e1">NxBodyDesc.massLocalPose</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="f61452dd6c0d2cada9c40596e4fd5eaa"></a><!-- doxytag: member="NxActor::setCMassOffsetLocalPosition" ref="f61452dd6c0d2cada9c40596e4fd5eaa" args="(const NxVec3 &amp;vec)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::setCMassOffsetLocalPosition           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>vec</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The setCMassOffsetLocal*() methods set the pose of the center of mass relative to the actor. 
<p>
See setCMassOffsetLocalPose() for more information.<p>
<dl compact><dt><b>Note:</b></dt><dd>Setting an unrealistic center of mass which is a long way from the body can make it difficult for the SDK to solve constraints. Perhaps leading to instability and jittering bodies.</dd></dl>
The actor must be dynamic.<p>
<b>Sleeping:</b> This call wakes the actor if it is sleeping.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>vec</em>&nbsp;</td><td>Mass frame offset relative to the actor frame. <b>Range:</b> position vector</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#28eaedf46e44aa650a788afce1a74799">setCMassOffsetLocalPose()</a> <a class="el" href="classNxActor.html#e7471526cbec9e27d9738b5d970db4e1">setCMassOffsetLocalOrientation()</a> <a class="el" href="classNxActor.html#e95d79850f3bcc02883c78cc34250adc">setCMassOffsetGlobalPose()</a> <p>
<a class="el" href="classNxBodyDesc.html#45fedd6e30ac62fe66ce4a42db2514e1">NxBodyDesc.massLocalPose</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="439d8c2044ad99e009db436f23b957bd"></a><!-- doxytag: member="NxActor::setContactReportFlags" ref="439d8c2044ad99e009db436f23b957bd" args="(NxU32 flags)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::setContactReportFlags           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">NxU32&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>flags</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the actor's contact report flags. 
<p>
These flags are used to determine the kind of report that is generated for interactions with other actors.<p>
The following flags are permitted:<p>
NX_NOTIFY_ON_START_TOUCH NX_NOTIFY_ON_END_TOUCH NX_NOTIFY_ON_TOUCH NX_NOTIFY_ON_IMPACT NX_NOTIFY_ON_ROLL NX_NOTIFY_ON_SLIDE NX_NOTIFY_FORCE NX_NOTIFY_ON_START_TOUCH_FORCE_THRESHOLD NX_NOTIFY_ON_END_TOUCH_FORCE_THRESHOLD NX_NOTIFY_ON_TOUCH_FORCE_THRESHOLD<p>
Please note: If the actor is part of an interacting pair for which the contact report generation is controlled already through any other mechanism (for example by use of <a class="el" href="classNxScene.html#124e55cbcbfa0a5bcf6a8f19f36fd5fe">NxScene::setActorPairFlags</a>) then the union of all the specified contact report flags will be used to generate the report.<p>
See <a class="el" href="classNxActor.html#90ebad2a4ff81c39b4bf4ceb7a6e9a7d">getContactReportFlags()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags to control contact reporting. See <a class="el" href="group__physics.html#g05983d9ea71be115e74f0a5d6a7559cc">NxContactPairFlag</a>.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#90ebad2a4ff81c39b4bf4ceb7a6e9a7d">getContactReportFlags</a> <a class="el" href="group__physics.html#g05983d9ea71be115e74f0a5d6a7559cc">NxContactPairFlag</a> <a class="el" href="classNxActorDescBase.html#ce34b0242412943ef6864c2ac54c6e64">NxActorDesc::contactReportFlags</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="3b9af44989cb866ea5397e32bc54c3f8"></a><!-- doxytag: member="NxActor::setContactReportThreshold" ref="3b9af44989cb866ea5397e32bc54c3f8" args="(NxReal threshold)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::setContactReportThreshold           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>threshold</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the force threshold for contact reports. 
<p>
See <a class="el" href="classNxActor.html#d744903886f3d2f817db1709f3344790">getContactReportThreshold()</a>.<p>
The actor must be dynamic.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>threshold</em>&nbsp;</td><td>Force threshold for contact reports. <b>Range:</b> (0,inf)</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#d744903886f3d2f817db1709f3344790">getContactReportThreshold</a> <a class="el" href="classNxActor.html#90ebad2a4ff81c39b4bf4ceb7a6e9a7d">getContactReportFlags</a> <a class="el" href="group__physics.html#g05983d9ea71be115e74f0a5d6a7559cc">NxContactPairFlag</a> <a class="el" href="classNxBodyDesc.html#f019d3ffb7e762719c16d9f6127cdfc3">NxBodyDesc::contactReportThreshold</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="589c806ed21ba3b8abe624e65d9c46a2"></a><!-- doxytag: member="NxActor::setDominanceGroup" ref="589c806ed21ba3b8abe624e65d9c46a2" args="(NxDominanceGroup dominanceGroup)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::setDominanceGroup           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__physics.html#gd17c09bc9705b7db96e260dffffdb381">NxDominanceGroup</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>dominanceGroup</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Assigns dynamic actors a dominance group identifier. 
<p>
NxDominanceGroup is a 5 bit group identifier (legal range from 0 to 31).<p>
This is similar to <a class="el" href="classNxShape.html">NxShape</a> groups, except those serve a different purpose.<p>
The <a class="el" href="classNxScene.html#b3a23eb788d2c6e290e3d14d8d5a2a79">NxScene::setDominanceGroupPair()</a> lets you set certain behaviors for pairs of dominance groups. By default every actor is created in group 0. Static actors must stay in group 0; thus you can only call this on dynamic actors.<p>
<b>Sleeping:</b> Changing the dominance group does <b>NOT</b> wake the actor up automatically.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#0809ec35a615e40824d13bf373ef3587">getDominanceGroup()</a> <a class="el" href="group__physics.html#gd17c09bc9705b7db96e260dffffdb381">NxDominanceGroup</a> <a class="el" href="classNxScene.html#b3a23eb788d2c6e290e3d14d8d5a2a79">NxScene::setDominanceGroupPair()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="7b1a009bb5b57cf98e5983fffe377bb2"></a><!-- doxytag: member="NxActor::setForceFieldMaterial" ref="7b1a009bb5b57cf98e5983fffe377bb2" args="(NxForceFieldMaterial)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::setForceFieldMaterial           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__physics.html#g6a78f0087de2bc790aff345a36f7552f">NxForceFieldMaterial</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the actor's force field material index, default index is 0. 
<p>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes [SW fallback] </li>
<li>PS3 : Yes </li>
<li>XB360: Yes </li>
</ul>
    </td>
  </tr>
</table>
<a class="anchor" name="f7a9b57b9709f7d0ce65023f69f7e56d"></a><!-- doxytag: member="NxActor::setGlobalOrientation" ref="f7a9b57b9709f7d0ce65023f69f7e56d" args="(const NxMat33 &amp;mat)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::setGlobalOrientation           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxMat33.html">NxMat33</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mat</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets a dynamic actor's orientation in the world. 
<p>
see setGlobalPose() for information.<p>
<b>Sleeping:</b> This call wakes the actor if it is sleeping.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mat</em>&nbsp;</td><td>New orientation for the actors frame. <b>Range:</b> rotation matrix.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#f93c356e369a3bb597d82884f1a7d093">setGlobalPose()</a> <a class="el" href="classNxActor.html#4daa5f22e293c6e5285aa60f4e9f1c64">setGlobalPosition()</a> <a class="el" href="classNxActor.html#e97d7d8704e754c9601a8a48f2163a29">getGlobalOrientation()</a> <a class="el" href="classNxActor.html#17828ae6bbd157fdce20b8182a7448c7">setGlobalOrientationQuat()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="17828ae6bbd157fdce20b8182a7448c7"></a><!-- doxytag: member="NxActor::setGlobalOrientationQuat" ref="17828ae6bbd157fdce20b8182a7448c7" args="(const NxQuat &amp;mat)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::setGlobalOrientationQuat           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxQuat.html">NxQuat</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mat</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets a dynamic actor's orientation in the world. 
<p>
see setGlobalPose() for information.<p>
<b>Sleeping:</b> This call wakes the actor if it is sleeping.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mat</em>&nbsp;</td><td>New orientation for the actors frame.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#f7a9b57b9709f7d0ce65023f69f7e56d">setGlobalOrientation()</a> <a class="el" href="classNxActor.html#e97d7d8704e754c9601a8a48f2163a29">getGlobalOrientation()</a> <a class="el" href="classNxActor.html#f93c356e369a3bb597d82884f1a7d093">setGlobalPose()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="f93c356e369a3bb597d82884f1a7d093"></a><!-- doxytag: member="NxActor::setGlobalPose" ref="f93c356e369a3bb597d82884f1a7d093" args="(const NxMat34 &amp;mat)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::setGlobalPose           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxMat34.html">NxMat34</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mat</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Methods for setting a dynamic actor's pose in the world. 
<p>
These methods instantaneously change the actor space to world space transformation.<p>
One should exercise restraint in making use of these methods.<p>
Static actors should not be moved at all. There are various internal data structures for static actors which may need to be recomputed when one moves. Also, moving static actors will not interact correctly with dynamic actors or joints. If you would like to directly control an actor's position and would like to have it correctly interact with dynamic bodies and joints, you should create a dynamic body with the NX_BF_KINEMATIC flag, and then use the moveGlobal*() commands to move it along a path!<p>
When briefly moving dynamic actors, one should not:<p>
<ul>
<li>Move actors into other actors, thus causing interpenetration (an invalid physical state)</li>
</ul>
<ul>
<li>Move an actor that is connected by a joint to another away from the other (thus causing joint error)</li>
</ul>
<ul>
<li>When moving jointed actors the joints' cached transform information is destroyed and recreated next frame; thus this call is expensive for jointed actors.</li>
</ul>
setGlobalPose(m) has the same effect as calling setGlobalOrientation(m.M); and setGlobalPosition(m.t); but <a class="el" href="classNxActor.html#f93c356e369a3bb597d82884f1a7d093">setGlobalPose()</a> may be faster as it doesn't recompute some internal values twice.<p>
<b>Sleeping:</b> This call wakes the actor if it is sleeping.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mat</em>&nbsp;</td><td>Transformation from the actors local frame to the global frame. <b>Range:</b> rigid body transform.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#6b7682f757f66754c2ae09c990580729">getGlobalPose()</a> <a class="el" href="classNxActor.html#4daa5f22e293c6e5285aa60f4e9f1c64">setGlobalPosition()</a> <a class="el" href="classNxActor.html#f7a9b57b9709f7d0ce65023f69f7e56d">setGlobalOrientation()</a> <a class="el" href="classNxActor.html#6b7682f757f66754c2ae09c990580729">getGlobalPose()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="4daa5f22e293c6e5285aa60f4e9f1c64"></a><!-- doxytag: member="NxActor::setGlobalPosition" ref="4daa5f22e293c6e5285aa60f4e9f1c64" args="(const NxVec3 &amp;vec)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::setGlobalPosition           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>vec</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets a dynamic actor's position in the world. 
<p>
see setGlobalPose() for information.<p>
<b>Sleeping:</b> This call wakes the actor if it is sleeping.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>vec</em>&nbsp;</td><td>New position for the actors frame relative to the global frame. <b>Range:</b> position vector</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#f93c356e369a3bb597d82884f1a7d093">setGlobalPose()</a> <a class="el" href="classNxActor.html#f7a9b57b9709f7d0ce65023f69f7e56d">setGlobalOrientation()</a> <a class="el" href="classNxActor.html#f81aaa2fbe517aa236acede75e241522">getGlobalPosition()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="3f2e3d34803c146d47264099cf27a7dc"></a><!-- doxytag: member="NxActor::setGroup" ref="3f2e3d34803c146d47264099cf27a7dc" args="(NxActorGroup actorGroup)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::setGroup           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__physics.html#gd7d66f3c79185448a29cbc084ddcfefb">NxActorGroup</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>actorGroup</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Assigns the actor to a user defined group of actors. 
<p>
NxActorGroup is a 16 bit group identifier.<p>
This is similar to <a class="el" href="classNxShape.html">NxShape</a> groups, except those are only five bits and serve a different purpose.<p>
The <a class="el" href="classNxScene.html#c918ed0ade26efb4df810e495924e05c">NxScene::setActorGroupPairFlags()</a> lets you set certain behaviors for pairs of actor groups. By default every actor is created in group 0.<p>
<b>Sleeping:</b> Does <b>NOT</b> wake the actor up automatically.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actorGroup</em>&nbsp;</td><td>The actor group flags.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : No </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#13d0bf7a27e8870eb93e233dbb8107ec">getGroup()</a> <a class="el" href="group__physics.html#gd7d66f3c79185448a29cbc084ddcfefb">NxActorGroup</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="79bc94be0beb90538460d4393854349b"></a><!-- doxytag: member="NxActor::setLinearDamping" ref="79bc94be0beb90538460d4393854349b" args="(NxReal linDamp)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::setLinearDamping           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>linDamp</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the linear damping coefficient. 
<p>
Zero represents no damping. The damping coefficient must be nonnegative.<p>
The actor must be dynamic.<p>
<b>Default:</b> 0.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>linDamp</em>&nbsp;</td><td>Linear damping coefficient. <b>Range:</b> [0,inf)</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#d88b80155a233e0d2f32e406acd9ec6e">getLinearDamping()</a> <a class="el" href="classNxActor.html#01a17cd835e78b04de9451255772a6f3">setAngularDamping()</a> <a class="el" href="classNxBodyDesc.html#a5c0ec194846727d13d6c735ac2e5d1a">NxBodyDesc.linearDamping</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="5b68e76f72476013feb078fc227a9e6a"></a><!-- doxytag: member="NxActor::setLinearMomentum" ref="5b68e76f72476013feb078fc227a9e6a" args="(const NxVec3 &amp;linMoment)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::setLinearMomentum           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>linMoment</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the linear momentum of the actor. 
<p>
Note that if you continuously set the linear momentum of an actor yourself, forces such as gravity or friction will not be able to manifest themselves, because forces directly influence only the velocity/momentum of a actor.<p>
The actor must be dynamic.<p>
<b>Sleeping:</b> This call wakes the actor if it is sleeping.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>linMoment</em>&nbsp;</td><td>New linear momentum. <b>Range:</b> momentum vector</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#439cad6fb757784e330b433c1aa22d57">getLinearMomentum()</a> <a class="el" href="classNxActor.html#89045d712932139196698354ad5866aa">setAngularMomentum()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="3109aa69b2cf09b340b622a3e4509620"></a><!-- doxytag: member="NxActor::setLinearVelocity" ref="3109aa69b2cf09b340b622a3e4509620" args="(const NxVec3 &amp;linVel)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::setLinearVelocity           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>linVel</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the linear velocity of the actor. 
<p>
Note that if you continuously set the velocity of an actor yourself, forces such as gravity or friction will not be able to manifest themselves, because forces directly influence only the velocity/momentum of an actor.<p>
The actor must be dynamic.<p>
<b>Sleeping:</b> This call wakes the actor if it is sleeping.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>linVel</em>&nbsp;</td><td>New linear velocity of actor. <b>Range:</b> velocity vector</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#b7c9eaeae7a6363523f10c660cb19468">getLinearVelocity()</a> <a class="el" href="classNxActor.html#7528388b02798682b09470aaa755b7b3">setAngularVelocity()</a> <a class="el" href="classNxBodyDesc.html#ccbb4c762cf11737a0a91e36874ecd66">NxBodyDesc.linearVelocity</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="1f64986638e085cd62a82a1f029ce29f"></a><!-- doxytag: member="NxActor::setMass" ref="1f64986638e085cd62a82a1f029ce29f" args="(NxReal mass)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::setMass           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mass</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the mass of a dynamic actor. 
<p>
The mass must be positive and the actor must be dynamic.<p>
<a class="el" href="classNxActor.html#1f64986638e085cd62a82a1f029ce29f">setMass()</a> does not update the inertial properties of the body, to change the inertia tensor use <a class="el" href="classNxActor.html#fdd5c9c2a24a326e444743d93799c3a6">setMassSpaceInertiaTensor()</a> or <a class="el" href="classNxActor.html#8949ba1c4b34408cf20c33fcbcb2016a">updateMassFromShapes()</a>.<p>
<b>Sleeping:</b> Does <b>NOT</b> wake the actor up automatically.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mass</em>&nbsp;</td><td>New mass value for the actor. <b>Range:</b> (0,inf)</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#bddfefef2f494f1592cdaee18013ed69">getMass()</a> <a class="el" href="classNxBodyDesc.html#ca2dff6c4201ea1f6c98ba1872d78cfc">NxBodyDesc.mass</a> <a class="el" href="classNxActor.html#fdd5c9c2a24a326e444743d93799c3a6">setMassSpaceInertiaTensor()</a> <a class="el" href="classNxActor.html#8949ba1c4b34408cf20c33fcbcb2016a">updateMassFromShapes()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="fdd5c9c2a24a326e444743d93799c3a6"></a><!-- doxytag: member="NxActor::setMassSpaceInertiaTensor" ref="fdd5c9c2a24a326e444743d93799c3a6" args="(const NxVec3 &amp;m)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::setMassSpaceInertiaTensor           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classNxVec3.html">NxVec3</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>m</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the inertia tensor, using a parameter specified in mass space coordinates. 
<p>
Note that such matrices are diagonal -- the passed vector is the diagonal.<p>
If you have a non diagonal world/actor space inertia tensor(3x3 matrix). Then you need to diagonalize it and set an appropriate mass space transform. See <a class="el" href="classNxActor.html#28eaedf46e44aa650a788afce1a74799">setCMassOffsetLocalPose()</a>.<p>
The actor must be dynamic.<p>
<b>Sleeping:</b> Does <b>NOT</b> wake the actor up automatically.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>m</em>&nbsp;</td><td>New mass space inertia tensor for the actor. <b>Range:</b> inertia vector</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxBodyDesc.html#df34de0163d0d8825513c2f8da30b47a">NxBodyDesc.massSpaceInertia</a> getMassSpaceInertia() <a class="el" href="classNxActor.html#1f64986638e085cd62a82a1f029ce29f">setMass()</a> <a class="el" href="classNxActor.html#28eaedf46e44aa650a788afce1a74799">setCMassOffsetLocalPose()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="b5a92000f85cad10c0fe1553dcbc1a5d"></a><!-- doxytag: member="NxActor::setMaxAngularVelocity" ref="b5a92000f85cad10c0fe1553dcbc1a5d" args="(NxReal maxAngVel)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::setMaxAngularVelocity           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>maxAngVel</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Lets you set the maximum angular velocity permitted for this actor. 
<p>
Because for various internal computations, very quickly rotating actors introduce error into the simulation, which leads to undesired results.<p>
With NxPhysicsSDK::setParameter(NX_MAX_ANGULAR_VELOCITY) you can set the default maximum velocity for actors created after the call. Bodies' high angular velocities are clamped to this value.<p>
However, because some actors, such as car wheels, should be able to rotate quickly, you can override the default setting on a per-actor basis with the below call. Note that objects such as wheels which are approximated with spherical or other smooth collision primitives can be simulated with stability at a much higher angular velocity than, say, a box that has corners.<p>
Note: The angular velocity is clamped to the set value <em>before</em> the solver, which means that the limit may still be momentarily exceeded.<p>
The actor must be dynamic.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxAngVel</em>&nbsp;</td><td>Max allowable angular velocity for actor. <b>Range:</b> (0,inf)</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#8cbf35f56b3a36154127a8ab98950794">getMaxAngularVelocity()</a> <a class="el" href="classNxBodyDesc.html#bab160fcce9598c95d74b9f52c0d327e">NxBodyDesc.maxAngularVelocity</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="2b6c86db5bb50044dcddbc8d76c1e93d"></a><!-- doxytag: member="NxActor::setName" ref="2b6c86db5bb50044dcddbc8d76c1e93d" args="(const char *name)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::setName           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>name</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets a name string for the object that can be retrieved with <a class="el" href="classNxActor.html#41d5cd1b7e48dc555fbb7dda4545aa55">getName()</a>. 
<p>
This is for debugging and is not used by the SDK. The string is not copied by the SDK, only the pointer is stored.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>String to set the objects name to.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#41d5cd1b7e48dc555fbb7dda4545aa55">getName()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="08ba74338fa41fd7d904e4e28c629089"></a><!-- doxytag: member="NxActor::setSleepAngularVelocity" ref="08ba74338fa41fd7d904e4e28c629089" args="(NxReal threshold)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::setSleepAngularVelocity           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>threshold</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the angular velocity below which an actor may go to sleep. 
<p>
Actors whose angular velocity is above this threshold will not be put to sleep.<p>
If the threshold value is negative, the velocity threshold is set using the NxPhysicsSDK's NX_DEFAULT_SLEEP_LIN_VEL_SQUARED parameter.<p>
Setting the sleep angular/linear velocity only makes sense when the NX_BF_ENERGY_SLEEP_TEST is not set. In version 2.5 and later a new method is used by default which uses the kinetic energy of the body to control sleeping.<p>
The actor must be dynamic.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>threshold</em>&nbsp;</td><td>Angular velocity below which an actor may go to sleep. <b>Range:</b> (0,inf]</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#529efc4d1ee46a7f42da2675913600f5">isGroupSleeping()</a> <a class="el" href="classNxActor.html#d42ee1a227f0ee512837ee8a250725f4">isSleeping()</a> <a class="el" href="classNxActor.html#0fbe05f29e7c786cb56a484376b01714">getSleepLinearVelocity()</a> <a class="el" href="classNxActor.html#d9cf5337c1ca98761f036eb6b6f5268c">getSleepAngularVelocity()</a> <a class="el" href="classNxActor.html#f3548981641eec58a3761331682298b7">wakeUp()</a> <a class="el" href="classNxActor.html#708cf737477f4787e0a4983ff391c02c">putToSleep()</a> <a class="el" href="classNxActor.html#4e29571507ee435c74ccda913a13888c">setSleepLinearVelocity()</a> <a class="el" href="classNxActor.html#1680326ee54d224d7cbe2e373a5599ad">setSleepEnergyThreshold()</a> <a class="el" href="classNxActor.html#2e77d74a928ea62456b0156e98061ea7">getSleepEnergyThreshold()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="1680326ee54d224d7cbe2e373a5599ad"></a><!-- doxytag: member="NxActor::setSleepEnergyThreshold" ref="1680326ee54d224d7cbe2e373a5599ad" args="(NxReal threshold)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::setSleepEnergyThreshold           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>threshold</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the energy threshold below which an actor may go to sleep. 
<p>
Actors whose kinematic energy is above this threshold will not be put to sleep.<p>
If the threshold value is negative, the velocity threshold is set using the NxPhysicsSDK's NX_DEFAULT_SLEEP_ENERGY parameter.<p>
Setting the sleep energy threshold only makes sense when the NX_BF_ENERGY_SLEEP_TEST is set. There are also other types of sleeping that uses the linear and angular velocities directly instead of the energy.<p>
The actor must be dynamic.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>threshold</em>&nbsp;</td><td>Energy below which an actor may go to sleep. <b>Range:</b> (0,inf]</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#529efc4d1ee46a7f42da2675913600f5">isGroupSleeping()</a> <a class="el" href="classNxActor.html#d42ee1a227f0ee512837ee8a250725f4">isSleeping()</a> <a class="el" href="classNxActor.html#2e77d74a928ea62456b0156e98061ea7">getSleepEnergyThreshold()</a> <a class="el" href="classNxActor.html#0fbe05f29e7c786cb56a484376b01714">getSleepLinearVelocity()</a> <a class="el" href="classNxActor.html#d9cf5337c1ca98761f036eb6b6f5268c">getSleepAngularVelocity()</a> <a class="el" href="classNxActor.html#f3548981641eec58a3761331682298b7">wakeUp()</a> <a class="el" href="classNxActor.html#708cf737477f4787e0a4983ff391c02c">putToSleep()</a> <a class="el" href="classNxActor.html#4e29571507ee435c74ccda913a13888c">setSleepLinearVelocity()</a> <a class="el" href="classNxActor.html#08ba74338fa41fd7d904e4e28c629089">setSleepAngularVelocity()</a> <a class="el" href="classNxBodyDesc.html#3573812de588ecfa626795b1306e181d">NxBodyDesc.sleepEnergyThreshold</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="4e29571507ee435c74ccda913a13888c"></a><!-- doxytag: member="NxActor::setSleepLinearVelocity" ref="4e29571507ee435c74ccda913a13888c" args="(NxReal threshold)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::setSleepLinearVelocity           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>threshold</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the linear velocity below which an actor may go to sleep. 
<p>
Actors whose linear velocity is above this threshold will not be put to sleep.<p>
If the threshold value is negative, the velocity threshold is set using the NxPhysicsSDK's NX_DEFAULT_SLEEP_LIN_VEL_SQUARED parameter.<p>
Setting the sleep angular/linear velocity only makes sense when the NX_BF_ENERGY_SLEEP_TEST is not set. In version 2.5 and later a new method is used by default which uses the kinetic energy of the body to control sleeping.<p>
The actor must be dynamic.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>threshold</em>&nbsp;</td><td>Linear velocity below which an actor may sleep. <b>Range:</b> (0,inf]</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#529efc4d1ee46a7f42da2675913600f5">isGroupSleeping()</a> <a class="el" href="classNxActor.html#d42ee1a227f0ee512837ee8a250725f4">isSleeping()</a> <a class="el" href="classNxActor.html#0fbe05f29e7c786cb56a484376b01714">getSleepLinearVelocity()</a> <a class="el" href="classNxActor.html#d9cf5337c1ca98761f036eb6b6f5268c">getSleepAngularVelocity()</a> <a class="el" href="classNxActor.html#f3548981641eec58a3761331682298b7">wakeUp()</a> <a class="el" href="classNxActor.html#708cf737477f4787e0a4983ff391c02c">putToSleep()</a> <a class="el" href="classNxActor.html#1680326ee54d224d7cbe2e373a5599ad">setSleepEnergyThreshold()</a> <a class="el" href="classNxActor.html#2e77d74a928ea62456b0156e98061ea7">getSleepEnergyThreshold()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="928d70f4e509322678da747de322bc26"></a><!-- doxytag: member="NxActor::setSolverIterationCount" ref="928d70f4e509322678da747de322bc26" args="(NxU32 iterCount)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::setSolverIterationCount           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">NxU32&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>iterCount</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the solver iteration count for the body. 
<p>
The solver iteration count determines how accurately joints and contacts are resolved. If you are having trouble with jointed bodies oscillating and behaving erratically, then setting a higher solver iteration count may improve their stability.<p>
The actor must be dynamic.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>iterCount</em>&nbsp;</td><td>Number of iterations the solver should perform for this body. <b>Range:</b> [1,255]</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#d24021d2a57fef1c2c66c537b25c19a8">getSolverIterationCount()</a> <a class="el" href="classNxBodyDesc.html#6fe9a4d43a13afa702ffe66ec9abcf9b">NxBodyDesc.solverIterationCount</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="8949ba1c4b34408cf20c33fcbcb2016a"></a><!-- doxytag: member="NxActor::updateMassFromShapes" ref="8949ba1c4b34408cf20c33fcbcb2016a" args="(NxReal density, NxReal totalMass)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual bool NxActor::updateMassFromShapes           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>density</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>totalMass</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Recomputes a dynamic actor's mass properties from its shapes. 
<p>
Given a constant density or total mass, the actors mass properties can be recomputed using the shapes attached to the actor. If the actor has no shapes, then only the totalMass parameter can be used. If all shapes in the actor are trigger shapes (non-physical), the call will fail.<p>
The mass of each shape is either the shape's local density (as specified in the <a class="el" href="classNxShapeDesc.html">NxShapeDesc</a>; default 1.0) multiplied by the shape's volume or a directly specified shape mass.<p>
The inertia tensor, mass frame and center of mass will always be recomputed. If there are no shapes in the actor, the mass will be totalMass, and the mass frame will be set to the center of the actor.<p>
If you supply a non-zero total mass, the actor's mass and inertia will first be computed as above and then scaled to fit this total mass.<p>
If you supply a non-zero density, the actor's mass and inertia will first be computed as above and then scaled by this factor.<p>
Either totalMass or density must be non-zero.<p>
The actor must be dynamic.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>density</em>&nbsp;</td><td>Density scale factor of the shapes belonging to the actor. <b>Range:</b> [0,inf) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>totalMass</em>&nbsp;</td><td>Total mass of the actor(or zero). <b>Range:</b> [0,inf)</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True if successful.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActorDesc.html">NxActorDesc</a> <a class="el" href="classNxBodyDesc.html">NxBodyDesc</a> <a class="el" href="classNxBodyDesc.html#ca2dff6c4201ea1f6c98ba1872d78cfc">NxBodyDesc.mass</a> <a class="el" href="classNxActorDescBase.html#b0ea9bea795de81d22ada690234b50dd">NxActorDesc.density</a> NxActorDesc.lockCOM </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="f3548981641eec58a3761331682298b7"></a><!-- doxytag: member="NxActor::wakeUp" ref="f3548981641eec58a3761331682298b7" args="(NxReal wakeCounterValue=NX_SLEEP_INTERVAL)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void NxActor::wakeUp           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__foundation.html#g6a502840309665cbb1fc655de7cde737">NxReal</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>wakeCounterValue</em> = <code>NX_SLEEP_INTERVAL</code>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wakes up the actor if it is sleeping. 
<p>
The wakeCounterValue determines how long until the body is put to sleep, a value of zero means that the body is sleeping. wakeUp(0) is equivalent to <a class="el" href="classNxActor.html#708cf737477f4787e0a4983ff391c02c">NxActor::putToSleep()</a>.<p>
The actor must be dynamic.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wakeCounterValue</em>&nbsp;</td><td>New sleep counter value. <b>Range:</b> [0,inf]</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classNxActor.html#529efc4d1ee46a7f42da2675913600f5">isGroupSleeping()</a> <a class="el" href="classNxActor.html#d42ee1a227f0ee512837ee8a250725f4">isSleeping()</a> <a class="el" href="classNxActor.html#0fbe05f29e7c786cb56a484376b01714">getSleepLinearVelocity()</a> <a class="el" href="classNxActor.html#d9cf5337c1ca98761f036eb6b6f5268c">getSleepAngularVelocity()</a> <a class="el" href="classNxActor.html#708cf737477f4787e0a4983ff391c02c">putToSleep()</a> </dd></dl>
    </td>
  </tr>
</table>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="40f0b150b42d632f5646d549be95b305"></a><!-- doxytag: member="NxActor::userData" ref="40f0b150b42d632f5646d549be95b305" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void* <a class="el" href="classNxActor.html#40f0b150b42d632f5646d549be95b305">NxActor::userData</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
user can assign this to whatever, usually to create a 1:1 relationship with a user object. 
<p>
    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="NxActor_8h-source.html">NxActor.h</a></ul>

<hr style="width: 100%; height: 2px;"><a><br>
</a>
Copyright &copy; 2008 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</body>
</html>
